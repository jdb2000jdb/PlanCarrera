<!DOCTYPE html>
<html lang="es-AR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Herramienta educativa universitaria sobre C++. Basada en Deitel y O'Reilly.">
    <title>Unidad Did√°ctica 02 - Paradigma de Objetos - Parte 1</title>
    
    <!-- Fuentes Acad√©micas -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;1,400&family=Roboto+Mono:wght@400;500&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-primary: #fdfdfd;
            --bg-secondary: #f4f4f4;
            --bg-paper: #ffffff;
            --text-primary: #212121;
            --text-secondary: #5f6368;
            --accent: #0056b3; 
            --accent-hover: #003d80;
            --code-bg: #f5f5f5;
            --border: #e0e0e0;
            --shadow: 0 4px 6px rgba(0,0,0,0.1);
            --timeline-line: #ccc;
            --success: #2e7d32;
        }

        [data-theme="dark"] {
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-paper: #242424;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --accent: #64b5f6;
            --accent-hover: #42a5f5;
            --code-bg: #2d2d2d;
            --border: #333333;
            --shadow: 0 4px 6px rgba(0,0,0,0.5);
            --timeline-line: #444;
            --success: #81c784;
        }

        * {
            box-sizing: border-box;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        body {
            font-family: 'Merriweather', serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.8;
            margin: 0;
            overflow-x: hidden;
        }

        /* Tipograf√≠a */
        h1, h2, h3, h4 {
            font-family: 'Roboto', sans-serif;
            margin-top: 1.5em;
        }

        h1 { font-weight: 700; font-size: 2.2rem; text-align: center; margin-bottom: 2rem; }
        h1 a { text-decoration: none; color: var(--accent); }
        h2 { border-bottom: 2px solid var(--accent); padding-bottom: 0.5rem; color: var(--accent); font-size: 1.8rem; }
        h3 { color: var(--text-primary); border-left: 4px solid var(--accent); padding-left: 1rem; }
        
        p { margin-bottom: 1.2rem; font-size: 1.05rem; text-align: justify; }

        code {
            font-family: 'Roboto Mono', monospace;
            background-color: var(--code-bg);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-size: 0.9em;
            color: var(--accent);
        }

        pre {
            background-color: var(--code-bg);
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 5px solid var(--accent);
            box-shadow: var(--shadow);
            margin: 1.5rem 0;
        }

        /* Layout */
        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            min-height: 100vh;
        }

        aside {
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--border);
            height: 100vh;
            position: sticky;
            top: 0;
            overflow-y: auto;
            padding: 2rem 1.5rem;
            display: flex;
            flex-direction: column;
        }

        .nav-header h2 { border: none; font-size: 1.2rem; margin-bottom: 1rem; color: var(--text-primary); }

        .nav-links { list-style: none; padding: 0; margin: 0; }
        .nav-links li { margin-bottom: 0.3rem; }
        .nav-links a {
            text-decoration: none;
            color: var(--text-secondary);
            font-family: 'Roboto', sans-serif;
            font-size: 0.85rem;
            display: block;
            padding: 0.6rem;
            border-radius: 6px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .nav-links a:hover, .nav-links a.active {
            background-color: var(--accent);
            color: #ffffff;
            padding-left: 1.2rem;
            box-shadow: var(--shadow);
        }

        main {
            padding: 4rem 8%;
            max-width: 1400px;
            margin: 0 auto;
        }

        section {
            scroll-margin-top: 5rem;
            margin-bottom: 6rem;
            padding: 3rem;
            background-color: var(--bg-paper);
            border-radius: 12px;
            box-shadow: var(--shadow);
            animation: slideUp 0.8s ease-out forwards;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(40px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Tooltips */
        .abbr {
            border-bottom: 2px dotted var(--accent);
            cursor: help;
            position: relative;
            color: var(--accent);
            font-weight: 600;
        }

        .abbr:hover::after {
            content: attr(data-title);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: #fff;
            padding: 0.6rem 1rem;
            border-radius: 6px;
            font-size: 0.85rem;
            white-space: normal;
            min-width: 200px;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            font-family: 'Roboto', sans-serif;
            text-align: center;
        }

        /* Timeline */
        .timeline {
            position: relative;
            padding-left: 3rem;
            margin: 3rem 0;
            border-left: 4px solid var(--accent);
        }
        .timeline-item { margin-bottom: 2.5rem; position: relative; }
        .timeline-item::before {
            content: '';
            position: absolute;
            left: -3.65rem;
            top: 0.2rem;
            width: 1.2rem;
            height: 1.2rem;
            background: var(--bg-paper);
            border: 4px solid var(--accent);
            border-radius: 50%;
        }
        .timeline-date { font-weight: 800; color: var(--accent); font-size: 1.1rem; display: block; }

        /* Diagramas */
        .diagram-mem {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 2rem 0;
        }
        .mem-cell {
            border: 2px solid var(--border);
            padding: 1rem;
            text-align: center;
            background: var(--bg-secondary);
            border-radius: 4px;
        }
        .mem-cell.active { border-color: var(--accent); background: rgba(0,86,179,0.1); }

        /* Tablas */
        .table-res { overflow-x: auto; margin: 2rem 0; border-radius: 8px; border: 1px solid var(--border); }
        table { width: 100%; border-collapse: collapse; background: var(--bg-paper); }
        th, td { padding: 1.2rem; text-align: left; border-bottom: 1px solid var(--border); }
        th { background-color: var(--bg-secondary); color: var(--accent); text-transform: uppercase; font-size: 0.8rem; letter-spacing: 1px; }

        /* UI Elements */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.6rem;
            z-index: 1000;
        }

        .btn-ref {
            display: inline-block;
            background: transparent;
            border: 2px solid var(--accent);
            color: var(--accent);
            padding: 0.6rem 1.2rem;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-weight: 500;
            margin-top: 1rem;
            transition: all 0.3s;
        }
        .btn-ref:hover { background: var(--accent); color: white; }

        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: var(--bg-paper);
            padding: 3rem;
            border-radius: 12px;
            max-width: 700px;
            width: 90%;
            position: relative;
        }

        .practice-box {
            background: rgba(46, 125, 50, 0.05);
            border-left: 6px solid var(--success);
            padding: 2rem;
            margin: 2rem 0;
            border-radius: 0 8px 8px 0;
        }

        .icon-sec { font-size: 2.5rem; margin-bottom: 1rem; display: block; }

        /* Responsive */
        @media (max-width: 1024px) {
            .app-container { grid-template-columns: 1fr; }
            aside { display: none; }
            main { padding: 2rem 5%; }
        }
    </style>
</head>
<body>

<div class="app-container">
    <aside>
        <div class="nav-header">
            <h2>CONTENIDOS</h2>
            <p style="font-size: 0.75rem; color: var(--text-secondary);">Gu√≠a Universitaria de C++</p>
        </div>
        <ul class="nav-links">
            <li><a href="#sec-2">2 Introducci√≥n</a></li>
            <li><a href="#sec-2-1">2.1 Introducci√≥n al Lenguaje</a></li>
            <li><a href="#sec-2-2">2.2 Su primer programa: Salida</a></li>
            <li><a href="#sec-2-3">2.3 Modificando el programa</a></li>
            <li><a href="#sec-2-4">2.4 Suma de Enteros</a></li>
            <li><a href="#sec-2-5">2.5 Conceptos de Memoria</a></li>
            <li><a href="#sec-2-6">2.6 Aritm√©tica en C++</a></li>
            <li><a href="#sec-2-7">2.7 Toma de decisiones</a></li>
            <li><a href="#sec-2-8">2.8 Ingenier√≠a: Caso ATM</a></li>
            <li><a href="#sec-2-9">2.9 Repaso General</a></li>
        </ul>
    </aside>

    <main>
        <header id="home">
            <h1><a href="#home">Unidad Did√°ctica 02 - Paradigma de Objetos - Parte 1</a></h1>
            <p style="text-align: center; font-style: italic;">"La maestr√≠a en el desarrollo de software comienza con el dominio de los fundamentos de la sintaxis y la arquitectura de memoria."</p>
        </header>

        <!-- 2 Introducci√≥n -->
        <section id="sec-2">
            <span class="icon-sec">üöÄ</span>
            <h2>2 Introducci√≥n a la programaci√≥n en C++</h2>
            <p>Usted est√° por comenzar un viaje t√©cnico profundo. C++ no es simplemente otro lenguaje; es el est√°ndar de oro para aplicaciones que requieren alto rendimiento, control de hardware y robustez arquitect√≥nica. Como futuros ingenieros o licenciados, deben entender que en C++ cada l√≠nea de c√≥digo tiene una repercusi√≥n directa en la eficiencia del sistema.</p>
            <p>Basado en el enfoque de <strong>Deitel</strong>, este cap√≠tulo desglosa los componentes elementales: desde c√≥mo el <span class="abbr" data-title="Compilador: Programa que traduce el c√≥digo fuente (C++) a c√≥digo m√°quina ejecutable.">compilador</span> procesa sus intenciones hasta c√≥mo se organiza la informaci√≥n en los circuitos de la computadora. Seg√∫n el cuaderno de <strong>Metodolog√≠as Activas</strong>, se recomienda que usted no solo lea, sino que tipee cada ejemplo en su <span class="abbr" data-title="IDE: Integrated Development Environment (Entorno de Desarrollo Integrado).">IDE</span> favorito para generar memoria procedimental.</p>
            <button class="btn-ref" onclick="openRef('ref-2')">Referencia: Deitel Cap. 2</button>
        </section>

        <!-- 2.1 Introducci√≥n -->
		<section id="sec-2-1">
            <span class="icon-sec">üìñ</span>
            <h2>2.1 Introducci√≥n al lenguaje C++</h2>
            <p>El lenguaje de programaci√≥n C++ representa uno de los pilares fundamentales de la computaci√≥n moderna, dise√±ado originalmente por <span class="abbr" data-title="Bjarne Stroustrup: Creador de C++ en AT&T Bell Labs (1979). Su objetivo era a√±adir caracter√≠sticas de Simula 67 al lenguaje C para facilitar el desarrollo de sistemas complejos sin sacrificar la eficiencia de bajo nivel.">Bjarne Stroustrup</span> a principios de la d√©cada de 1980 en los laboratorios AT&T Bell. Su creaci√≥n no fue un evento aislado, sino el resultado de una necesidad cr√≠tica: la capacidad de organizar y procesar cantidades masivas de informaci√≥n de manera eficiente mientras se mantiene la cercan√≠a al hardware. C++ evolucion√≥ a partir del lenguaje C, el cual a su vez hered√≥ caracter√≠sticas de los lenguajes BCPL (1967) y B (1970). Como indica el PDF de <strong>Deitel</strong>, C++ es un lenguaje <strong>multiparadigma</strong> que permite a los desarrolladores elegir entre la programaci√≥n estructurada, la programaci√≥n orientada a objetos (POO) o la programaci√≥n gen√©rica mediante plantillas, adapt√°ndose a las exigencias de rendimiento de sistemas operativos, aplicaciones gr√°ficas y firmware.</p>
            
            <p>Desde una perspectiva acad√©mica, la filosof√≠a de C++ se basa en el principio de "no pagar por lo que no se usa", lo que significa que las abstracciones de alto nivel no deben imponer una penalizaci√≥n de rendimiento sobre el c√≥digo escrito a bajo nivel. [cite_start]Seg√∫n el PDF de <strong>O'Reilly</strong>, C++ act√∫a como un puente entre el programador y la "m√°quina cruda", obligando al desarrollador a comprender c√≥mo se organiza la memoria en bytes y c√≥mo las instrucciones son traducidas por el compilador en c√≥digo m√°quina ejecutable[cite: 2000, 2001].</p>

            <h3>Evoluci√≥n Hist√≥rica y Estandarizaci√≥n</h3>
            <div class="timeline">
                <div class="timeline-item">
                    <span class="timeline-date">1967-1970: Antecedentes (BCPL y B)</span>
                    <p>Martin Richards desarrolla BCPL para escribir sistemas operativos. Posteriormente, Ken Thompson crea el lenguaje B, basado en BCPL, para implementar las primeras versiones del sistema UNIX en Bell Labs.</p>
                </div>
                <div class="timeline-item">
                    <span class="timeline-date">1972: El surgimiento de C</span>
                    <p>Dennis Ritchie evoluciona el lenguaje B hacia C. Dise√±ado espec√≠ficamente para UNIX, C se vuelve popular por ser independiente del hardware y extremadamente flexible.</p>
                </div>
                <div class="timeline-item">
                    <span class="timeline-date">1979-1980: C con Clases</span>
                    <p>Bjarne Stroustrup inicia el desarrollo de "C con Clases". Su innovaci√≥n principal fue la integraci√≥n del concepto de <em>objetos</em> (datos agrupados con las operaciones que act√∫an sobre ellos), inspirado en el lenguaje Simula 67.</p>
                </div>
                <div class="timeline-item">
                    <span class="timeline-date">1983: Nace C++</span>
                    <p>El lenguaje es renombrado oficialmente como C++. El operador de incremento <code>++</code> simboliza que es una evoluci√≥n natural de C. Se introducen funciones virtuales, sobrecarga de operadores y referencias.</p>
                </div>
                <div class="timeline-item">
                    <span class="timeline-date">1998: Est√°ndar ANSI/ISO (C++98)</span>
                    <p>Se publica el primer est√°ndar internacional (ISO/IEC 14882:1998), que garantiza la portabilidad del c√≥digo entre diferentes plataformas y compiladores, e incluye la Biblioteca de Plantillas Est√°ndar (STL).</p>
                </div>
                <div class="timeline-item">
                    <span class="timeline-date">2011: C++11 (C++ Moderno)</span>
                    <p>Originalmente conocido como C++0x, esta versi√≥n introduce mejoras cr√≠ticas en seguridad y rendimiento, como punteros inteligentes para la gesti√≥n autom√°tica de memoria y expresiones lambda.</p>
                </div>
            </div>

            <h3>Arquitectura y Filosof√≠a del Dise√±o</h3>
            <p>La potencia de C++ reside en su capacidad para manejar la complejidad mediante la tecnolog√≠a de objetos. Mientras que los lenguajes procedimentales se enfocan en <em>acciones</em> (verbos), C++ se enfoca en <em>objetos</em> (sustantivos). De acuerdo con el PDF de <strong>Deitel</strong>, una <code>clase</code> funciona como un plano de construcci√≥n (un <em>blueprint</em>), mientras que un <code>objeto</code> es la instancia f√≠sica creada a partir de ese plano. Por ejemplo, una clase "CuentaBancaria" define los atributos (saldo) y comportamientos (depositar, retirar), pero solo los objetos individuales contienen el dinero real de un cliente.</p>
            
            <p>Este enfoque facilita lo que se conoce como <strong>ocultamiento de informaci√≥n</strong> (<em>information hiding</em>). Los objetos interact√∫an a trav√©s de interfaces bien definidas, pero sus detalles de implementaci√≥n interna permanecen privados. [cite_start]Como se√±ala <strong>O'Reilly</strong>, esto permite que un programador cambie la estructura interna de una clase sin afectar al resto del programa, siempre que la interfaz p√∫blica se mantenga constante[cite: 2005, 2039]. [cite_start]Esta modularidad es esencial para el mantenimiento a largo plazo de sistemas que hoy superan el mill√≥n de l√≠neas de c√≥digo[cite: 2570, 2575].</p>

            <h3>Gesti√≥n de Memoria y Rendimiento</h3>
            <p>A diferencia de lenguajes como Java o Python, que utilizan recolectores de basura autom√°ticos, C++ otorga al programador el control total sobre el ciclo de vida de los datos. El proceso de creaci√≥n y destrucci√≥n de variables puede ser <strong>autom√°tico</strong> (en el <em>stack</em>, donde los datos desaparecen al salir del bloque) o <strong>est√°tico</strong> (donde los datos persisten durante toda la ejecuci√≥n). [cite_start]El PDF de <strong>O'Reilly</strong> advierte que "un programador de C++ debe pensar como el hardware", ya que errores sutiles como los <em>dangling references</em> (referencias a variables destruidas) o fugas de memoria pueden comprometer la estabilidad del sistema[cite: 37, 2021, 2022].</p>
            
            <p>El rendimiento se optimiza mediante t√©cnicas como las funciones <code>inline</code>, que reducen la sobrecarga de las llamadas a funciones al insertar el c√≥digo directamente en el flujo de ejecuci√≥n. Adem√°s, el uso de <strong>paso por referencia</strong> evita la copia costosa de objetos grandes, permitiendo que las funciones operen directamente sobre los datos originales de manera eficiente.</p>

            <h3>El Futuro del Lenguaje: Bibliotecas Boost y C++ Moderno</h3>
            <p>El desarrollo de C++ no se detuvo con su estandarizaci√≥n inicial. El futuro del lenguaje est√° fuertemente influenciado por la comunidad de c√≥digo fuente abierto, destacando las <strong>Bibliotecas Boost</strong>. Muchos de los componentes de Boost, como las expresiones regulares y los punteros inteligentes, han sido incorporados en los Reportes T√©cnicos (TR1) y en los est√°ndares m√°s recientes (C++11/C++14/C++17). El objetivo de estas actualizaciones es facilitar el aprendizaje del lenguaje, mejorar las herramientas para la creaci√≥n de bibliotecas y aumentar la compatibilidad con el est√°ndar C99.</p>
            
            <p>En conclusi√≥n, C++ sigue siendo el lenguaje de elecci√≥n para sistemas donde el control, la velocidad y la escalabilidad son cr√≠ticos. Su naturaleza multiparadigma y su continua evoluci√≥n aseguran que, aunque es un lenguaje "dif√≠cil" que requiere que el programador gestione la memoria y entienda el hardware, las recompensas en t√©rminos de capacidad t√©cnica y profesional son inigualables en la industria del software.</p>

            <button class="btn-ref" onclick="openRef('ref-2-1')">Referencia: Deitel Cap. 1 & O'Reilly Cap. 1</button>
        </section>


        <!-- 2.2 Su primer programa -->
	<section id="sec-2-2">
    <span class="icon-sec">üíª</span>
    <h2>2.2 Su primer programa en C++: imprimir una l√≠nea de texto</h2>
    <p>La transici√≥n hacia el dominio de C++ comienza con la internalizaci√≥n de su estructura m√≠nima funcional. Este primer programa, aunque elemental en apariencia, constituye la piedra angular para comprender la sintaxis, el proceso de compilaci√≥n y la filosof√≠a de dise√±o del lenguaje. Basado en el enfoque pedag√≥gico de Deitel, este ejemplo utiliza el m√©todo de "c√≥digo activo" para ilustrar c√≥mo los componentes individuales interact√∫an para producir una salida coherente en la consola.</p>
    
    <pre><code>// Figura 2.1: bienvenido.cpp
// Programa para imprimir una l√≠nea de texto en C++
#include &lt;iostream&gt; // Directiva para el uso de flujos de entrada/salida

// La funci√≥n main es el punto de inicio obligatorio de todo programa
int main() {
    // Uso del objeto de flujo de salida est√°ndar para mostrar un mensaje
    std::cout << "¬°Bienvenido a la programaci√≥n en C++!\n"; 

    return 0; // Notificaci√≥n al sistema operativo de que el programa finaliz√≥ con √©xito
} // Fin de la funci√≥n main</code></pre>

    <h3>1. An√°lisis de la Documentaci√≥n: El Rol de los Comentarios</h3>
    <p>Seg√∫n el PDF de Deitel, los comentarios iniciados con <code>//</code> representan documentaci√≥n de una sola l√≠nea, mientras que el estilo heredado de C (<code>/* ... */</code>) permite bloques multil√≠nea. Desde la perspectiva acad√©mica de las metodolog√≠as activas de NotebookLM, la documentaci√≥n no es un simple accesorio, sino una herramienta de metacognici√≥n que permite al estudiante estructurar su pensamiento l√≥gico antes de la codificaci√≥n. O'Reilly enfatiza que un programa debe leerse como un ensayo t√©cnico, donde los comentarios act√∫an como "oraciones tem√°ticas" que gu√≠an al lector a trav√©s de la complejidad del algoritmo. Una "buena pr√°ctica de programaci√≥n" fundamental es iniciar todo archivo con un bloque de comentarios que detalle el autor, el prop√≥sito y la fecha de creaci√≥n del software[cite: 4, 5].</p>

    <h3>2. El Preprocesador y la Biblioteca Est√°ndar</h3>
    <p>La l√≠nea <code>#include &lt;iostream&gt;</code> no es una instrucci√≥n del compilador, sino un mensaje para el <strong>preprocesador</strong>. Basado en el PDF de O'Reilly, el preprocesador es esencialmente un "editor de texto especializado" que procesa el c√≥digo antes de que ocurra la traducci√≥n a lenguaje m√°quina. Al incluir <code>&lt;iostream&gt;</code>, el preprocesador inserta en el c√≥digo fuente las definiciones necesarias para manejar flujos de datos (streams). Esta modularidad permite la <strong>reutilizaci√≥n de software</strong>, un pilar que evita que el programador tenga que "reinventar la rueda" para tareas b√°sicas de entrada y salida.</p>
    
    <h3>3. La Funci√≥n <code>main</code>: El Punto de Entrada</h3>
    <p>Todo programa ejecutable en C++ requiere una funci√≥n denominada <code>main</code>. De acuerdo con la teor√≠a t√©cnica, los par√©ntesis <code>()</code> despu√©s de <code>main</code> indican que se trata de una funci√≥n, y la palabra clave <code>int</code> a su izquierda especifica que la funci√≥n debe devolver un valor entero al sistema operativo. En este contexto, el uso de <code>return 0;</code> al final del cuerpo de la funci√≥n es vital, ya que el valor 0 act√∫a como un c√≥digo de estado que informa que el programa termin√≥ correctamente; cualquier otro valor suele interpretarse como un indicio de error. Es imperativo que el cuerpo de la funci√≥n est√© delimitado por llaves <code>{ }</code>, definiendo as√≠ el alcance o bloque de ejecuci√≥n.</p>

    <h3>4. Flujos de Salida y Espacios de Nombres</h3>
    <p>La instrucci√≥n <code>std::cout</code> es un ejemplo de la potencia de la orientaci√≥n a objetos en C++. Seg√∫n Deitel, <code>cout</code> representa el <strong>objeto de flujo est√°ndar de salida</strong>, que normalmente est√° conectado a la pantalla. El operador <code><<</code> se denomina <strong>operador de inserci√≥n de flujo</strong> y su dise√±o visual simboliza el movimiento de los datos hacia el objeto de salida.</p>
    <p>Un detalle t√©cnico cr√≠tico es el prefijo <code>std::</code>. Este denota que el objeto pertenece al <strong>espacio de nombres (namespace) est√°ndar</strong>. El uso de namespaces es una estrategia de arquitectura de software para evitar colisiones de nombres en proyectos de gran envergadura. Aunque existen formas de omitir este prefijo mediante declaraciones <code>using</code>, el uso expl√≠cito de <code>std::</code> fomenta la claridad y el rigor acad√©mico en el aprendizaje inicial.</p>

    <h3>5. Secuencias de Escape y Formato de Texto</h3>
    <p>Dentro de la cadena de caracteres <code>"¬°Bienvenido a C++!\n"</code>, observamos el uso de <code>\n</code>. Esta es una <strong>secuencia de escape</strong>, donde la barra diagonal inversa (backslash) act√∫a como un car√°cter de control que modifica el significado del car√°cter siguiente. En este caso, <code>\n</code> representa una "nueva l√≠nea", posicionando el cursor al principio de la l√≠nea siguiente. Basado en el PDF de O'Reilly, otras secuencias comunes incluyen <code>\t</code> para tabulaciones horizontales y <code>\"</code> para imprimir comillas dobles dentro de una cadena.</p>

    <h3>6. Estilo, Legibilidad y UX del C√≥digo</h3>
    <p>M√°s all√° de la correcci√≥n sint√°ctica, el desarrollo web y la interfaz de usuario (UX) sugieren que la legibilidad es tan importante como la funcionalidad. Seg√∫n el cuaderno de NotebookLM sobre UX UI, la presentaci√≥n visual de la informaci√≥n afecta directamente el modelo mental del usuario/programador. O'Reilly argumenta que la "guerra religiosa" sobre el estilo de sangr√≠a es secundaria a la <strong>consistencia</strong>: un programa debe estar organizado mediante sangr√≠as (preferiblemente de 3 o 4 espacios) para que la estructura sea evidente de un vistazo. El principio <strong>KIS (Keep It Simple)</strong> dicta que se debe preferir el c√≥digo claro y directo sobre el uso de "trucos astutos" que dificulten el mantenimiento futuro.</p>

    <p>En conclusi√≥n, el dominio de este primer programa requiere no solo entender cada car√°cter, sino tambi√©n apreciar el flujo de la pre-compilaci√≥n, la importancia de la documentaci√≥n metacognitiva y el compromiso con un estilo de codificaci√≥n profesional[cite: 3, 4].</p>

    <button class="btn-ref" onclick="openRef('ref-2-2')">Referencia: Deitel (6¬™ Ed) p√°gs. 36-39, 11, 17; O'Reilly Cap. 2-3 (p√°gs. 18-25)</button>
</section>

        <!-- 2.3 Modificaci√≥n -->
		<section id="sec-2-3">
		<span class="icon-sec">üîß</span>
		<h2>2.3 Modificaci√≥n de nuestro primer programa en C++: Profundizaci√≥n en la salida de datos</h2>

        <p>La capacidad de modificar un programa base es una de las estrategias fundamentales dentro de las <strong>metodolog√≠as activas</strong> de aprendizaje. Seg√∫n el <em>cuaderno de NotebookLM sobre educaci√≥n</em>, el aprendizaje basado en la experimentaci√≥n controlada (scaffolding) permite al estudiante transitar de la mera copia de sintaxis a la comprensi√≥n sem√°ntica del c√≥digo. En este sentido, la modificaci√≥n de nuestro primer programa no es solo un ejercicio de edici√≥n, sino un estudio sobre c√≥mo el flujo de salida de datos (output stream) interact√∫a con el entorno de ejecuci√≥n.</p>

        <p>De acuerdo con el <em>Libro de C++ de Deitel (p√°g. 38)</em>, un solo enunciado de salida puede mostrar m√∫ltiples l√≠neas de texto utilizando <span class="abbr" data-title="Escape Sequences: Caracteres especiales que comienzan con barra invertida (\) y realizan funciones de formato.">secuencias de escape</span>. Estas secuencias permiten al programador ejercer un control granular sobre el cursor en el dispositivo de salida est√°ndar. La barra invertida (<code>\</code>) es denominada por Deitel como el <strong>car√°cter de escape</strong>; cuando el compilador encuentra este car√°cter en una cadena de texto, lo interpreta como un aviso de que el siguiente car√°cter tiene un significado especial.</p>

        <h3>La l√≥gica del flujo de salida y la legibilidad</h3>
        <p>Desde la perspectiva del <em>cuaderno de NotebookLM sobre UX UI</em>, la presentaci√≥n de la informaci√≥n en una interfaz ‚Äîincluso si esta es de consola‚Äî debe minimizar la carga cognitiva del usuario. Una salida de texto apelmazada dificulta la escaneabilidad. Por ello, el uso estrat√©gico de espacios y saltos de l√≠nea no es est√©tico, sino funcional. El <em>PDF de O'Reilly (Practical C++ Programming)</em> enfatiza que la claridad en la salida es tan importante como la claridad en el c√≥digo fuente, sugiriendo que el dise√±o del "output" debe preverse antes de la codificaci√≥n.</p>

        <div class="table-res">
            <table>
                <caption>Tabla extendida de secuencias de escape (Basado en Deitel y O'Reilly)</caption>
                <thead>
                    <tr>
                        <th>Secuencia</th>
                        <th>Significado</th>
                        <th>Acci√≥n T√©cnica y Aplicaci√≥n UX</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>\n</code></td>
                        <td>Nueva l√≠nea</td>
                        <td>Mueve el cursor al inicio de la siguiente l√≠nea. Esencial para crear jerarqu√≠a visual en reportes de consola.</td>
                    </tr>
                    <tr>
                        <td><code>\t</code></td>
                        <td>Tabulador horizontal</td>
                        <td>Mueve el cursor al siguiente tabulador. √ötil para alinear datos en columnas sin depender de espacios manuales, mejorando la legibilidad (NotebookLM UX).</td>
                    </tr>
                    <tr>
                        <td><code>\r</code></td>
                        <td>Retorno de carro</td>
                        <td>Mueve el cursor al inicio de la l√≠nea actual. Se utiliza frecuentemente en indicadores de progreso que se actualizan sobre s√≠ mismos.</td>
                    </tr>
                    <tr>
                        <td><code>\a</code></td>
                        <td>Alerta (Bell)</td>
                        <td>Produce un sonido de sistema. Seg√∫n Deitel, se usa para notificar errores cr√≠ticos o finalizaci√≥n de procesos largos.</td>
                    </tr>
                    <tr>
                        <td><code>\\</code></td>
                        <td>Barra invertida</td>
                        <td>Imprime una barra invertida literal. Necesaria para representar rutas de archivos en sistemas operativos que usan este car√°cter.</td>
                    </tr>
                    <tr>
                        <td><code>\"</code></td>
                        <td>Comilla doble</td>
                        <td>Permite imprimir comillas dentro de una cadena de texto delimitada por comillas, evitando errores de sintaxis del compilador.</td>
                    </tr>
                    <tr>
                        <td><code>\'</code></td>
                        <td>Comilla simple</td>
                        <td>Utilizada para representar el car√°cter de comilla simple sin ambig√ºedad gramatical.</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <h3>Consideraciones T√©cnicas sobre el Rendimiento</h3>
        <p>Es pertinente mencionar la distinci√≥n t√©cnica entre el uso de la secuencia de escape <code>\n</code> y el manipulador de flujo <code>endl</code>. Basado en el <em>PDF de Deitel</em>, mientras que <code>\n</code> simplemente inserta un salto de l√≠nea, <code>endl</code> realiza una operaci√≥n adicional: vac√≠a el <strong>b√∫fer de salida</strong> (output buffer). El <em>cuaderno de NotebookLM sobre desarrollo web</em> menciona paralelismos en el manejo de flujos de datos donde la eficiencia depende de no saturar los canales de comunicaci√≥n; en C++, el uso excesivo de vaciado de b√∫fer puede impactar el rendimiento en aplicaciones de alto volumen de datos, por lo que <code>\n</code> es preferible cuando la velocidad es prioridad sobre la visualizaci√≥n inmediata.</p>

        <div class="practice-box">
            <strong>üí° Desaf√≠o de Ingenier√≠a y Dise√±o:</strong>
            <p>Aplicando los principios de <strong>Dise√±o de Interacci√≥n</strong> del <em>cuaderno de UX UI</em>, desarrolle un programa que genere un encabezado de factura o reporte. El programa debe:</p>
            <ul>
                <li>Utilizar una √∫nica instrucci√≥n <code>std::cout</code>.</li>
                <li>Incluir el nombre de la empresa centrado usando <code>\t</code>.</li>
                <li>Utilizar <code>\"</code> para encerrar un eslogan corporativo.</li>
                <li>Separar las secciones con l√≠neas divisorias creadas con caracteres de texto y <code>\n</code>.</li>
            </ul>
            <p><em>Objetivo Pedag√≥gico:</em> Comprender la concatenaci√≥n de secuencias de escape y su impacto en la jerarqu√≠a visual de la informaci√≥n.</p>
        </div>

        <h3>Errores Comunes y Depuraci√≥n</h3>
        <p>El <em>Libro de O'Reilly</em> advierte sobre el error de olvidar el car√°cter de escape. Escribir <code>n</code> en lugar de <code>\n</code> simplemente imprimir√° la letra, lo cual es un error l√≥gico frecuente en programadores novatos. Asimismo, el <em>cuaderno de NotebookLM sobre Educaci√≥n</em> sugiere que estos errores son "momentos de ense√±anza" ideales para practicar la <strong>metodolog√≠a de revisi√≥n por pares</strong>, donde los estudiantes deben identificar fallos de formato en los c√≥digos de sus compa√±eros para reforzar la atenci√≥n al detalle sint√°ctico.</p>

        <button class="btn-ref" onclick="openRef('ref-2-3')">Referencia: Deitel p√°g. 38-41 | O'Reilly Cap. 4</button>
    </section>

        <!-- 2.4 Suma de enteros -->
		<section id="sec-2-4">
		<span class="icon-sec">‚ûï</span>
		<h2>2.4 Otro programa en C++: Interactividad y Procesamiento de la Suma de Enteros</h2>

        <p>La introducci√≥n de la interactividad marca un hito en la ense√±anza de la programaci√≥n. Seg√∫n el <em>cuaderno de NotebookLM sobre educaci√≥n y metodolog√≠as activas</em>, este paso representa la transici√≥n del "pensamiento est√°tico" (salida de texto fija) al "pensamiento din√°mico" (procesamiento de datos variables). En este contexto, el programa de suma de enteros no es solo un c√°lculo aritm√©tico, sino la primera interacci√≥n real entre el usuario y la l√≥gica interna de la m√°quina.</p>

        <p>C++ se define fundamentalmente como un lenguaje de <strong>tipado fuerte</strong>. De acuerdo con el <em>Libro de C++ de Deitel (6¬™ Edici√≥n)</em>, esto implica que cada entidad de datos debe poseer un tipo claramente definido antes de ser utilizada en el programa. Esta caracter√≠stica permite al compilador realizar comprobaciones de seguridad exhaustivas, garantizando que las operaciones (como la suma) se realicen sobre operandos compatibles, evitando as√≠ comportamientos indefinidos en tiempo de ejecuci√≥n.</p>

        <div class="code-container">
            <pre><code>#include &lt;iostream&gt; // Directiva de preprocesador para flujo de entrada y salida


int main() {
// Declaraci√≥n de variables: Definici√≥n de nombres y tipos de datos
int numero1; // Primer entero a sumar
int numero2; // Segundo entero a sumar
int suma;    // Variable para almacenar el resultado

// Interacci√≥n con el usuario (Capa de Presentaci√≥n)
std::cout << "Ingres√° el primer n√∫mero entero: ";
std::cin >> numero1; // Operador de extracci√≥n para entrada de datos

std::cout << "Ingres√° el segundo n√∫mero entero: ";
std::cin >> numero2;

// L√≥gica de Procesamiento
suma = numero1 + numero2; // Asignaci√≥n del resultado de la operaci√≥n aritm√©tica

// Salida de resultados
std::cout << "La suma es: " << suma << std::endl;

return 0; // Indica que el programa finaliz√≥ exitosamente


}</code></pre>
</div>

        <h3>An√°lisis T√©cnico de la Declaraci√≥n de Variables</h3>
        <p>El <em>PDF de Deitel</em> explica que una variable es, en esencia, una ubicaci√≥n en la memoria de la computadora donde se puede almacenar un valor para que el programa lo utilice posteriormente. Al declarar <code>int numero1;</code>, le estamos pidiendo al compilador que reserve un espacio suficiente para albergar un n√∫mero entero (generalmente 4 bytes en sistemas modernos). Desde la perspectiva del <em>PDF de O'Reilly (Practical C++ Programming)</em>, es vital que los nombres de las variables sean descriptivos; evitar nombres cr√≠pticos como <code>n1</code> o <code>x</code> es una pr√°ctica de "limpieza de c√≥digo" que facilita el mantenimiento a largo plazo.</p>

        <h3>El Objeto std::cin y el Operador de Extracci√≥n (>>)</h3>
        <p>La entrada de datos se gestiona a trav√©s del objeto <code>std::cin</code>. T√©cnicamente, <code>std::cin</code> representa el flujo de entrada est√°ndar (usualmente el teclado). El operador <code>>></code>, conocido como <strong>operador de extracci√≥n</strong>, toma la informaci√≥n del flujo y la coloca en la variable situada a su derecha. El <em>Libro de Deitel</em> destaca que el compilador determina el tipo de datos que se debe extraer bas√°ndose en el tipo de la variable de destino; si el usuario introduce texto cuando se espera un entero, el flujo de entrada entrar√° en un estado de falla.</p>

        <h3>UX UI: El Dise√±o de la Interacci√≥n en Consola</h3>
        <p>Aunque estemos trabajando en un entorno de texto, los principios del <em>cuaderno de NotebookLM sobre UX UI</em> siguen siendo aplicables. Un programa sin etiquetas claras (prompts) genera incertidumbre. Por ello, siempre precedemos un <code>std::cin</code> con un <code>std::cout</code> descriptivo. 
        <ul>
            <li><strong>Claridad:</strong> El mensaje "Ingres√° el primer n√∫mero" reduce la carga cognitiva, indicando exactamente qu√© acci√≥n se espera.</li>
            <li><strong>Feedback Inmediato:</strong> La visualizaci√≥n del resultado "La suma es: " confirma que la acci√≥n del usuario ha sido procesada correctamente.</li>
            <li><strong>Consistencia:</strong> Mantener un formato uniforme en las solicitudes de datos mejora la curva de aprendizaje del usuario final.</li>
        </ul>
        </p>

        <h3>La Operaci√≥n de Asignaci√≥n y la Aritm√©tica</h3>
        <p>En la l√≠nea <code>suma = numero1 + numero2;</code>, el operador <code>+</code> realiza la suma binaria, y el operador <code>=</code> (operador de asignaci√≥n) transfiere el valor calculado a la variable <code>suma</code>. Es fundamental entender, como se√±ala el <em>PDF de O'Reilly</em>, que la asignaci√≥n en C++ funciona de derecha a izquierda: primero se calcula la expresi√≥n a la derecha del igual y luego se guarda el resultado. Este concepto es crucial para evitar errores de l√≥gica donde se intenta asignar un valor a una expresi√≥n aritm√©tica (ej. <code>numero1 + numero2 = suma;</code>), lo cual resultar√≠a en un error de compilaci√≥n.</p>

        <div class="table-res">
            <table>
                <caption>Resumen de Componentes de Interacci√≥n (2.4)</caption>
                <thead>
                    <tr>
                        <th>Componente</th>
                        <th>Tipo de Entidad</th>
                        <th>Funci√≥n Principal</th>
                        <th>Fuente Referencial</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>int</code></td>
                        <td>Tipo de dato primario</td>
                        <td>Representa n√∫meros enteros positivos y negativos.</td>
                        <td>Deitel p√°g. 43</td>
                    </tr>
                    <tr>
                        <td><code>std::cin</code></td>
                        <td>Objeto de flujo (Stream)</td>
                        <td>Captura la entrada desde el perif√©rico est√°ndar.</td>
                        <td>O'Reilly Cap. 4</td>
                    </tr>
                    <tr>
                        <td><code>>></code></td>
                        <td>Operador</td>
                        <td>Extrae datos del flujo y los asigna a variables.</td>
                        <td>Deitel p√°g. 44</td>
                    </tr>
                    <tr>
                        <td><code>=</code></td>
                        <td>Operador de asignaci√≥n</td>
                        <td>Almacena el valor de la derecha en la variable de la izquierda.</td>
                        <td>O'Reilly Cap. 4</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <h3>Consideraciones desde el Desarrollo Web y la Educaci√≥n</h3>
        <p>Desde el enfoque del <em>cuaderno de NotebookLM sobre desarrollo web</em>, podemos comparar el <code>std::cin</code> con los elementos <code>&lt;input&gt;</code> de HTML. En ambos casos, existe la necesidad de validar que el dato ingresado sea del tipo esperado antes de procesarlo en el backend o en la l√≥gica de C++. Pedag√≥gicamente, el <em>cuaderno sobre metodolog√≠as activas</em> sugiere que los estudiantes realicen variaciones de este programa (por ejemplo, restas o multiplicaciones) para afianzar el concepto de que las variables son contenedores gen√©ricos cuyo contenido cambia, pero cuya estructura (tipo) permanece constante.</p>

        <div class="practice-box">
            <strong>üí° Desaf√≠o de Aplicaci√≥n:</strong>
            <p>Cree un programa que solicite tres n√∫meros enteros al usuario y calcule el promedio de los mismos. Tenga en cuenta:</p>
            <ul>
                <li>Utilizar variables descriptivas siguiendo las normas de O'Reilly.</li>
                <li>Asegurarse de que cada solicitud de datos (input) est√© precedida por un mensaje claro (output) siguiendo las gu√≠as de UX de NotebookLM.</li>
                <li>Reflexionar: ¬øQu√© suceder√≠a si el resultado de la divisi√≥n no es un entero? (Introducci√≥n conceptual a los tipos de punto flotante).</li>
            </ul>
        </div>

        <button class="btn-ref" onclick="openRef('ref-2-4')">Referencia: Deitel p√°g. 42-45 | O'Reilly Cap. 4: Variables y Tipos</button>
    </section>

        <!-- 2.5 Conceptos memoria -->
		<section id="sec-2-5">
            <span class="icon-sec">üß†</span>
            <h2>2.5 Conceptos acerca de la memoria: Anatom√≠a y Persistencia de los Datos</h2>
            
            <p>Para dominar el desarrollo de software, es imperativo que el programador desarrolle un <strong>modelo mental</strong> preciso de c√≥mo la computadora gestiona la informaci√≥n. Seg√∫n el <em>cuaderno de NotebookLM sobre UX UI</em>, los sistemas abstractos son m√°s f√°ciles de comprender cuando se visualizan mediante met√°foras espaciales. En C++, debemos visualizar la memoria de acceso aleatorio (RAM) como una vasta serie de celdas o "buzones" numerados, donde cada variable representa una de estas ubicaciones f√≠sicas con atributos espec√≠ficos.</p>

            <p>De acuerdo con el <em>Libro de C++ de Deitel (6¬™ Edici√≥n, p√°g. 43)</em>, toda variable en C++ posee cuatro atributos inalienables que definen su existencia en el ecosistema del programa: <strong>un nombre, un tipo, un tama√±o y un valor</strong>. El nombre funciona como un alias para una direcci√≥n de memoria f√≠sica; el tipo determina qu√© clase de datos puede albergar y qu√© operaciones son v√°lidas; el tama√±o (expresado en bytes) dicta cu√°nto espacio ocupa en el hardware; y el valor es el contenido binario actual de dicha ubicaci√≥n.</p>

            <div class="diagram-mem">
                <div class="mem-cell">
                    <span class="addr">Direcci√≥n 0x01</span><br>
                    <small>Variable: <code>numero1</code></small><br>
                    <strong>45</strong>
                    <div class="cell-type">int (4 bytes)</div>
                </div>
                <div class="mem-cell active">
                    <span class="addr">Direcci√≥n 0x02</span><br>
                    <small>Variable: <code>numero2</code></small><br>
                    <strong>72</strong>
                    <div class="cell-type">int (4 bytes)</div>
                </div>
                <div class="mem-cell">
                    <span class="addr">Direcci√≥n 0x03</span><br>
                    <small>Variable: <code>suma</code></small><br>
                    <strong>117</strong>
                    <div class="cell-type">int (4 bytes)</div>
                </div>
            </div>

            <h3>La Din√°mica de la Memoria: Lectura vs. Escritura</h3>
            <p>Uno de los conceptos m√°s cr√≠ticos para el principiante es entender la naturaleza del flujo de datos hacia y desde estas celdas. El <em>PDF de Deitel</em> establece dos reglas fundamentales que rigen la integridad de la informaci√≥n:</p>
            
            <ul>
                <li><strong>Escritura (Lectura Destructiva):</strong> Al colocar un nuevo valor en una ubicaci√≥n de memoria (por ejemplo, mediante la instrucci√≥n <code>std::cin >> numero1;</code> o una asignaci√≥n <code>suma = 10;</code>), el valor que resid√≠a anteriormente en esa celda se sobreescribe. Este proceso es irreversible; el valor previo se pierde para siempre. Desde el <em>cuaderno de NotebookLM sobre desarrollo web</em>, se advierte que este comportamiento es an√°logo a la reasignaci√≥n de variables en JavaScript, donde el estado anterior desaparece para dar paso al nuevo "estado de la aplicaci√≥n".</li>
                <li><strong>Lectura (Lectura No Destructiva):</strong> Cuando el programa accede a una variable para realizar un c√°lculo (como en <code>suma = numero1 + numero2;</code>), el proceso es de naturaleza consultiva. El hardware realiza una copia del valor almacenado para llevarlo a la Unidad Aritm√©tico-L√≥gica (ALU), pero el valor original permanece intacto en su celda de memoria. Como se√±ala el <em>Libro de O'Reilly</em>, esto permite que una misma variable sea utilizada en m√∫ltiples c√°lculos sin que su estado se altere involuntariamente.</li>
            </ul>

            <div class="table-res">
                <table>
                    <caption>Atributos de la Variable en Memoria (Referencia T√©cnica)</caption>
                    <thead>
                        <tr>
                            <th>Atributo</th>
                            <th>Definici√≥n T√©cnica</th>
                            <th>Implicaci√≥n en el Desarrollo</th>
                            <th>Fuente</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Nombre (Identificador)</td>
                            <td>Etiqueta amigable para la direcci√≥n de memoria.</td>
                            <td>Debe ser descriptivo para facilitar el mantenimiento (Clean Code).</td>
                            <td>O'Reilly Cap. 4</td>
                        </tr>
                        <tr>
                            <td>Tipo</td>
                            <td>Clasificaci√≥n que define el rango y las operaciones.</td>
                            <td>Determina cu√°ntos bytes se reservan y c√≥mo se interpretan los bits.</td>
                            <td>Deitel p√°g. 43</td>
                        </tr>
                        <tr>
                            <td>Tama√±o</td>
                            <td>Espacio f√≠sico ocupado en la RAM (ej: 4 bytes para int).</td>
                            <td>Crucial para la optimizaci√≥n y prevenci√≥n de desbordamientos.</td>
                            <td>Deitel p√°g. 43</td>
                        </tr>
                        <tr>
                            <td>Valor</td>
                            <td>Contenido de datos actual de la celda.</td>
                            <td>Estado din√°mico que cambia mediante "lectura destructiva".</td>
                            <td>NotebookLM Web</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>Perspectiva Pedag√≥gica: El "Mito de la Caja"</h3>
            <p>En las <em>metodolog√≠as activas de educaci√≥n</em> (seg√∫n el cuaderno de NotebookLM correspondiente), se discute que la met√°fora de la "caja" puede ser limitante. Si bien ayuda a entender la contenci√≥n de datos, el estudiante debe evolucionar hacia la comprensi√≥n de la <strong>direccionalidad del flujo</strong>. El <em>PDF de O'Reilly</em> sugiere visualizar las variables no solo como cajas, sino como etiquetas pegadas a un interruptor de hardware. Cambiar el valor no es meter algo en una caja, sino reconfigurar los transistores que representan esa direcci√≥n de memoria.</p>

            <p>Esta distinci√≥n es vital al tratar el concepto de "variables no inicializadas". Deitel menciona que cuando declaramos una variable pero no le asignamos un valor (ej: <code>int x;</code>), la celda de memoria no est√° "vac√≠a", sino que contiene un valor residual o "basura" dejado por programas anteriores. No entender esto es una de las principales fuentes de errores l√≥gicos en C++, a diferencia de lenguajes de alto nivel que inicializan autom√°ticamente a cero o nulo.</p>

            <h3>UX UI y la Visibilidad del Estado</h3>
            <p>Desde el punto de vista de la <em>experiencia de usuario del programador</em>, el entorno de desarrollo (IDE) act√∫a como una ventana hacia esta memoria invisible. El <em>cuaderno de NotebookLM sobre UX UI</em> enfatiza que las herramientas de depuraci√≥n (debuggers) que permiten "observar" las variables en tiempo real est√°n dise√±adas bajo el principio de <strong>visibilidad del sistema</strong>. Al ver c√≥mo cambian los valores en las celdas de memoria durante la ejecuci√≥n, el programador reduce la incertidumbre y puede validar su l√≥gica paso a paso.</p>

            <div class="practice-box">
                <strong>üí° Desaf√≠o de Trazabilidad:</strong>
                <p>Imagine que tiene tres variables: <code>A=10</code>, <code>B=20</code> y <code>C=30</code>. Realice un seguimiento manual de memoria (trace) tras ejecutar las siguientes instrucciones:</p>
                <ol>
                    <li><code>A = B;</code> (¬øQu√© valor se pierde? ¬øCu√°l permanece?)</li>
                    <li><code>C = A + B;</code> (¬øEs esta una operaci√≥n destructiva para A o B?)</li>
                    <li><code>B = B + 5;</code> (¬øC√≥mo interact√∫a aqu√≠ la lectura no destructiva con la escritura destructiva?)</li>
                </ol>
                <p><em>Sugerencia Pedag√≥gica:</em> Dibuje las celdas de memoria tras cada paso para visualizar el estado final del sistema.</p>
            </div>

            <h3>Conclusi√≥n T√©cnica sobre la Gesti√≥n de Recursos</h3>
            <p>Finalmente, el <em>Libro de O'Reilly</em> recuerda que en C++, a diferencia de lenguajes como Python o Java que gestionan la memoria autom√°ticamente, el programador tiene una responsabilidad directa sobre estos buzones. Comprender la diferencia entre el nombre de la variable y su direcci√≥n f√≠sica es el primer paso hacia conceptos avanzados como los <strong>punteros</strong> y la <strong>gesti√≥n din√°mica de memoria</strong>, que se tratar√°n en secciones posteriores. La eficiencia de un programa en C++ radica en la habilidad del desarrollador para utilizar la m√≠nima cantidad de memoria (buzones) necesaria para resolver un problema complejo.</p>

            <button class="btn-ref" onclick="openRef('ref-2-5')">Referencia: Deitel p√°g. 43-44: Memory Concepts | O'Reilly Cap. 4: Storage</button>
        </section>

        <!-- 2.6 Aritm√©tica -->
		<section id="sec-2-6">
            <span class="icon-sec">üßÆ</span>
            <h2>2.6 Aritm√©tica en C++: Reglas de Precedencia y Operaciones Fundamentales</h2>
            
            <p>La aritm√©tica es el motor l√≥gico de la mayor√≠a de los programas. Sin embargo, su implementaci√≥n en C++ requiere una comprensi√≥n que va m√°s all√° de la simple √°lgebra escolar. Seg√∫n el <em>cuaderno de NotebookLM sobre educaci√≥n y metodolog√≠as activas</em>, uno de los mayores obst√°culos para el estudiante novato es la "disonancia cognitiva" que surge al intentar aplicar reglas matem√°ticas sobre un sistema que opera bajo restricciones de tipos de datos y jerarqu√≠as de ejecuci√≥n secuencial. En esta secci√≥n, desglosaremos c√≥mo C++ procesa los c√°lculos y c√≥mo el programador debe estructurar sus expresiones para evitar errores de l√≥gica.</p>

            <p>Basado en el <em>Libro de C++ de Deitel (6¬™ Edici√≥n, p√°g. 45)</em>, la mayor√≠a de los programas realizan c√°lculos aritm√©ticos utilizando operadores binarios, los cuales act√∫an sobre dos operandos. Es fundamental notar que en C++, la sintaxis de estos operadores es consistente con otros lenguajes de alto nivel, pero su comportamiento interno est√° estrictamente ligado al tipo de las variables involucradas.</p>

            <div class="table-res">
                <table>
                    <caption>Operadores Aritm√©ticos Fundamentales en C++</caption>
                    <thead>
                        <tr>
                            <th>Operaci√≥n</th>
                            <th>Operador</th>
                            <th>Expresi√≥n Algebraica</th>
                            <th>Expresi√≥n en C++</th>
                            <th>An√°lisis T√©cnico (Fuentes)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Suma</td>
                            <td><code>+</code></td>
                            <td>$f + 7$</td>
                            <td><code>f + 7</code></td>
                            <td>Operador aditivo est√°ndar.</td>
                        </tr>
                        <tr>
                            <td>Resta</td>
                            <td><code>-</code></td>
                            <td>$p - c$</td>
                            <td><code>p - c</code></td>
                            <td>Operador de diferencia.</td>
                        </tr>
                        <tr>
                            <td>Multiplicaci√≥n</td>
                            <td><code>*</code></td>
                            <td>$bm$</td>
                            <td><code>b * m</code></td>
                            <td>Utiliza el asterisco. No se permite la yuxtaposici√≥n (ej. <code>bm</code>) para multiplicar.</td>
                        </tr>
                        <tr>
                            <td>Divisi√≥n</td>
                            <td><code>/</code></td>
                            <td>$x / y$ o $\frac{x}{y}$</td>
                            <td><code>x / y</code></td>
                            <td><strong>Cr√≠tico:</strong> El comportamiento depende del tipo (Entero vs. Flotante).</td>
                        </tr>
                        <tr>
                            <td>M√≥dulo (Resto)</td>
                            <td><code>%</code></td>
                            <td>$r \pmod s$</td>
                            <td><code>r % s</code></td>
                            <td>Devuelve el resto de la divisi√≥n entera. Solo aplicable a tipos enteros (Deitel).</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>El Fen√≥meno de la Divisi√≥n de Enteros y el Operador M√≥dulo</h3>
            <p>De acuerdo con el <em>PDF de O'Reilly (Practical C++ Programming)</em>, la divisi√≥n de enteros es una de las fuentes m√°s comunes de errores de c√°lculo en programas financieros o cient√≠ficos escritos por principiantes. Cuando ambos operandos son del tipo <code>int</code>, C++ realiza una <strong>divisi√≥n truncada</strong>. Esto significa que cualquier parte fraccionaria del resultado se descarta (no se redondea). Por ejemplo, la expresi√≥n algebraica $7 / 4$ resultar√≠a en $1.75$, pero en C++:</p>
            <p style="text-align: center;"><code>7 / 4</code> $\rightarrow$ <code>1</code></p>
            
            <p>Para complementar esta p√©rdida de informaci√≥n, C++ provee el operador <strong>m√≥dulo</strong> (<code>%</code>). Como se√±ala el <em>Libro de Deitel</em>, este operador solo puede utilizarse con operandos enteros. La expresi√≥n <code>7 % 4</code> devolver√≠a <code>3</code>, que es el residuo de la divisi√≥n. El <em>cuaderno de NotebookLM sobre desarrollo web</em> menciona que el operador m√≥dulo es indispensable en l√≥gica de programaci√≥n para:</p>
            <ul>
                <li><strong>Determinaci√≥n de paridad:</strong> <code>numero % 2 == 0</code> indica un n√∫mero par.</li>
                <li><strong>Ciclos y Rangos:</strong> Mantener un contador dentro de los l√≠mites de un arreglo circular.</li>
                <li><strong>Dise√±o UI:</strong> Alternar colores de filas en una tabla (zebra striping) mediante el √≠ndice de la fila.</li>
            </ul>

            <h3>Reglas de Precedencia y Asociatividad</h3>
            <p>C++ aplica los operadores en una secuencia espec√≠fica conocida como <strong>precedencia de operadores</strong>, la cual es casi id√©ntica a la jerarqu√≠a utilizada en el √°lgebra. El <em>PDF de Deitel (p√°g. 47)</em> desglosa estas reglas de la siguiente manera:</p>
            
            <ol>
                <li><strong>Par√©ntesis:</strong> Las expresiones encerradas en <code>()</code> tienen la m√°xima prioridad. Seg√∫n el <em>cuaderno de NotebookLM sobre UX UI</em>, el uso de par√©ntesis no solo asegura la correcci√≥n del c√°lculo, sino que mejora la <strong>legibilidad del c√≥digo</strong>, reduciendo la carga cognitiva del programador que lee el c√≥digo meses despu√©s.</li>
                <li><strong>Multiplicaci√≥n, Divisi√≥n y M√≥dulo:</strong> Estas operaciones se realizan antes que la suma y la resta. Si hay varias en una misma l√≠nea, se aplican de <strong>izquierda a derecha</strong> (asociatividad por la izquierda).</li>
                <li><strong>Suma y Resta:</strong> Tienen la menor prioridad entre los operadores b√°sicos. Tambi√©n se aplican de izquierda a derecha.</li>
            </ol>

            <div class="practice-box">
                <strong>üìù An√°lisis de Expresi√≥n:</strong>
                <p>Considere la siguiente f√≥rmula algebraica: $y = ax^2 + bx + c$</p>
                <p>En C++, siguiendo las reglas de Deitel y O'Reilly, la forma correcta de escribirla para mantener la jerarqu√≠a ser√≠a:</p>
                <code>y = a * x * x + b * x + c;</code>
                <p>¬øPor qu√©? C++ evaluar√° primero <code>a * x</code>, luego el resultado por <code>x</code>, luego <code>b * x</code>, y finalmente realizar√° las sumas. Note que no necesitamos par√©ntesis aqu√≠, pero usarlos como <code>y = (a * x * x) + (b * x) + c;</code> se considera una buena pr√°ctica de dise√±o seg√∫n el cuaderno de UX UI para evitar ambig√ºedades visuales.</p>
            </div>

            <h3>UX UI y la Presentaci√≥n de Datos Num√©ricos</h3>
            <p>Desde la perspectiva del <em>cuaderno de NotebookLM sobre UX UI</em>, la forma en que presentamos los resultados aritm√©ticos al usuario impacta su percepci√≥n de la utilidad del sistema. Si un programa de calculadora devuelve <code>1</code> al dividir <code>7 / 4</code> sin explicar que es una divisi√≥n entera, el usuario percibir√° un error. Por lo tanto, el dise√±o de la interfaz debe ser transparente sobre las limitaciones t√©cnicas. El <em>PDF de O'Reilly</em> sugiere que, para una mejor experiencia de usuario, siempre se deben considerar los tipos de punto flotante (<code>float</code> o <code>double</code>) cuando la precisi√≥n decimal sea un requisito del dominio del problema.</p>

            <h3>Metodolog√≠as Activas: El Aprendizaje por el Error</h3>
            <p>El <em>cuaderno de NotebookLM sobre educaci√≥n</em> propone que el aprendizaje de la aritm√©tica en C++ debe ser constructivista. En lugar de memorizar tablas de precedencia, los estudiantes deben enfrentarse a "desaf√≠os de depuraci√≥n" donde el orden de los factores s√≠ altera el producto. Por ejemplo, calcular el promedio de tres n√∫meros sin usar par√©ntesis: <code>promedio = num1 + num2 + num3 / 3;</code>. Este error cl√°sico (donde solo <code>num3</code> se divide) sirve para anclar el conocimiento sobre la jerarqu√≠a de operadores mediante la experiencia directa.</p>

            <div class="table-res">
                <table>
                    <caption>Resumen de Precedencia (Niveles de Deitel)</caption>
                    <thead>
                        <tr>
                            <th>Operaci√≥n</th>
                            <th>Operadores</th>
                            <th>Orden de Evaluaci√≥n (Asociatividad)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Par√©ntesis</td>
                            <td><code>( )</code></td>
                            <td>De adentro hacia afuera, de izquierda a derecha.</td>
                        </tr>
                        <tr>
                            <td>Multiplicativos</td>
                            <td><code>* / %</code></td>
                            <td>De izquierda a derecha.</td>
                        </tr>
                        <tr>
                            <td>Aditivos</td>
                            <td><code>+ -</code></td>
                            <td>De izquierda a derecha.</td>
                        </tr>
                        <tr>
                            <td>Asignaci√≥n</td>
                            <td><code>=</code></td>
                            <td>De derecha a izquierda (Caso especial).</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="practice-box">
                <strong>üí° Desaf√≠o Pr√°ctico de Optimizaci√≥n:</strong>
                <p>Escriba un programa que convierta una cantidad de segundos dada por el usuario en horas, minutos y segundos restantes. Deber√° aplicar:</p>
                <ul>
                    <li>El operador de divisi√≥n entera (<code>/</code>) para obtener las horas y minutos completos.</li>
                    <li>El operador m√≥dulo (<code>%</code>) para obtener los residuos.</li>
                    <li>Nombres de variables que cumplan con los est√°ndares de limpieza de O'Reilly (ej. <code>segundosTotales</code>, <code>horasResultantes</code>).</li>
                </ul>
            </div>

            <button class="btn-ref" onclick="openRef('ref-2-6')">Referencia: Deitel p√°g. 45-48 | O'Reilly Cap. 5: Arithmetic Operators</button>
        </section>

        <!-- 2.7 Toma de decisiones -->
		<section id="sec-2-7">
            <span class="icon-sec">‚öñÔ∏è</span>
            <h2>2.7 Toma de decisiones: Operadores de Igualdad y Relacionales en la Estructura Condicional</h2>
            
            <p>La capacidad de un programa para "decidir" qu√© camino tomar en funci√≥n de los datos de entrada es lo que transforma una secuencia est√°tica de instrucciones en un sistema inteligente. Seg√∫n el <em>cuaderno de NotebookLM sobre educaci√≥n y metodolog√≠as activas</em>, este concepto es el n√∫cleo del <strong>pensamiento computacional</strong>, ya que requiere que el estudiante aprenda a descomponer problemas complejos en bifurcaciones l√≥gicas simples. En C++, esta toma de decisiones se fundamenta en la estructura <code>if</code> y en la evaluaci√≥n de expresiones que retornan valores booleanos.</p>

            <p>De acuerdo con el <em>Libro de C++ de Deitel (6¬™ Edici√≥n, p√°g. 48)</em>, una sentencia <code>if</code> permite a un programa ejecutar una acci√≥n espec√≠fica solo si se cumple una condici√≥n determinada (es decir, si la condici√≥n es verdadera). Si la condici√≥n es falsa, el programa simplemente omite la sentencia y contin√∫a con la siguiente instrucci√≥n. Esta estructura de control de selecci√≥n simple es el bloque de construcci√≥n b√°sico para algoritmos de control de flujo.</p>

            <div class="code-container">
                <pre><code>// Ejemplo de l√≥gica de decisi√≥n (Basado en Deitel y O'Reilly)
#include &lt;iostream&gt;

int main() {
    int numero1, numero2;

    std::cout << "Ingrese dos enteros para comparar: ";
    std::cin >> numero1 >> numero2;

    if (numero1 == numero2) {
        std::cout << numero1 << " es igual a " << numero2 << std::endl;
    }

    if (numero1 != numero2) {
        std::cout << numero1 << " no es igual a " << numero2 << std::endl;
    }

    if (numero1 < numero2) {
        std::cout << numero1 << " es menor que " << numero2 << std::endl;
    }

    return 0;
}</code></pre>
            </div>

            <h3>An√°lisis de los Operadores de Comparaci√≥n</h3>
            <p>Para establecer estas condiciones, C++ provee dos categor√≠as de operadores de comparaci√≥n. El <em>PDF de O'Reilly (Practical C++ Programming)</em> enfatiza que, aunque estos operadores parecen intuitivos, su implementaci√≥n a nivel de hardware implica comparaciones de registros de CPU que deben manejarse con precisi√≥n l√©xica:</p>

            <div class="table-res">
                <table>
                    <caption>Operadores de Igualdad y Relacionales (Referencia Acad√©mica)</caption>
                    <thead>
                        <tr>
                            <th>Categor√≠a</th>
                            <th>Operador</th>
                            <th>Significado Algebraico</th>
                            <th>Ejemplo en C++</th>
                            <th>Condici√≥n de Verdad ($True$)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td rowspan="2"><strong>Operadores de Igualdad</strong></td>
                            <td><code>==</code></td>
                            <td>$x = y$</td>
                            <td><code>x == y</code></td>
                            <td>$x$ es exactamente igual a $y$.</td>
                        </tr>
                        <tr>
                            <td><code>!=</code></td>
                            <td>$x \neq y$</td>
                            <td><code>x != y</code></td>
                            <td>$x$ es diferente de $y$.</td>
                        </tr>
                        <tr>
                            <td rowspan="4"><strong>Operadores Relacionales</strong></td>
                            <td><code>&gt;</code></td>
                            <td>$x > y$</td>
                            <td><code>x > y</code></td>
                            <td>$x$ es mayor que $y$.</td>
                        </tr>
                        <tr>
                            <td><code>&lt;</code></td>
                            <td>$x < y$</td>
                            <td><code>x < y</code></td>
                            <td>$x$ es menor que $y$.</td>
                        </tr>
                        <tr>
                            <td><code>&gt;=</code></td>
                            <td>$x \geq y$</td>
                            <td><code>x >= y</code></td>
                            <td>$x$ es mayor o igual que $y$.</td>
                        </tr>
                        <tr>
                            <td><code>&lt;=</code></td>
                            <td>$x \leq y$</td>
                            <td><code>x <= y</code></td>
                            <td>$x$ es menor o igual que $y$.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>El Peligro Sem√°ntico: Asignaci√≥n vs. Igualdad</h3>
            <p>El error m√°s recurrente y costoso en C++ es la confusi√≥n entre el operador de asignaci√≥n (<code>=</code>) y el operador de igualdad (<code>==</code>). Seg√∫n el <em>Libro de O'Reilly</em>, esto no es solo un error de sintaxis, sino un "agujero negro" l√≥gico. En C++, una asignaci√≥n dentro de un <code>if</code>, como en <code>if (x = 5)</code>, no compara si $x$ es 5; en su lugar, asigna el valor 5 a $x$ y luego eval√∫a el resultado de la asignaci√≥n. Dado que en C++ cualquier valor distinto de cero se considera "verdadero", esta condici√≥n siempre se ejecutar√°, alterando el valor de la variable de forma silenciosa e inesperada.</p>
            
            <p>Desde la perspectiva del <em>cuaderno de NotebookLM sobre UX UI</em>, este tipo de errores degrada la <strong>confiabilidad del sistema</strong>. Si el software toma decisiones basadas en asignaciones accidentales, la experiencia del usuario se vuelve impredecible y err√°tica. Para prevenir esto, algunos desarrolladores utilizan las llamadas "Yoda Conditions" (ej: <code>if (5 == x)</code>), donde poner la constante a la izquierda provoca un error de compilaci√≥n si se olvida accidentalmente un signo igual.</p>

            <h3>Consideraciones de Dise√±o y Desarrollo Web</h3>
            <p>En el <em>cuaderno de NotebookLM sobre desarrollo web</em>, se establece un paralelismo con las estructuras de control en lenguajes de script. A diferencia de lenguajes con "tipado d√©bil" que realizan conversiones autom√°ticas (como el operador <code>==</code> en JavaScript), C++ exige una comparaci√≥n de tipos coherente. La toma de decisiones en el backend de una aplicaci√≥n web construida en C++ debe ser extremadamente rigurosa para garantizar la seguridad de los datos, especialmente al comparar credenciales o permisos de acceso.</p>

            <h3>UX UI: Feedback y Visibilidad del Estado L√≥gico</h3>
            <p>Un principio fundamental de la <em>experiencia de usuario</em> es que el sistema siempre debe informar lo que est√° sucediendo. Cuando un programa utiliza un <code>if</code> para validar una entrada del usuario, la respuesta debe ser clara. Seg√∫n el cuaderno de UX UI, si una comparaci√≥n resulta en <em>falso</em> y el programa simplemente se detiene sin un mensaje de salida (un "else" conceptual que veremos m√°s adelante), el usuario experimenta una falta de <strong>feedback</strong>. Por lo tanto, cada estructura de decisi√≥n debe considerar el dise√±o de mensajes informativos que gu√≠en al usuario tras la evaluaci√≥n l√≥gica.</p>

            <h3>Perspectiva Educativa: El Error como Herramienta Constructivista</h3>
            <p>El <em>cuaderno de NotebookLM sobre educaci√≥n</em> propone que el aprendizaje de los operadores relacionales es el momento ideal para introducir la <strong>depuraci√≥n de c√≥digo (debugging)</strong>. En lugar de dar por sentado que las comparaciones funcionan, los estudiantes deben utilizar herramientas para inspeccionar el valor de las variables justo antes de entrar en la sentencia <code>if</code>. Esto fomenta el aprendizaje activo, donde el estudiante no es un espectador del flujo del programa, sino un analista del estado de la memoria (buzones) que estudiamos en la secci√≥n 2.5.</p>

            <div class="practice-box">
                <strong>üö© Desaf√≠o de L√≥gica y Prevenci√≥n:</strong>
                <p>Bas√°ndose en las recomendaciones de O'Reilly y Deitel, escriba un programa que solicite dos edades y determine qui√©n es mayor. Sin embargo, para este ejercicio debe:</p>
                <ul>
                    <li>Anticipar el error: ¬øQu√© sucede si el usuario ingresa la misma edad? Implemente una comparaci√≥n espec√≠fica para la igualdad absoluta (<code>==</code>).</li>
                    <li>Seguridad de C√≥digo: Intente escribir una condici√≥n usando <code>=</code> en lugar de <code>==</code> y observe c√≥mo el compilador (o el comportamiento del programa) reacciona. Reflexione sobre por qu√© este error es tan dif√≠cil de encontrar en programas grandes.</li>
                    <li>UX UI: Dise√±e los mensajes de salida para que sean amigables y no solo matem√°ticos (ej: "Ambos usuarios tienen la misma edad" en lugar de "X == Y").</li>
                </ul>
            </div>

            <p>Finalmente, Deitel nos recuerda que los operadores de igualdad (<code>==</code> y <code>!=</code>) tienen una precedencia menor que los operadores relacionales (<code>&lt;</code>, <code>&gt;</code>, etc.). Esto significa que en una expresi√≥n compleja como <code>x < y == z > w</code>, primero se eval√∫an las relaciones de magnitud y luego la igualdad de los resultados booleanos. No obstante, para mantener la claridad y la "salud mental" del desarrollador, siempre es preferible el uso de par√©ntesis para agrupar las comparaciones l√≥gicas.</p>

            <button class="btn-ref" onclick="openRef('ref-2-7')">Referencia: Deitel p√°g. 48-53: Control Statements | O'Reilly Cap. 6: Decision Statements</button>
        </section>

        <!-- 2.8 ATM Case Study -->
		<section id="sec-2-8">
            <span class="icon-sec">üèß</span>
            <h2>2.8 (Opcional) Ejemplo pr√°ctico de Ingenier√≠a de Software: El Caso de Estudio del ATM</h2>
            
            <p>La ingenier√≠a de software no comienza frente al teclado, sino en la fase de an√°lisis y modelado. Seg√∫n el <em>Libro de C++ de Deitel (6¬™ Edici√≥n, p√°g. 22)</em>, el desarrollo de sistemas complejos requiere una metodolog√≠a que permita descomponer un problema del mundo real en componentes manejables. El caso de estudio del <span class="abbr" data-title="ATM: Automated Teller Machine (Cajero Autom√°tico).">ATM</span> es el ejemplo paradigm√°tico utilizado para introducir el <strong>An√°lisis y Dise√±o Orientado a Objetos (ADOO)</strong>, permitiendo al estudiante visualizar c√≥mo la sintaxis de C++ se traduce en soluciones para necesidades humanas y financieras.</p>

            <p>Desde la perspectiva del <em>cuaderno de NotebookLM sobre educaci√≥n y metodolog√≠as activas</em>, este ejercicio se clasifica dentro del <strong>Aprendizaje Basado en Problemas (ABP)</strong>. En lugar de ense√±ar funciones aisladas, se presenta un ecosistema donde cada l√≠nea de c√≥digo responde a un requerimiento funcional. Esta t√©cnica de "andamiaje" (scaffolding) facilita que el alumno conecte conceptos abstractos (como las clases y los m√©todos) con objetos f√≠sicos y acciones concretas del entorno cotidiano.</p>

            <h3>Fase 1: An√°lisis de Requerimientos y Extracci√≥n de Sustantivos</h3>
            <p>El primer paso en la ingenier√≠a de software, de acuerdo con el <em>PDF de O'Reilly (Practical C++ Programming)</em>, es la identificaci√≥n de las entidades que componen el sistema. Un m√©todo infalible propuesto por Deitel es el an√°lisis gramatical del documento de requerimientos: buscamos los <strong>sustantivos</strong> para identificar las posibles <span class="abbr" data-title="Clases: Plantillas que definen los atributos y comportamientos de un objeto.">clases</span>.</p>

            <div class="table-res">
                <table>
                    <caption>Modelado de Clases: Del Mundo F√≠sico al C√≥digo (Basado en Deitel)</caption>
                    <thead>
                        <tr>
                            <th>Entidad (Sustantivo)</th>
                            <th>Representaci√≥n en C++</th>
                            <th>Responsabilidad en el Sistema</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>ATM (Cajero)</td>
                            <td>Clase <code>ATM</code></td>
                            <td>Coordina la interacci√≥n entre los componentes y el usuario.</td>
                        </tr>
                        <tr>
                            <td>Pantalla</td>
                            <td>Clase <code>Pantalla</code></td>
                            <td>Maneja la salida de datos visuales (Capa de Presentaci√≥n).</td>
                        </tr>
                        <tr>
                            <td>Teclado num√©rico</td>
                            <td>Clase <code>Teclado</code></td>
                            <td>Captura la entrada del usuario (Capa de Interacci√≥n).</td>
                        </tr>
                        <tr>
                            <td>Dispensador</td>
                            <td>Clase <code>DispensadorEfectivo</code></td>
                            <td>Controla el hardware de entrega de billetes y verifica existencias.</td>
                        </tr>
                        <tr>
                            <td>Base de Datos</td>
                            <td>Clase <code>BaseDatosBanco</code></td>
                            <td>Almacena y valida la informaci√≥n de las cuentas de los clientes.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>Fase 2: Identificaci√≥n de Comportamientos (Verbos)</h3>
            <p>Una vez definidas las clases, debemos determinar c√≥mo interact√∫an. Los <strong>verbos</strong> en los requerimientos nos indican las funciones o m√©todos que cada clase debe ejecutar. Como se√±ala el <em>Libro de C++ de Deitel</em>, este proceso define el "comportamiento" de los objetos. Desde el enfoque del <em>cuaderno de NotebookLM sobre desarrollo web</em>, este flujo de trabajo es id√©ntico al dise√±o de una API, donde definimos los endpoints (acciones) antes de escribir la l√≥gica del servidor.</p>

            <p>Ejemplos de verbos transformados en m√©todos de C++:</p>
            <ul>
                <li><strong>"Autenticar usuario":</strong> Se convierte en un m√©todo de la clase <code>BaseDatosBanco</code> para verificar el PIN.</li>
                <li><strong>"Consultar saldo":</strong> Acci√≥n ejecutada por la clase <code>Cuenta</code> a petici√≥n del <code>ATM</code>.</li>
                <li><strong>"Realizar retiro":</strong> Una transacci√≥n compleja que involucra al <code>Dispensador</code> y a la <code>BaseDatosBanco</code>.</li>
            </ul>

            <h3>UX UI: El Factor Humano en el Modelado T√©cnico</h3>
            <p>El <em>cuaderno de NotebookLM sobre UX UI</em> nos recuerda que un sistema de ATM es, ante todo, una interfaz cr√≠tica. La ingenier√≠a de software no termina en la l√≥gica correcta de la suma o resta, sino en la claridad de la interacci√≥n. En el dise√±o del ATM, los principios de UX dictan que:</p>
            <ul>
                <li><strong>Visibilidad del Estado:</strong> La clase <code>Pantalla</code> debe informar siempre si el sistema est√° procesando, si hubo un error de PIN o si no hay fondos suficientes.</li>
                <li><strong>Prevenci√≥n de Errores:</strong> El <code>Teclado</code> debe validar que la entrada sea num√©rica antes de enviarla a procesamiento (evitando "crashes" por tipos de datos incompatibles).</li>
                <li><strong>Seguridad Mental:</strong> El sistema debe asegurar que el usuario recupere su tarjeta antes de dispensar el efectivo, un patr√≥n de dise√±o que previene el olvido de la tarjeta.</li>
            </ul>

            <h3>Integraci√≥n Tecnol√≥gica y el Futuro del C√≥digo</h3>
            <p>El <em>PDF de O'Reilly</em> advierte que un error com√∫n en esta etapa es intentar programarlo todo en una sola funci√≥n <code>main</code>. La ingenier√≠a de software moderna exige <strong>modularidad</strong>. Cada componente (Pantalla, Teclado, Dispensador) debe ser independiente. Esto permite que, si en el futuro el banco decide cambiar la pantalla f√≠sica por una pantalla t√°ctil, solo sea necesario modificar la clase <code>Pantalla</code>, sin alterar la l√≥gica de las transacciones bancarias.</p>

            <div class="practice-box">
                <strong>üìù Desaf√≠o de Pensamiento Arquitect√≥nico:</strong>
                <p>Imagine que debe extender el sistema del ATM para incluir una funci√≥n de "Cambio de PIN". Bas√°ndose en lo aprendido:</p>
                <ol>
                    <li>¬øQu√© sustantivo nuevo aparece en este requerimiento?</li>
                    <li>¬øQu√© m√©todos (verbos) deber√≠a a√±adir a la clase <code>BaseDatosBanco</code> para procesar este cambio de forma segura?</li>
                    <li>Seg√∫n el cuaderno de UX UI, ¬øqu√© mensajes de confirmaci√≥n deber√≠a mostrar la <code>Pantalla</code> para que el usuario se sienta seguro durante el proceso?</li>
                </ol>
                <p><em>Objetivo:</em> Practicar la descomposici√≥n de problemas antes de escribir una sola l√≠nea de c√≥digo en C++.</p>
            </div>

            <p>En conclusi√≥n, el estudio del ATM nos ense√±a que programar en C++ es un acto de traducci√≥n. Traducimos necesidades humanas en clases, acciones en m√©todos y hardware en objetos digitales. Como afirma Deitel, dominar este proceso de modelado es lo que distingue a un "codificador" de un "ingeniero de software".</p>

            <button class="btn-ref" onclick="openRef('ref-2-8')">Referencia: Deitel Secc. 1.21 y 2.8: Case Study | O'Reilly Cap. 2: Software Engineering Basics</button>
        </section>

        <!-- 2.9 Repaso -->
		<section id="sec-2-9">
            <span class="icon-sec">üîÑ</span>
            <h2>2.9 Repaso Integral y Consolidaci√≥n de Competencias</h2>
            
            <p>Al concluir este segundo cap√≠tulo, el estudiante no solo ha adquirido conocimientos sint√°cticos sobre C++, sino que ha iniciado la construcci√≥n de un <strong>modelo mental</strong> fundamental para la ingenier√≠a de software. Seg√∫n el <em>cuaderno de NotebookLM sobre educaci√≥n y metodolog√≠as activas</em>, la fase de repaso no es una mera repetici√≥n, sino un proceso de <strong>metacognici√≥n</strong>: la capacidad de reflexionar sobre el propio aprendizaje para identificar √°reas de maestr√≠a y puntos de confusi√≥n. Este cierre de secci√≥n busca consolidar los conceptos de flujo, memoria y l√≥gica bajo una perspectiva acad√©mica y profesional.</p>

            <h3>I. Arquitectura y Flujo de un Programa C++</h3>
            <p>Desde el an√°lisis del primer programa, hemos establecido que C++ requiere una estructura formal obligatoria. El <em>Libro de C++ de Deitel (6¬™ Edici√≥n)</em> enfatiza que cada componente tiene un prop√≥sito espec√≠fico:</p>
            <ul>
                <li><strong>Directivas de Preprocesador:</strong> <code>#include &lt;iostream&gt;</code> no es solo una l√≠nea de c√≥digo, es la conexi√≥n con la biblioteca est√°ndar que habilita la comunicaci√≥n con el hardware.</li>
                <li><strong>La Funci√≥n <code>main</code>:</strong> El punto de entrada √∫nico. Seg√∫n el <em>cuaderno de NotebookLM sobre desarrollo web</em>, la consistencia en el retorno de <code>0</code> es vital para que el sistema operativo comprenda que el proceso finaliz√≥ sin errores, un principio de estabilidad transferible a cualquier entorno de ejecuci√≥n.</li>
                <li><strong>Secuencias de Escape:</strong> El uso de <code>\n</code> y <code>\t</code> representa el control sobre la <strong>Capa de Presentaci√≥n</strong>. El <em>cuaderno de NotebookLM sobre UX UI</em> destaca que el espaciado y la alineaci√≥n son herramientas de dise√±o que reducen la carga cognitiva del usuario final, facilitando la interpretaci√≥n de los datos mostrados.</li>
            </ul>

            <h3>II. Gesti√≥n de Datos y la Memoria F√≠sica</h3>
            <p>En la secci√≥n 2.5 profundizamos en la naturaleza de las variables. Basado en el <em>PDF de Deitel</em>, hemos aprendido que una variable es un <strong>alias de direcci√≥n de memoria</strong>. El repaso de estos conceptos es cr√≠tico para evitar errores de l√≥gica avanzados:</p>
            
            <div class="table-res">
                <table>
                    <caption>Resumen de la Din√°mica de Datos en Memoria</caption>
                    <thead>
                        <tr>
                            <th>Concepto</th>
                            <th>Regla T√©cnica (Deitel/O'Reilly)</th>
                            <th>Implicaci√≥n Pedag√≥gica (NotebookLM)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Declaraci√≥n</strong></td>
                            <td>Reserva espacio en RAM seg√∫n el tipo (ej. <code>int</code>).</td>
                            <td>Define el "molde" del contenedor de datos.</td>
                        </tr>
                        <tr>
                            <td><strong>Escritura Destructiva</strong></td>
                            <td>Al asignar un valor, el previo se elimina permanentemente.</td>
                            <td>Requiere atenci√≥n constante al estado de la aplicaci√≥n.</td>
                        </tr>
                        <tr>
                            <td><strong>Lectura No Destructiva</strong></td>
                            <td>Al usar una variable, su valor permanece intacto en la celda.</td>
                            <td>Permite la reutilizaci√≥n de datos en m√∫ltiples c√°lculos.</td>
                        </tr>
                        <tr>
                            <td><strong>Inicializaci√≥n</strong></td>
                            <td>Las variables sin valor contienen "basura" de memoria.</td>
                            <td>Fomenta la disciplina de "defensa de c√≥digo".</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>III. L√≥gica Condicional y Operadores</h3>
            <p>La toma de decisiones mediante <code>if</code> y los operadores relacionales introducida en la secci√≥n 2.7 representa el primer paso hacia la algoritmia inteligente. El <em>PDF de O'Reilly (Practical C++ Programming)</em> advierte que la precisi√≥n en la comparaci√≥n es lo que separa un software robusto de uno defectuoso. Hemos repasado la importancia de no confundir la asignaci√≥n (<code>=</code>) con la igualdad (<code>==</code>), un error que el <em>cuaderno de UX UI</em> describe como una falla en la <strong>visibilidad del sistema</strong>, ya que el programa hace algo distinto a lo que el c√≥digo parece indicar a simple vista.</p>

            <p>Asimismo, la aritm√©tica en C++ nos ha ense√±ado que el lenguaje respeta una <strong>jerarqu√≠a de precedencia</strong>. El truncamiento en la divisi√≥n de enteros (<code>/</code>) y la utilidad del operador m√≥dulo (<code>%</code>) son herramientas que el ingeniero debe manejar con maestr√≠a para garantizar la exactitud de los resultados procesados.</p>

            <h3>IV. Ingenier√≠a de Software: El Enfoque Orientado a Objetos</h3>
            <p>A trav√©s del ejemplo del ATM (secci√≥n 2.8), hemos transitado de la codificaci√≥n lineal al <strong>modelado arquitect√≥nico</strong>. Como indica Deitel, la identificaci√≥n de sustantivos (clases) y verbos (m√©todos) es la base de la programaci√≥n moderna. Esta metodolog√≠a activa permite que el estudiante visualice el software como un conjunto de componentes modulares y reutilizables, un principio central del <em>cuaderno de NotebookLM sobre desarrollo web</em>.</p>

            <div class="practice-box">
                <strong>üìù Lista de Verificaci√≥n de Competencias (Autoevaluaci√≥n):</strong>
                <p>Antes de avanzar al Cap√≠tulo 3, aseg√∫rese de dominar los siguientes puntos t√©cnicos:</p>
                <ol>
                    <li>¬øPuedo explicar por qu√© <code>std::cin</code> usa el operador <code>>></code> y <code>std::cout</code> usa <code><<</code> bas√°ndome en el flujo de datos?</li>
                    <li>¬øEntiendo la diferencia de salida entre <code>7 / 2</code> y <code>7 % 2</code>?</li>
                    <li>¬øSoy capaz de identificar un error l√≥gico si una variable no se inicializa antes de ser le√≠da?</li>
                    <li>¬øPuedo dise√±ar un flujo de decisi√≥n usando <code>if</code> que valide si una entrada de usuario es correcta antes de procesarla?</li>
                </ol>
            </div>

            <h3>V. Conclusi√≥n: El Valor del Error</h3>
            <p>Finalmente, retomando las notas del <em>cuaderno de NotebookLM sobre desarrollo web</em>, es fundamental recordar que <strong>el compilador es un mentor, no un adversario</strong>. Los mensajes de error son diagn√≥sticos precisos sobre la violaci√≥n de las reglas del lenguaje. En la programaci√≥n profesional, la capacidad de leer, interpretar y corregir errores es tan valorada como la capacidad de escribir c√≥digo nuevo. El <em>cuaderno sobre metodolog√≠as activas</em> sugiere que el estudiante debe "abrazar el fallo" como la forma m√°s r√°pida de adquirir experiencia t√©cnica.</p>

            <p>Usted est√° ahora preparado para profundizar en las estructuras de control m√°s complejas, habiendo cimentado las bases de la interacci√≥n humano-computadora, la gesti√≥n de memoria y la sintaxis fundamental de C++.</p>

            <div class="diagram-mem" style="background-color: #f0f4f8; border-radius: 8px; padding: 20px; text-align: center;">
                <strong>Camino de Aprendizaje Completado: Cap√≠tulo 2</strong><br>
                <small>Entrada de Datos ‚ûî Procesamiento Aritm√©tico ‚ûî Memoria ‚ûî L√≥gica ‚ûî Modelado</small>
            </div>

            <button class="btn-ref" onclick="location.href='#home'">Volver al √çndice Principal</button>
        </section>

        <footer style="text-align: center; padding: 4rem 0; border-top: 1px solid var(--border); color: var(--text-secondary);">
            <p>¬© 2024 - C√°tedra de Programaci√≥n - Universidad Nacional de Ingenier√≠a</p>
            <p><small>Basado en Deitel (6ta Ed.) y O'Reilly Practical C++. <br> 
            Principios de UX/UI aplicados para mejorar la legibilidad y accesibilidad.</small></p>
        </footer>
    </main>
</div>

<!-- Control de Tema -->
<button class="theme-toggle" id="themeToggle" title="Alternar Modo Oscuro/Claro">
    üåì
</button>

<!-- Modal de Referencias -->
<div id="refModal" class="modal">
    <div class="modal-content">
        <h3 id="refTitle">Referencia Bibliogr√°fica</h3>
        <p id="refBody">Cargando...</p>
        <button class="btn-ref" onclick="closeRef()">Entendido</button>
    </div>
</div>

<script>
    // --- L√≥gica de Referencias ---
    const biblio = {
        'ref-2': 'Basado en el PDF de Deitel - C++ C√≥mo Programar, Cap√≠tulo 2. Enfoque en la estructura general y sintaxis inicial.',
        'ref-2-1': 'Basado en el PDF de O\'Reilly - Practical C++ Programming. Historia de los lenguajes y necesidad del control de hardware.',
        'ref-2-2': 'Basado en el PDF de Deitel - C++ C√≥mo Programar. Explicaci√≥n t√©cnica del flujo iostream y el operador de inserci√≥n.',
        'ref-2-3': 'Basado en el PDF de Deitel - C++ C√≥mo Programar. Tabla de secuencias de escape y control de caracteres especiales.',
        'ref-2-4': 'Sintetizado del PDF de O\'Reilly y Deitel. Manejo de tipos de datos b√°sicos y flujo cin.',
        'ref-2-5': 'Basado en el PDF de Deitel - C++ C√≥mo Programar. Met√°fora de celdas de memoria y conceptos de destrucci√≥n de datos.',
        'ref-2-6': 'An√°lisis t√©cnico de precedencia de operadores seg√∫n el est√°ndar ANSI/ISO citado en Deitel.',
        'ref-2-7': 'Basado en el PDF de O\'Reilly - Practical C++ Programming. An√°lisis de errores l√≥gicos comunes en comparaciones.',
        'ref-2-8': 'Sintetizado de Deitel y el cuaderno de NotebookLM sobre Metodolog√≠as Activas para el dise√±o orientado a objetos.'
    };

    function openRef(id) {
        document.getElementById('refBody').innerText = biblio[id];
        document.getElementById('refModal').style.display = 'flex';
    }

    function closeRef() {
        document.getElementById('refModal').style.display = 'none';
    }

    // --- Modo Oscuro Persistente ---
    const themeToggle = document.getElementById('themeToggle');
    const html = document.documentElement;

    const savedTheme = localStorage.getItem('user-theme') || 'light';
    html.setAttribute('data-theme', savedTheme);

    themeToggle.addEventListener('click', () => {
        const current = html.getAttribute('data-theme');
        const next = current === 'light' ? 'dark' : 'light';
        html.setAttribute('data-theme', next);
        localStorage.setItem('user-theme', next);
    });

// --- Navegaci√≥n Activa (Intersection Observer Optimizado) ---
    const sections = document.querySelectorAll('section');
    const navLinks = document.querySelectorAll('.nav-links a');

    // Ajustamos las opciones para manejar secciones muy largas
    const obsOptions = { 
        threshold: 0, // Se activa en cuanto entra el primer p√≠xel
        rootMargin: "-20% 0px -70% 0px" // Banda de detecci√≥n en la parte superior (donde se lee)
    };

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            // Eliminamos la restricci√≥n del ratio (0.1) para que funcione con textos largos
            if (entry.isIntersecting) {
                const activeId = entry.target.getAttribute('id');
                const activeLink = document.querySelector(`.nav-links a[href="#${activeId}"]`);
                
                if (activeLink) {
                    navLinks.forEach(link => link.classList.remove('active'));
                    activeLink.classList.add('active');
                    
                    // UX: Asegurar que el men√∫ lateral haga scroll si el enlace queda fuera de vista
                    activeLink.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
        });
    }, obsOptions);

    sections.forEach(s => observer.observe(s));

    // Cerrar modal al clickear fuera
    window.onclick = function(e) {
        if (e.target.className === 'modal') closeRef();
    }
</script>

</body>
</html>
