<!DOCTYPE html>
<html lang="es-AR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Gu√≠a de estudio universitaria sobre C++. Basada en Deitel y O'Reilly.">
    <title>Unidad Did√°ctica 02 - Paradigma de Objetos - Parte 1</title>
    
    <!-- Fuentes Acad√©micas -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;1,400&family=Roboto+Mono:wght@400;500&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-primary: #fdfdfd;
            --bg-secondary: #f4f4f4;
            --bg-paper: #ffffff;
            --text-primary: #212121;
            --text-secondary: #5f6368;
            --accent: #0056b3; 
            --accent-hover: #003d80;
            --code-bg: #f5f5f5;
            --border: #e0e0e0;
            --shadow: 0 4px 6px rgba(0,0,0,0.1);
            --timeline-line: #ccc;
            --success: #2e7d32;
        }

        [data-theme="dark"] {
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-paper: #242424;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --accent: #64b5f6;
            --accent-hover: #42a5f5;
            --code-bg: #2d2d2d;
            --border: #333333;
            --shadow: 0 4px 6px rgba(0,0,0,0.5);
            --timeline-line: #444;
            --success: #81c784;
        }

        * {
            box-sizing: border-box;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        body {
            font-family: 'Merriweather', serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.8;
            margin: 0;
            overflow-x: hidden;
        }

        /* Tipograf√≠a */
        h1, h2, h3, h4 {
            font-family: 'Roboto', sans-serif;
            margin-top: 1.5em;
        }

        h1 { font-weight: 700; font-size: 2.2rem; text-align: center; margin-bottom: 2rem; }
        h1 a { text-decoration: none; color: var(--accent); }
        h2 { border-bottom: 2px solid var(--accent); padding-bottom: 0.5rem; color: var(--accent); font-size: 1.8rem; }
        h3 { color: var(--text-primary); border-left: 4px solid var(--accent); padding-left: 1rem; margin-top: 2rem; }
        
        p { margin-bottom: 1.2rem; font-size: 1.05rem; text-align: justify; }

        code {
            font-family: 'Roboto Mono', monospace;
            background-color: var(--code-bg);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-size: 0.9em;
            color: var(--accent);
        }

        pre {
            background-color: var(--code-bg);
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 5px solid var(--accent);
            box-shadow: var(--shadow);
            margin: 1.5rem 0;
        }

        /* Layout */
        .app-container {
            display: grid;
            grid-template-columns: 320px 1fr;
            min-height: 100vh;
        }

        aside {
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--border);
            height: 100vh;
            position: sticky;
            top: 0;
            overflow-y: auto;
            padding: 2rem 1.5rem;
            display: flex;
            flex-direction: column;
        }

        .nav-header h2 { border: none; font-size: 1.2rem; margin-bottom: 0.5rem; color: var(--text-primary); }

        .nav-links { list-style: none; padding: 0; margin: 0; }
        .nav-links li { margin-bottom: 0.2rem; }
        .nav-links a {
            text-decoration: none;
            color: var(--text-secondary);
            font-family: 'Roboto', sans-serif;
            font-size: 0.85rem;
            display: block;
            padding: 0.5rem;
            border-radius: 6px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .nav-links a:hover, .nav-links a.active {
            background-color: var(--accent);
            color: #ffffff;
            padding-left: 1.2rem;
            box-shadow: var(--shadow);
        }

        main {
            padding: 4rem 8%;
            max-width: 1400px;
            margin: 0 auto;
        }

        section {
            scroll-margin-top: 5rem;
            margin-bottom: 6rem;
            padding: 3rem;
            background-color: var(--bg-paper);
            border-radius: 12px;
            box-shadow: var(--shadow);
            animation: slideUp 0.8s ease-out forwards;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(40px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Tooltips */
        .abbr {
            border-bottom: 2px dotted var(--accent);
            cursor: help;
            position: relative;
            color: var(--accent);
            font-weight: 600;
        }

        .abbr:hover::after {
            content: attr(data-title);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: #fff;
            padding: 0.6rem 1rem;
            border-radius: 6px;
            font-size: 0.85rem;
            white-space: normal;
            min-width: 200px;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            font-family: 'Roboto', sans-serif;
            text-align: center;
        }

        /* Timeline */
        .timeline {
            position: relative;
            padding-left: 3rem;
            margin: 3rem 0;
            border-left: 4px solid var(--accent);
        }
        .timeline-item { margin-bottom: 2.5rem; position: relative; }
        .timeline-item::before {
            content: '';
            position: absolute;
            left: -3.65rem;
            top: 0.2rem;
            width: 1.2rem;
            height: 1.2rem;
            background: var(--bg-paper);
            border: 4px solid var(--accent);
            border-radius: 50%;
        }
        .timeline-date { font-weight: 800; color: var(--accent); font-size: 1.1rem; display: block; }

        /* Diagramas */
        .diagram-box {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin: 2rem 0;
        }
        .diagram-node {
            border: 2px solid var(--accent);
            padding: 1.5rem;
            border-radius: 12px;
            background: var(--bg-secondary);
            text-align: center;
            min-width: 180px;
            position: relative;
        }
        .diagram-arrow {
            display: flex;
            align-items: center;
            font-size: 1.5rem;
            color: var(--accent);
        }

        /* UI Elements */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.6rem;
            z-index: 1000;
        }

        .btn-ref {
            display: inline-block;
            background: transparent;
            border: 2px solid var(--accent);
            color: var(--accent);
            padding: 0.6rem 1.2rem;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-weight: 500;
            margin-top: 1rem;
            transition: all 0.3s;
        }
        .btn-ref:hover { background: var(--accent); color: white; }

        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: var(--bg-paper);
            padding: 3rem;
            border-radius: 12px;
            max-width: 700px;
            width: 90%;
            position: relative;
        }

        .practice-box {
            background: rgba(46, 125, 50, 0.05);
            border-left: 6px solid var(--success);
            padding: 2rem;
            margin: 2rem 0;
            border-radius: 0 8px 8px 0;
        }

        .icon-sec { font-size: 2.5rem; margin-bottom: 1rem; display: block; }

        /* Responsive */
        @media (max-width: 1024px) {
            .app-container { grid-template-columns: 1fr; }
            aside { display: none; }
            main { padding: 2rem 5%; }
        }
    </style>
</head>
<body>

<div class="app-container">
    <aside id="sidebar">
        <div class="nav-header">
            <h2>CONTENIDOS</h2>
            <p style="font-size: 0.75rem; color: var(--text-secondary);">Gu√≠a Acad√©mica Unidad 02</p>
        </div>
        <ul class="nav-links">
            <li><a href="#sec-2">2 Introducci√≥n a C++</a></li>
            <li><a href="#sec-2-1">2.1 Introducci√≥n</a></li>
            <li><a href="#sec-2-2">2.2 Primer programa</a></li>
            <li><a href="#sec-2-3">2.3 Modificaciones</a></li>
            <li><a href="#sec-2-4">2.4 Suma de enteros</a></li>
            <li><a href="#sec-2-5">2.5 Conceptos de memoria</a></li>
            <li><a href="#sec-2-6">2.6 Aritm√©tica</a></li>
            <li><a href="#sec-2-7">2.7 Toma de decisiones</a></li>
            <li><a href="#sec-2-8">2.8 Ingenier√≠a ATM</a></li>
            <li><a href="#sec-2-9">2.9 Encapsulamiento</a></li>
            <li><a href="#sec-2-10">2.10 Abstracci√≥n de Datos</a></li>
            <li><a href="#sec-2-11">2.11 Crear Clases</a></li>
            <li><a href="#sec-2-12">2.12 Ciclo de Vida Objetos</a></li>
            <li><a href="#sec-2-13">2.13 Control de Acceso</a></li>
            <li><a href="#sec-2-14">2.14 Valor de la OO</a></li>
            <li><a href="#sec-2-15">2.15 Repaso</a></li>
        </ul>
    </aside>

    <main>
        <header id="home">
            <h1><a href="#home">Unidad Did√°ctica 02 - Paradigma de Objetos - Parte 1</a></h1>
            <p style="text-align: center; font-style: italic;">"La excelencia t√©cnica surge de la comprensi√≥n profunda de los cimientos del lenguaje."</p>
        </header>

        <!-- Secciones 2.0 a 2.15 -->

        <section id="sec-2">
            <span class="icon-sec">üöÄ</span>
            <h2>2 Introducci√≥n a la programaci√≥n en C++</h2>
            <p>Usted est√° por comenzar un estudio intensivo del lenguaje C++, una herramienta fundamental para el desarrollo de sistemas de alto rendimiento. Basado en el enfoque de <strong>Deitel</strong>, este cap√≠tulo desglosa los componentes elementales para que el estudiante universitario domine no solo la sintaxis, sino la l√≥gica subyacente del procesamiento de datos.</p>
            <p>Seg√∫n el cuaderno de <strong>Metodolog√≠as Activas</strong>, se recomienda alternar la lectura te√≥rica con la implementaci√≥n inmediata en su <span class="abbr" data-title="IDE: Integrated Development Environment. Entorno para escribir y compilar c√≥digo.">IDE</span>.</p>
            <button class="btn-ref" onclick="openRef('ref-deitel')">Referencia: Deitel Cap. 2</button>
        </section>

		<section id="sec-2-1">
            <span class="icon-sec">üìú</span>
            <h2>2.1 Introducci√≥n al Lenguaje C++: Or√≠genes, Evoluci√≥n y Paradigmas</h2>
            
            <p>El lenguaje de programaci√≥n C++ representa uno de los hitos m√°s significativos en la historia de la ingenier√≠a de software. Su concepci√≥n no fue un hecho fortuito, sino una respuesta t√©cnica necesaria a la creciente complejidad de los sistemas computacionales de finales de la d√©cada de 1970. Como bien indica el PDF de <strong>Deitel</strong>, para comprender la magnitud de C++, primero deb√©s situarlo como la evoluci√≥n natural y superadora de una genealog√≠a de lenguajes que priorizaban la eficiencia y la cercan√≠a al hardware.</p>

            <p>La base gen√©tica de C++ se encuentra en el lenguaje <strong>C</strong>, desarrollado por Dennis Ritchie en los Laboratorios Bell. C, a su vez, hered√≥ caracter√≠sticas fundamentales de los lenguajes <strong>BCPL</strong> (Martin Richards, 1967) y <strong>B</strong> (Ken Thompson, 1970). Mientras que C permit√≠a una programaci√≥n estructurada y eficiente para el desarrollo de sistemas operativos como UNIX, el crecimiento exponencial de las l√≠neas de c√≥digo en proyectos industriales comenz√≥ a exponer las limitaciones del paradigma estrictamente procedimental. En este contexto, <span class="abbr" data-title="Bjarne Stroustrup: Cient√≠fico de la computaci√≥n dan√©s que en 1979 comenz√≥ a desarrollar lo que hoy conocemos como C++ en AT&T Bell Labs.">Bjarne Stroustrup</span> inici√≥ en 1979 el desarrollo de lo que inicialmente denomin√≥ "C con Clases".</p>

            <h3>La Filosof√≠a de la "Potencia H√≠brida"</h3>
            <p>De acuerdo con el enfoque de <strong>O'Reilly</strong> en <em>Practical C++ Programming</em>, la genialidad de C++ reside en su naturaleza de lenguaje <strong>h√≠brido</strong> o multiparadigma. A diferencia de otros lenguajes que fuerzan al programador a adoptar un √∫nico estilo de pensamiento, C++ te permite moverte fluidamente entre la programaci√≥n estructurada (centrada en algoritmos y funciones) y la programaci√≥n orientada a objetos (centrada en datos y sus comportamientos). Esta flexibilidad es la que permite que C++ sea el est√°ndar de oro tanto para el desarrollo de drivers de bajo nivel como para motores de videojuegos de √∫ltima generaci√≥n y aplicaciones financieras de alta frecuencia.</p>
            
            <p>El nombre "C++" es en s√≠ mismo una declaraci√≥n de principios. El operador de incremento <code>++</code> del lenguaje C simboliza que estamos ante una versi√≥n mejorada, pero que mantiene la compatibilidad con sus ra√≠ces. Seg√∫n <strong>Deitel</strong>, esto permiti√≥ una transici√≥n suave para miles de programadores, quienes pudieron adoptar las nuevas caracter√≠sticas de objetos de manera incremental, sin perder la eficiencia del manejo de memoria manual que caracteriza a C.</p>

            <h3>L√≠nea de Tiempo: La Senda hacia la Estandarizaci√≥n</h3>
            <div class="timeline">
                <div class="timeline-item">
                    <span class="timeline-date">1967 - 1972: La Semilla</span>
                    <p>Desarrollo de BCPL y B. Dennis Ritchie crea C para escribir el sistema operativo UNIX. Se establece la base de la sintaxis que dominar√≠a la computaci√≥n por d√©cadas.</p>
                </div>
                <div class="timeline-item">
                    <span class="timeline-date">1979 - 1980: C con Clases</span>
                    <p>Stroustrup introduce el concepto de clases de Simula 67 en C. El objetivo era facilitar la organizaci√≥n del c√≥digo en proyectos de gran escala sin sacrificar la velocidad de ejecuci√≥n.</p>
                </div>
                <div class="timeline-item">
                    <span class="timeline-date">1983 - 1985: El Nacimiento Oficial</span>
                    <p>El lenguaje se renombra oficialmente como C++. Se publica la primera edici√≥n de <em>The C++ Programming Language</em>. Se incorporan funciones virtuales, sobrecarga de operadores y referencias.</p>
                </div>
                <div class="timeline-item">
                    <span class="timeline-date">1998: El Primer Est√°ndar (C++98)</span>
                    <p>La ISO y la ANSI ratifican el primer est√°ndar internacional. Se incluye la <span class="abbr" data-title="STL: Standard Template Library. Biblioteca que proporciona estructuras de datos y algoritmos gen√©ricos altamente optimizados.">STL</span>, transformando la manera en que los programadores gestionan colecciones de datos.</p>
                </div>
                <div class="timeline-item">
                    <span class="timeline-date">2011 - Presente: La Era del C++ Moderno</span>
                    <p>Con la llegada de C++11 (seguido por C++14, 17 y 20), el lenguaje experimenta un renacimiento. Se introducen punteros inteligentes, expresiones lambda y una gesti√≥n de memoria mucho m√°s segura y robusta.</p>
                </div>
            </div>

            <h3>Comparativa T√©cnica: C vs. C++</h3>
            <p>Para un estudiante universitario, es crucial distinguir las fronteras t√©cnicas entre estos dos lenguajes. El siguiente cuadro comparativo sintetiza las diferencias clave analizadas en los textos de referencia:</p>

            <div class="table-res">
                <table>
                    <thead>
                        <tr>
                            <th>Caracter√≠stica</th>
                            <th>Lenguaje C</th>
                            <th>Lenguaje C++</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Paradigma Dominante</strong></td>
                            <td>Programaci√≥n Estructurada / Procedimental.</td>
                            <td>Multiparadigma (Estructurada, OO, Gen√©rica).</td>
                        </tr>
                        <tr>
                            <td><strong>Enfoque de Dise√±o</strong></td>
                            <td>Top-Down (se descompone el problema en funciones).</td>
                            <td>Bottom-Up (se modelan objetos que interact√∫an).</td>
                        </tr>
                        <tr>
                            <td><strong>Seguridad de Tipos</strong></td>
                            <td>Relativamente d√©bil; permite conversiones riesgosas.</td>
                            <td>Tipado fuerte (Strong Typing); chequeos m√°s rigurosos.</td>
                        </tr>
                        <tr>
                            <td><strong>Manejo de Memoria</strong></td>
                            <td>Funciones <code>malloc</code> y <code>free</code>.</td>
                            <td>Operadores <code>new</code> y <code>delete</code> (y Smart Pointers).</td>
                        </tr>
                        <tr>
                            <td><strong>Encapsulamiento</strong></td>
                            <td>Inexistente de forma nativa.</td>
                            <td>Soportado mediante Clases y Modificadores de Acceso.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>Importancia en la Ingenier√≠a de Software Moderna</h3>
            <p>Como se destaca en los cuadernos de **Desarrollo Web** y **Metodolog√≠as Activas**, el estudio de C++ no es solo una cuesti√≥n de aprender una sintaxis, sino de entender la arquitectura del software. C++ te obliga a ser consciente de c√≥mo tus decisiones de dise√±o impactan en la <span class="abbr" data-title="Latencia: El tiempo de retraso entre una acci√≥n y su respuesta. Cr√≠tico en sistemas de tiempo real.">latencia</span> y el uso de recursos. En la industria actual, C++ sigue siendo insustituible en √°reas donde el rendimiento es innegociable: sistemas operativos, navegadores web (como Chrome o Firefox), software de dise√±o industrial (CAD) y sistemas de control aeroespacial.</p>

            <p>La transici√≥n hacia el <strong>Paradigma de Objetos</strong> (tema central de esta unidad) requiere un cambio de mentalidad. Usted dejar√° de pensar en el programa como una "receta de pasos" para visualizarlo como un ecosistema de entidades aut√≥nomas (objetos) que se comunican entre s√≠. Esta abstracci√≥n, soportada por C++, es lo que permite manejar proyectos de millones de l√≠neas de c√≥digo sin que el sistema colapse bajo su propio peso. Seg√∫n el enfoque pedag√≥gico del cuaderno de **Educaci√≥n**, este aprendizaje debe ser procedimental: usted debe tipear los ejemplos, romper el c√≥digo y analizar por qu√© el compilador reacciona de determinada manera ante sus instrucciones.</p>

            <div class="practice-box">
                <strong>üîç Reflexi√≥n Acad√©mica:</strong> ¬øPor qu√© cree que C++ no ha sido reemplazado por lenguajes m√°s "sencillos" como Python en el desarrollo de motores gr√°ficos? Considere la relaci√≥n entre el tiempo de ejecuci√≥n y el control del hardware mencionada en el PDF de <strong>O'Reilly</strong>.
            </div>

            <button class="btn-ref" onclick="openRef('ref-deitel')">Referencia: Deitel Cap. 1 y 2 / O'Reilly Cap. 1</button>
        </section>

		<section id="sec-2-2">
            <span class="icon-sec">üìü</span>
            <h2>2.2 Su primer programa en C++: imprimir una l√≠nea de texto</h2>
            
            <p>El primer contacto con un lenguaje de programaci√≥n de alto rendimiento como C++ requiere que usted comprenda no solo la sintaxis superficial, sino la arquitectura l√≥gica que sostiene cada sentencia. En el √°mbito universitario, no nos limitamos a "copiar y pegar"; analizamos la anatom√≠a del c√≥digo para entender c√≥mo el hardware interpreta nuestras intenciones. Seg√∫n el PDF de <strong>Deitel</strong>, un programa en C++ es una secuencia de instrucciones que interact√∫an con el sistema operativo para gestionar recursos. Analiz√° detenidamente el siguiente bloque de c√≥digo, el cual representa la unidad m√≠nima funcional de una aplicaci√≥n de consola:</p>

            <pre><code>// Figura 2.1: bienvenido.cpp
// Programa que imprime una l√≠nea de texto en la consola.
#include &lt;iostream&gt; // Directiva para el preprocesador

// La funci√≥n main es el punto de inicio de la ejecuci√≥n
int main() {
    std::cout << "Bienvenido a la programaci√≥n en C++!\n"; // Muestra un mensaje

    return 0; // Indica que el programa finaliz√≥ exitosamente
} // Fin de la funci√≥n main</code></pre>

            <h3>Desglose T√©cnico y An√°lisis de Componentes</h3>
            <p>Para dominar este lenguaje, deb√©s desarmar este programa pieza por pieza. Cada l√≠nea cumple una funci√≥n cr√≠tica en el ciclo de vida de la aplicaci√≥n:</p>
            
            <ol>
                <li><strong>Comentarios de documentaci√≥n:</strong> Las l√≠neas que comienzan con <code>//</code> son ignoradas por el <span class="abbr" data-title="Compilador: Herramienta de software que traduce el c√≥digo fuente (texto) a c√≥digo objeto o lenguaje de m√°quina que la CPU puede ejecutar directamente.">compilador</span>. Sin embargo, desde la perspectiva de la ingenier√≠a de software, son vitales. El cuaderno de <strong>Metodolog√≠as Activas</strong> destaca que un c√≥digo bien documentado facilita la colaboraci√≥n y el mantenimiento a largo plazo. En C++, tambi√©n pod√©s usar <code>/* ... */</code> para comentarios multil√≠nea.</li>
                
                <li><strong>Directivas del Preprocesador:</strong> La l√≠nea <code>#include &lt;iostream&gt;</code> no es una instrucci√≥n de C++ propiamente dicha, sino una orden para el preprocesador. Seg√∫n <strong>O'Reilly</strong> en <em>Practical C++ Programming</em>, esta l√≠nea le indica al compilador que "pegue" el contenido del archivo de cabecera <code>iostream</code> antes de empezar la traducci√≥n. Este archivo es parte de la <span class="abbr" data-title="Biblioteca Est√°ndar: Conjunto de funciones, clases y objetos predefinidos que vienen con el compilador de C++ para facilitar tareas comunes como la entrada y salida de datos.">biblioteca est√°ndar</span> y contiene las definiciones necesarias para manejar flujos de datos (streams).</li>
                
                <li><strong>La Funci√≥n Principal (main):</strong> En C++, <code>int main()</code> es la puerta de entrada obligatoria. Todo programa ejecutable debe tener una (y solo una) funci√≥n llamada <code>main</code>. El t√©rmino <code>int</code> a la izquierda indica que la funci√≥n debe devolver un n√∫mero entero al sistema operativo al finalizar. Las llaves <code>{ }</code> delimitan el cuerpo de la funci√≥n, definiendo su √°mbito o <em>scope</em>.</li>
                
                <li><strong>El Objeto de Flujo de Salida (std::cout):</strong> Aqu√≠ es donde C++ demuestra su naturaleza orientada a objetos. <code>std::cout</code> no es una funci√≥n (como lo es <code>printf</code> en C), sino un <strong>objeto</strong> que representa el flujo de salida est√°ndar (generalmente la pantalla). El prefijo <code>std::</code> indica que <code>cout</code> reside en el <span class="abbr" data-title="Namespace: Mecanismo para agrupar nombres de funciones o clases bajo un identificador √∫nico, evitando que dos funciones con el mismo nombre entren en conflicto en proyectos grandes.">espacio de nombres</span> est√°ndar.</li>
                
                <li><strong>El Operador de Inserci√≥n (<<):</strong> Este operador "empuja" la cadena de texto <code>"Bienvenido..."</code> hacia el objeto <code>cout</code>. Not√° la elegancia del paradigma: estamos insertando datos en un flujo. Seg√∫n el PDF de <strong>Deitel</strong>, pod√©s encadenar m√∫ltiples inserciones en una sola l√≠nea, lo que otorga una gran flexibilidad al formatear la salida.</li>
                
                <li><strong>La Secuencia de Escape (\n):</strong> El car√°cter de barra invertida (<code>\</code>) es un "car√°cter de escape". Cuando se combina con la <code>n</code>, indica una "nueva l√≠nea". Es fundamental que usted comprenda que el cursor de la consola no bajar√° autom√°ticamente a menos que usted se lo indique expl√≠citamente mediante esta secuencia o el manipulador <code>std::endl</code>.</li>
            </ol>

            <h3>El Ciclo de Vida: De C√≥digo Fuente a Ejecutable</h3>
            <p>Como estudiante de ingenier√≠a, ten√©s que visualizar qu√© sucede "detr√°s de escena" cuando presion√°s el bot√≥n de ejecutar en tu IDE. El proceso se divide en tres etapas fundamentales analizadas en los textos de <strong>O'Reilly</strong>:</p>

            <div class="diagram-box">
                <div class="diagram-node"><strong>1. Preprocesamiento</strong><br><small>Se procesan las directivas #include y macros.</small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node"><strong>2. Compilaci√≥n</strong><br><small>El c√≥digo C++ se traduce a c√≥digo de ensamblador y luego a objeto.</small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node"><strong>3. Enlace (Linking)</strong><br><small>Se unen los archivos objeto con las bibliotecas est√°ndar (iostream).</small></div>
            </div>

            <p>Si olvid√°s incluir el punto y coma (<code>;</code>) al final de la sentencia de <code>cout</code>, el compilador generar√° un error de sintaxis. Estos errores son tus aliados pedag√≥gicos: te obligan a revisar la rigurosidad de tu gram√°tica de programaci√≥n. El cuaderno de <strong>Educaci√≥n</strong> sugiere que usted provoque estos errores intencionalmente para aprender a leer los mensajes de diagn√≥stico del compilador.</p>

            <h3>Buenas Pr√°cticas Acad√©micas</h3>
            <p>Aunque C++ permite escribir c√≥digo de forma compacta, la legibilidad es una prioridad universitaria. Se recomienda:</p>
            <ul>
                <li><strong>Identaci√≥n:</strong> Siempre desplaz√° el contenido dentro de las llaves (usualmente 3 o 4 espacios) para que la estructura jer√°rquica sea evidente a simple vista.</li>
                <li><strong>Espaciado:</strong> Coloc√° espacios alrededor de los operadores (como <code><<</code>) para facilitar la lectura r√°pida del c√≥digo.</li>
                <li><strong>Finalizaci√≥n:</strong> Asegurate de que <code>main</code> siempre termine con <code>return 0;</code>. Aunque los compiladores modernos pueden inferirlo, explicitarlo es una marca de profesionalismo t√©cnico que indica que el programa alcanz√≥ su fin sin anomal√≠as.</li>
            </ul>

            <div class="practice-box">
                <strong>üõ†Ô∏è Laboratorio de Aplicaci√≥n:</strong> 
                <p>Escrib√≠ un programa que imprima un mensaje de bienvenida en la primera l√≠nea y tu a√±o de cursada en la segunda, utilizando dos sentencias <code>std::cout</code> distintas. Luego, intent√° lograr el mismo resultado visual usando una sola sentencia <code>std::cout</code> con dos secuencias <code>\n</code>.</p>
                <p><em>Sugerencia:</em> Prest√° atenci√≥n a c√≥mo el uso de comillas dobles delimita las <span class="abbr" data-title="String Literal: Una secuencia de caracteres encerrada entre comillas dobles que el programa trata como un dato constante de texto.">cadenas de caracteres</span>.</p>
            </div>

            <p>En conclusi√≥n, este peque√±o programa de apenas seis l√≠neas es la piedra angular de todo lo que vendr√°. Seg√∫n <strong>Deitel</strong>, dominar la entrada y salida de datos es el primer paso para interactuar con el usuario y, por ende, para resolver problemas del mundo real a trav√©s del software. En la pr√≥xima secci√≥n, veremos c√≥mo modificar este c√≥digo base para realizar operaciones m√°s din√°micas y complejas.</p>

            <button class="btn-ref" onclick="openRef('ref-deitel')">Referencia: Deitel Cap. 2.2 / O'Reilly Cap. 3</button>
        </section>

		<section id="sec-2-3">
            <span class="icon-sec">üñãÔ∏è</span>
            <h2>2.3 Modificaci√≥n de nuestro primer programa en C++: El Arte del Formateo</h2>
            
            <p>En la pr√°ctica de la ingenier√≠a de software, la presentaci√≥n de la informaci√≥n es tan cr√≠tica como el algoritmo que la procesa. En esta secci√≥n, profundizaremos en la flexibilidad del objeto <code>std::cout</code> y en c√≥mo C++ permite manipular el flujo de salida para generar interfaces de consola profesionales. Seg√∫n el PDF de <strong>Deitel</strong>, existen dos formas fundamentales de alterar la salida de texto: mediante la fragmentaci√≥n de enunciados y el uso de secuencias de escape especializadas.</p>

            <h3>I. Fragmentaci√≥n de Enunciados vs. Salida Unificada</h3>
            <p>Un concepto que usted debe dominar es que el flujo de salida en C++ es <strong>continuo</strong>. El <span class="abbr" data-title="Stream: Secuencia de caracteres o bytes que fluyen desde una fuente (como un programa) hacia un destino (como la pantalla).">stream</span> no inserta saltos de l√≠nea autom√°ticos. Esto otorga al programador un control absoluto sobre el cursor. Observ√° el siguiente ejemplo t√©cnico que contrasta ambas filosof√≠as:</p>

            <pre><code>// T√©cnica A: M√∫ltiples enunciados para una sola l√≠nea
std::cout << "Bienvenido ";
std::cout << "a la cursada ";
std::cout << "de Programaci√≥n.\n";

// T√©cnica B: Un solo enunciado para m√∫ltiples l√≠neas
std::cout << "L√≠nea 1\nL√≠nea 2\nL√≠nea 3\n";</code></pre>

            <p>En la <strong>T√©cnica A</strong>, cada llamado a <code>std::cout</code> comienza exactamente donde termin√≥ el anterior. Esta granularidad es extremadamente √∫til cuando se construyen mensajes din√°micos donde partes del texto dependen de variables calculadas en tiempo de ejecuci√≥n. Por el contrario, la <strong>T√©cnica B</strong> demuestra la potencia de las cadenas de caracteres complejas. Como indica <strong>O'Reilly</strong> en su enfoque pr√°ctico, minimizar las llamadas al objeto de flujo puede, en sistemas cr√≠ticos, reducir ligeramente la sobrecarga del sistema al gestionar el <span class="abbr" data-title="Buffer: Almacenamiento temporal en memoria que agrupa datos antes de enviarlos al hardware de salida para mejorar la eficiencia.">buffer</span> de salida.</p>

            <h3>II. Anatom√≠a de las Secuencias de Escape</h3>
            <p>Para lograr un formateo preciso, C++ hereda de C el concepto de <strong>car√°cter de escape</strong>. Se utiliza la barra invertida (<code>\</code>) para indicarle al compilador que el car√°cter siguiente tiene un significado especial y no debe ser impreso literalmente. Seg√∫n la documentaci√≥n t√©cnica de <strong>Deitel</strong>, este mecanismo es esencial para representar caracteres que, de otro modo, ser√≠an imposibles de incluir en una cadena (como una comilla doble o un sonido).</p>

            <div class="table-res">
                <table>
                    <thead>
                        <tr>
                            <th>Secuencia</th>
                            <th>Nombre Acad√©mico</th>
                            <th>Descripci√≥n y Aplicaci√≥n en Ingenier√≠a</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>\n</code></td>
                            <td>Nueva L√≠nea (Newline)</td>
                            <td>Mueve el cursor al inicio de la siguiente l√≠nea f√≠sica. Es el est√°ndar para finalizar p√°rrafos de salida.</td>
                        </tr>
                        <tr>
                            <td><code>\t</code></td>
                            <td>Tabulaci√≥n Horizontal</td>
                            <td>Mueve el cursor al siguiente "punto de tabulaci√≥n". Vital para crear tablas alineadas en la consola sin calcular espacios manualmente.</td>
                        </tr>
                        <tr>
                            <td><code>\r</code></td>
                            <td>Retorno de Carro (Carriage Return)</td>
                            <td>Mueve el cursor al inicio de la l√≠nea <em>actual</em>. Se utiliza en barras de progreso donde el texto se sobreescribe constantemente.</td>
                        </tr>
                        <tr>
                            <td><code>\a</code></td>
                            <td>Alerta (Alert/Bell)</td>
                            <td>Produce un sonido de sistema o se√±al visual. √ötil en diagn√≥stico de errores o notificaciones de fin de proceso.</td>
                        </tr>
                        <tr>
                            <td><code>\\</code></td>
                            <td>Barra Invertida Literal</td>
                            <td>Necesaria para imprimir rutas de archivos (especialmente en sistemas Windows) sin que el compilador interprete un comando de escape.</td>
                        </tr>
                        <tr>
                            <td><code>\"</code></td>
                            <td>Comilla Doble Literal</td>
                            <td>Permite incluir citas o √©nfasis dentro de una cadena de texto sin cerrar prematuramente el literal de cadena.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>III. El Manipulador <code>std::endl</code> y la Gesti√≥n de Memoria</h3>
            <p>Usted encontrar√° con frecuencia el uso de <code>std::endl</code> en lugar de <code>\n</code>. Es vital entender la diferencia t√©cnica: <code>std::endl</code> no solo inserta una nueva l√≠nea, sino que tambi√©n realiza un <strong>vaciado del buffer</strong> (<em>flushing</em>). [cite_start]Seg√∫n el PDF de <strong>O'Reilly</strong>, vaciar el buffer constantemente puede degradar el rendimiento en bucles intensivos[cite: 48, 49]. Sin embargo, en aplicaciones interactivas, asegura que el usuario vea el mensaje inmediatamente, evitando que la informaci√≥n quede "atrapada" en la memoria temporal antes de un error del sistema.</p>

            <h3>IV. Diagrama de Flujo del Procesamiento de Salida</h3>
            <p>El siguiente diagrama ilustra c√≥mo el compilador y el entorno de ejecuci√≥n gestionan estos caracteres especiales antes de que lleguen a sus ojos:</p>
            
            <div class="diagram-box">
                <div class="diagram-node"><strong>C√≥digo Fuente</strong><br><small>"Texto\n"</small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node"><strong>Pre-procesador</strong><br><small>Interpretaci√≥n de \</small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node"><strong>Buffer de Salida</strong><br><small>Almacenamiento Temporal</small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node"><strong>Consola / TTY</strong><br><small>Salida Visual Final</small></div>
            </div>

            <p>Como futuro profesional de la inform√°tica, usted deber√° decidir qu√© t√©cnica de formateo aplicar bas√°ndose en la legibilidad del c√≥digo fuente y la claridad de la interfaz de usuario. El cuaderno de <strong>UX/UI</strong> nos recuerda que la jerarqu√≠a visual en la consola (lograda mediante <code>\t</code> y <code>\n</code>) reduce la carga cognitiva del usuario final.</p>

            <div class="practice-box">
                <span class="icon-sec">üß™</span>
                <strong>Laboratorio de Aplicaci√≥n N¬∞ 3:</strong>
                <p>Desarroll√° un programa que genere un recibo de sueldo acad√©mico. Deber√° contener:</p>
                <ul>
                    <li>Una cabecera con el nombre de la Universidad rodeado de comillas dobles (usando <code>\"</code>).</li>
                    <li>Una tabla de tres columnas (Materia, Nota, Fecha) perfectamente alineada mediante el uso de <code>\t</code>.</li>
                    <li>Un aviso sonoro al finalizar la ejecuci√≥n (usando <code>\a</code>).</li>
                </ul>
                <p><em>Desaf√≠o extra:</em> Intent√° que todo el reporte se genere con una √∫nica llamada a <code>std::cout</code> para optimizar el uso de recursos.</p>
            </div>

            <p>En conclusi√≥n, la modificaci√≥n de los programas b√°sicos de salida en C++ es el primer paso hacia la creaci√≥n de software robusto. La capacidad de controlar el cursor y el sonido del sistema permite una interacci√≥n m√°s rica. En la siguiente secci√≥n, abordaremos c√≥mo no solo "hablarle" al usuario, sino tambi√©n "escucharlo" mediante la captura de datos desde el teclado.</p>

            <button class="btn-ref" onclick="openRef('ref-deitel')">Referencia: Deitel Cap. 2.3 / O'Reilly Cap. 4</button>
        </section>

		<section id="sec-2-4">
            <span class="icon-sec">üî¢</span>
            <h2>2.4 Otro programa en C++: suma de enteros</h2>
            
            <p>En el desarrollo de software de nivel industrial, la captura y el procesamiento de datos del usuario constituyen el n√∫cleo de la interactividad. Mientras que en las secciones anteriores nos limitamos a la salida de datos (output), aqu√≠ introducimos la entrada de datos (input). Seg√∫n el enfoque pedag√≥gico de <strong>Deitel</strong>, este proceso transforma un programa est√°tico en una herramienta din√°mica capaz de resolver problemas espec√≠ficos en tiempo de ejecuci√≥n. Analiz√° el siguiente programa, dise√±ado para realizar una operaci√≥n aritm√©tica elemental pero fundamental para comprender la arquitectura de C++:</p>

            <pre><code>// Figura 2.5: suma.cpp
// Programa que muestra la suma de dos enteros ingresados por teclado.
#include &lt;iostream&gt; // Permite la entrada y salida de datos

int main() {
   // Declaraci√≥n de variables: reserva de espacio en memoria
   int numero1 = 0; // Primer sumando
   int numero2 = 0; // Segundo sumando
   int suma = 0;    // Variable para almacenar el resultado

   std::cout << "Escrib√≠ el primer entero: "; // Indicador para el usuario
   std::cin >> numero1; // Lee el primer entero del usuario y lo deposita en numero1

   std::cout << "Escrib√≠ el segundo entero: "; // Indicador para el usuario
   std::cin >> numero2; // Lee el segundo entero y lo deposita en numero2

   suma = numero1 + numero2; // Realiza el c√°lculo y asigna el resultado

   std::cout << "La suma es " << suma << std::endl; // Muestra el resultado final

   return 0; // Indica que el programa finaliz√≥ correctamente
} // Fin de la funci√≥n main</code></pre>

            <h3>I. La Declaraci√≥n de Variables y el Tipado Fuerte</h3>
            <p>C++ se caracteriza por ser un lenguaje de <span class="abbr" data-title="Tipado Fuerte: Regla que exige que cada variable tenga un tipo definido expl√≠citamente, impidiendo operaciones entre tipos incompatibles sin una conversi√≥n previa.">tipado fuerte</span>. Esto implica que cada identificador debe ser declarado con un tipo espec√≠fico antes de ser utilizado. En el ejemplo anterior, utilizamos el tipo de dato <code>int</code> (integer), que representa n√∫meros enteros.</p>
            
            <p>De acuerdo con <strong>O'Reilly</strong> en <em>Practical C++ Programming</em>, la declaraci√≥n de una variable no es solo una formalidad sint√°ctica, sino una instrucci√≥n directa al compilador para reservar un bloque de memoria de tama√±o espec√≠fico (generalmente 32 bits para un <code>int</code> en arquitecturas modernas). Es una excelente pr√°ctica acad√©mica inicializar las variables (por ejemplo, <code>= 0</code>) para evitar que contengan <span class="abbr" data-title="Valores Basura: Datos residuales que quedan en una ubicaci√≥n de memoria tras su uso previo por otro proceso o variable.">valores basura</span>, lo cual es una fuente com√∫n de errores l√≥gicos dif√≠ciles de depurar.</p>

            <h3>II. Anatom√≠a de la Entrada de Datos: <code>std::cin</code></h3>
            <p>El objeto <code>std::cin</code> (character input) es el contraparte de <code>std::cout</code>. Representa el flujo de entrada est√°ndar, usualmente vinculado al teclado. La interacci√≥n con este objeto se realiza mediante el <strong>operador de extracci√≥n de flujo</strong> (<code>>></code>).</p>
            
            <p>Usted debe notar que la direcci√≥n de las flechas en los operadores indica el flujo de la informaci√≥n:</p>
            <ul>
                <li><strong>Inserci√≥n (<code><<</code>):</strong> Los datos fluyen desde el programa hacia el objeto de salida (pantalla).</li>
                <li><strong>Extracci√≥n (<code>>></code>):</strong> Los datos fluyen desde el objeto de entrada (teclado) hacia las variables del programa.</li>
            </ul>

            <p>Un detalle t√©cnico avanzado mencionado en el PDF de <strong>Deitel</strong> es que <code>std::cin</code> espera a que el usuario presione la tecla <em>Enter</em> para procesar la entrada. Durante este tiempo, los caracteres se almacenan en un <span class="abbr" data-title="Buffer de Entrada: √Årea de memoria temporal donde se guardan los caracteres tecleados antes de ser procesados por el programa.">buffer</span>. Si el usuario ingresa datos que no corresponden al tipo esperado (por ejemplo, texto en lugar de un entero), el flujo entra en un estado de falla que debe ser gestionado para evitar comportamientos err√°ticos.</p>

            <h3>III. La L√≥gica de la Asignaci√≥n y la Aritm√©tica</h3>
            <p>La l√≠nea <code>suma = numero1 + numero2;</code> ilustra el uso del <strong>operador de asignaci√≥n</strong> (<code>=</code>). Es vital que el estudiante universitario comprenda que la asignaci√≥n en C++ es una operaci√≥n que fluye de <strong>derecha a izquierda</strong>. El compilador primero eval√∫a la expresi√≥n aritm√©tica a la derecha del signo igual y luego deposita el valor resultante en la ubicaci√≥n de memoria referenciada por la variable a la izquierda.</p>
            
            <p>En este contexto, <code>numero1</code> y <code>numero2</code> act√∫an como <span class="abbr" data-title="r-value: Un valor que puede aparecer en el lado derecho de una asignaci√≥n; t√≠picamente un valor de lectura.">r-values</span> (valores de lectura), mientras que <code>suma</code> act√∫a como un <span class="abbr" data-title="l-value: Un identificador que se refiere a una ubicaci√≥n de memoria persistente; t√≠picamente el receptor de una asignaci√≥n.">l-value</span> (ubicaci√≥n de almacenamiento). Este proceso de c√°lculo y almacenamiento es lo que permite al software transformar datos crudos en informaci√≥n √∫til.</p>

            <h3>IV. Representaci√≥n de Estados en Memoria</h3>
            <p>Para visualizar lo que ocurre dentro de la computadora, analiz√° la evoluci√≥n de las celdas de memoria durante la ejecuci√≥n:</p>
            
            <div class="table-res">
                <table>
                    <thead>
                        <tr>
                            <th>Momento de Ejecuci√≥n</th>
                            <th>Variable <code>numero1</code></th>
                            <th>Variable <code>numero2</code></th>
                            <th>Variable <code>suma</code></th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Tras la declaraci√≥n</td>
                            <td>0 (Inicializado)</td>
                            <td>0 (Inicializado)</td>
                            <td>0 (Inicializado)</td>
                        </tr>
                        <tr>
                            <td>Tras <code>std::cin >> numero1;</code> (Entrada: 45)</td>
                            <td>45 (Escritura destructiva)</td>
                            <td>0</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>Tras <code>std::cin >> numero2;</code> (Entrada: 72)</td>
                            <td>45</td>
                            <td>72 (Escritura destructiva)</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>Tras el c√°lculo de la suma</td>
                            <td>45 (Lectura no destructiva)</td>
                            <td>72 (Lectura no destructiva)</td>
                            <td>117 (Resultado)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Como se explica en el PDF de <strong>Deitel</strong>, el concepto de "escritura destructiva" es fundamental: cualquier valor que resida en una variable es reemplazado permanentemente cuando se le asigna uno nuevo. Por el contrario, leer el valor de una variable para un c√°lculo no altera su contenido original.</p>

            <h3>V. Perspectiva de Ingenier√≠a de Software</h3>
            <p>Desde la √≥ptica de las <strong>Metodolog√≠as Activas</strong>, no basta con que el programa "funcione". Un ingeniero debe considerar la <strong>robustez</strong>. ¬øQu√© sucede si la suma de dos n√∫meros excede el valor m√°ximo que un <code>int</code> puede representar? Este fen√≥meno, conocido como <span class="abbr" data-title="Overflow (Desbordamiento): Error que ocurre cuando un c√°lculo produce un resultado que excede el rango m√°ximo de representaci√≥n del tipo de dato utilizado.">overflow</span>, es una vulnerabilidad cr√≠tica que usted aprender√° a mitigar en secciones avanzadas mediante el uso de tipos de datos de mayor capacidad o validaciones l√≥gicas.</p>

            <div class="practice-box">
                <span class="icon-sec">üß™</span>
                <strong>Laboratorio de Aplicaci√≥n N¬∞ 4:</strong>
                <p>Escrib√≠ un programa que solicite tres n√∫meros enteros al usuario y muestre el resultado de su producto (multiplicaci√≥n). Analiz√° qu√© sucede si ingres√°s n√∫meros muy grandes (por ejemplo, superiores a 1.000.000.000) y compar√° los resultados con una calculadora est√°ndar.</p>
                <p><em>Nota acad√©mica:</em> Asegurate de usar nombres de variables descriptivos (como <code>factor1</code>, <code>producto</code>) en lugar de nombres gen√©ricos (como <code>a</code>, <code>b</code>), siguiendo las recomendaciones de estilo de <strong>O'Reilly</strong>.</p>
            </div>

            <p>En conclusi√≥n, la captura de datos y su posterior procesamiento aritm√©tico constituyen la base de cualquier sistema computacional. Al dominar <code>std::cin</code> y la l√≥gica de variables, usted ha pasado de ser un espectador de flujos de texto a un dise√±ador de l√≥gica interactiva. En la siguiente secci√≥n, exploraremos c√≥mo estas variables se organizan f√≠sicamente en la jerarqu√≠a de memoria del hardware.</p>

            <button class="btn-ref" onclick="openRef('ref-deitel')">Referencia: Deitel Cap. 2.4 / O'Reilly Cap. 5</button>
        </section>

        <section id="sec-2-5">
            <span class="icon-sec">üß†</span>
            <h2>2.5 Conceptos acerca de la memoria: Anatom√≠a del Almacenamiento</h2>
            
            <p>Para un ingeniero o licenciado en sistemas, la memoria de la computadora no debe verse como un concepto abstracto, sino como un recurso f√≠sico finito y estructurado. Como se explica en el PDF de <strong>Deitel</strong>, usted debe visualizar la memoria como una secuencia de celdas o "buzones" numerados de forma √∫nica. Cada variable que usted declara en su programa representa, en √∫ltima instancia, una o m√°s de estas ubicaciones f√≠sicas en la <span class="abbr" data-title="RAM: Random Access Memory. Memoria vol√°til de alta velocidad donde la CPU almacena temporalmente datos de programas en ejecuci√≥n.">RAM</span>.</p>

            <h3>I. La Variable como Abstracci√≥n de Hardware</h3>
            <p>En C++, una variable es mucho m√°s que un nombre; es un objeto que posee cinco atributos fundamentales que usted debe poder identificar en cualquier instante de la ejecuci√≥n:</p>
            <ul>
                <li><strong>Nombre (Identificador):</strong> La etiqueta que usamos en el c√≥digo fuente para referirnos a la celda (ej: <code>numero1</code>).</li>
                <li><strong>Tipo:</strong> Define la naturaleza de los datos y, crucialmente, cu√°ntos bytes de memoria ocupar√° (ej: <code>int</code> suele ocupar 4 bytes).</li>
                <li><strong>Tama√±o:</strong> La cantidad f√≠sica de espacio reservado en la memoria.</li>
                <li><strong>Valor:</strong> El dato binario almacenado actualmente en esa ubicaci√≥n.</li>
                <li><strong>Direcci√≥n:</strong> La ubicaci√≥n f√≠sica exacta en el hardware, generalmente expresada en formato <span class="abbr" data-title="Hexadecimal: Sistema num√©rico en base 16 utilizado en computaci√≥n para representar direcciones de memoria de forma m√°s compacta que el binario.">hexadecimal</span> (ej: <code>0x7ffee4b5a</code>).</li>
            </ul>

            <p>Seg√∫n <strong>O'Reilly</strong> en <em>Practical C++ Programming</em>, la cercan√≠a de C++ al hardware obliga al programador a ser consciente de estas direcciones. Aunque en este nivel inicial usamos nombres, internamente el <span class="abbr" data-title="Enlazador (Linker): Programa que une los archivos de c√≥digo objeto para crear un ejecutable, resolviendo las direcciones de memoria de las funciones y variables.">enlazador</span> traduce esos nombres en direcciones f√≠sicas precisas.</p>

            <h3>II. La Ley de Acceso: Escritura Destructiva y Lectura No Destructiva</h3>
            <p>Uno de los conceptos m√°s cr√≠ticos analizados por <strong>Deitel</strong> es c√≥mo el flujo de informaci√≥n altera (o no) el estado de la memoria. Usted debe internalizar estas dos reglas de oro:</p>
            
            <ol>
                <li><strong>Escritura Destructiva (Sobreescritura):</strong> Cuando un valor es enviado a una ubicaci√≥n de memoria (ya sea mediante una asignaci√≥n <code>=</code> o mediante una entrada <code>std::cin >></code>), el valor anterior que resid√≠a en esa celda es eliminado permanentemente. No existe una "papelera de reciclaje" dentro de una variable; el nuevo dato aplasta al anterior.</li>
                <li><strong>Lectura No Destructiva:</strong> Cuando el programa accede a una variable para usar su valor en un c√°lculo o para mostrarlo en pantalla (ej: <code>std::cout << numero1</code>), el valor permanece intacto en la celda. El hardware realiza una "copia" del dato para su procesamiento, pero la fuente original no se altera.</li>
            </ol>

            <div class="diagram-box">
                <div class="diagram-node"><strong>Memoria RAM</strong><br><small>Direcci√≥n: 0x01</small><br>Variable: <code>n1</code><br>Valor: [15]</div>
                <div class="diagram-arrow">‚ûî Lectura ‚ûî</div>
                <div class="diagram-node"><strong>CPU (ALU)</strong><br><small>Operaci√≥n: + 10</small><br>Resultado: [25]</div>
            </div>
            <p style="text-align: center; font-size: 0.9rem; color: var(--text-secondary);">Diagrama 2.5a: Note que tras la operaci√≥n, el valor en la celda 0x01 sigue siendo [15].</p>

            <h3>III. El Peligro de los "Valores Basura"</h3>
            <p>De acuerdo con el enfoque pr√°ctico de <strong>O'Reilly</strong>, C++ no garantiza que una variable reci√©n declarada est√© vac√≠a o en cero. La memoria es un recurso compartido: cuando su programa solicita espacio para un <code>int</code>, el sistema operativo le entrega una ubicaci√≥n que pudo haber sido utilizada previamente por otro programa (como un navegador o un editor de texto).</p>
            
            <p>Si usted no inicializa la variable (ej: <code>int x;</code> en lugar de <code>int x = 0;</code>), la variable contendr√° los residuos binarios de la aplicaci√≥n anterior. Esto se conoce acad√©micamente como <strong>Valor Basura</strong>. Intentar realizar c√°lculos con valores basura es una de las causas principales de errores l√≥gicos indetectables y fallos de seguridad en sistemas cr√≠ticos. Como indica el cuaderno de <strong>Metodolog√≠as Activas</strong>, la autodisciplina en la inicializaci√≥n define a un programador profesional.</p>

            <h3>IV. Representaci√≥n Visual de Estados de Memoria</h3>
            <p>Analice c√≥mo evoluciona la memoria en un proceso de intercambio de valores (swap) entre dos variables:</p>

            <div class="table-res">
                <table>
                    <thead>
                        <tr>
                            <th>Sentencia ejecutada</th>
                            <th>Estado <code>varA</code></th>
                            <th>Estado <code>varB</code></th>
                            <th>Estado <code>temp</code></th>
                            <th>Observaci√≥n T√©cnica</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>int varA=10, varB=20, temp;</code></td>
                            <td>10</td>
                            <td>20</td>
                            <td>? (Basura)</td>
                            <td>Reserva inicial de 3 celdas.</td>
                        </tr>
                        <tr>
                            <td><code>temp = varA;</code></td>
                            <td>10</td>
                            <td>20</td>
                            <td>10</td>
                            <td>Lectura no destructiva de A.</td>
                        </tr>
                        <tr>
                            <td><code>varA = varB;</code></td>
                            <td><strong>20</strong></td>
                            <td>20</td>
                            <td>10</td>
                            <td>Escritura <strong>destructiva</strong> en A.</td>
                        </tr>
                        <tr>
                            <td><code>varB = temp;</code></td>
                            <td>20</td>
                            <td><strong>10</strong></td>
                            <td>10</td>
                            <td>Escritura destructiva en B.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>V. Perspectiva de Ingenier√≠a: Jerarqu√≠a y Velocidad</h3>
            <p>Finalmente, es vital comprender que no toda la memoria es igual. Mientras que la RAM es donde residen sus variables, la CPU posee memorias internas mucho m√°s r√°pidas llamadas <span class="abbr" data-title="Registros: Peque√±as ubicaciones de almacenamiento de alt√≠sima velocidad situadas dentro del procesador, donde se realizan las operaciones aritm√©ticas reales.">registros</span>. C++ permite, mediante optimizaciones del compilador, que ciertas variables se mantengan en registros para aumentar la velocidad. Seg√∫n el cuaderno de <strong>Desarrollo Web</strong>, entender esta jerarqu√≠a es lo que permite crear aplicaciones que no solo funcionan, sino que escalan eficientemente bajo carga masiva de datos.</p>

            <div class="practice-box">
                <span class="icon-sec">üß™</span>
                <strong>Desaf√≠o de Visualizaci√≥n:</strong>
                <p>Imagine que tiene una variable <code>saldo</code> con valor 5000. Si ejecuta <code>saldo = saldo - 1000;</code>, describa detalladamente el proceso de lectura y escritura. ¬øQu√© valor se lee de la celda? ¬øD√≥nde se realiza la resta? ¬øQu√© sucede con el valor 5000 original al finalizar la sentencia?</p>
                <p><em>Ayuda:</em> Recuerde que la asignaci√≥n <code>=</code> eval√∫a primero todo lo que est√° a la derecha antes de modificar la memoria a la izquierda.</p>
            </div>

            <p>Comprender la memoria es el primer paso para dominar los <strong>punteros</strong> y la <strong>gesti√≥n din√°mica de memoria</strong> que veremos en unidades posteriores. Como afirma <strong>Deitel</strong>, la maestr√≠a en C++ requiere que usted piense como la m√°quina mientras dise√±a como un arquitecto.</p>

            <button class="btn-ref" onclick="openRef('ref-deitel')">Referencia: Deitel Cap. 2.5 / O'Reilly Cap. 5</button>
        </section>

        <section id="sec-2-6">
            <span class="icon-sec">üìê</span>
            <h2>2.6 Aritm√©tica en C++: Operadores y L√≥gica de Evaluaci√≥n</h2>
            
            <p>El procesamiento aritm√©tico es el coraz√≥n de la computaci√≥n cient√≠fica e industrial. Como se detalla en el PDF de <strong>Deitel</strong>, C++ proporciona un conjunto robusto de <span class="abbr" data-title="Operador Binario: Un operador que requiere dos operandos (valores) para realizar su funci√≥n.">operadores binarios</span> que permiten realizar c√°lculos complejos con una sintaxis similar a la notaci√≥n algebraica. Sin embargo, para un programador universitario, no basta con conocer el s√≠mbolo; es imperativo comprender las reglas de prioridad que el compilador aplica para resolver ambig√ºedades.</p>

            <h3>I. Los Operadores Aritm√©ticos Fundamentales</h3>
            <p>C++ utiliza los siguientes operadores b√°sicos para manipular datos num√©ricos (principalmente <code>int</code>, <code>float</code> y <code>double</code>):</p>

            <div class="table-res">
                <table>
                    <thead>
                        <tr>
                            <th>Operaci√≥n</th>
                            <th>Operador</th>
                            <th>Expresi√≥n en C++</th>
                            <th>Interpretaci√≥n en Ingenier√≠a</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Suma</td>
                            <td><code>+</code></td>
                            <td><code>f + 7</code></td>
                            <td>Adici√≥n simple de dos valores.</td>
                        </tr>
                        <tr>
                            <td>Resta</td>
                            <td><code>-</code></td>
                            <td><code>p - c</code></td>
                            <td>Sustracci√≥n del segundo operando al primero.</td>
                        </tr>
                        <tr>
                            <td>Multiplicaci√≥n</td>
                            <td><code>*</code></td>
                            <td><code>b * m</code></td>
                            <td>Producto escalar de magnitudes.</td>
                        </tr>
                        <tr>
                            <td>Divisi√≥n</td>
                            <td><code>/</code></td>
                            <td><code>x / y</code></td>
                            <td>Cociente entre operandos. <strong>Ojo con el truncamiento</strong>.</td>
                        </tr>
                        <tr>
                            <td>M√≥dulo (Resto)</td>
                            <td><code>%</code></td>
                            <td><code>7 % 4</code></td>
                            <td>Devuelve el remanente de una divisi√≥n entera (Resultado: 3).</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>II. El Fen√≥meno del Truncamiento y el Operador M√≥dulo</h3>
            <p>Seg√∫n <strong>O'Reilly</strong> en <em>Practical C++ Programming</em>, uno de los errores m√°s comunes en la etapa de aprendizaje es ignorar la naturaleza del <span class="abbr" data-title="Truncamiento: La eliminaci√≥n de la parte decimal de un n√∫mero sin realizar redondeo, com√∫n en la divisi√≥n de enteros en C++.">truncamiento</span>. Cuando usted divide dos n√∫meros enteros (ej: <code>7 / 4</code>), C++ devuelve √∫nicamente la parte entera (<code>1</code>). Los decimales no se redondean; simplemente desaparecen de la memoria de c√°lculo.</p>
            
            <p>Para recuperar la informaci√≥n perdida en una divisi√≥n entera, utilizamos el <strong>operador m√≥dulo (<code>%</code>)</strong>. Este operador es exclusivo para tipos de datos enteros. Es extremadamente √∫til en aplicaciones de ingenier√≠a para:</p>
            <ul>
                <li>Determinar la paridad de un n√∫mero (<code>n % 2 == 0</code> es par).</li>
                <li>Ciclar valores dentro de un rango (ej: d√≠as de la semana, √°ngulos de 0 a 360).</li>
                <li>Verificar si un n√∫mero es m√∫ltiplo de otro.</li>
            </ul>

            <h3>III. Precedencia de Operadores (Reglas de Jerarqu√≠a)</h3>
            <p>Para evitar resultados impredecibles en expresiones largas como <code>x = a + b * c;</code>, C++ aplica un orden jer√°rquico estricto. De acuerdo con <strong>Deitel</strong>, si usted no utiliza par√©ntesis, el compilador sigue estas reglas basadas en el est√°ndar ANSI:</p>

            <div class="timeline">
                <div class="timeline-item">
                    <span class="timeline-date">Nivel 1: Agrupamiento ( )</span>
                    <p>Los par√©ntesis tienen la prioridad m√°s alta. Usted debe usarlos para forzar el orden de evaluaci√≥n deseado o simplemente para mejorar la legibilidad del c√≥digo ("Par√©ntesis de claridad").</p>
                </div>
                <div class="timeline-item">
                    <span class="timeline-date">Nivel 2: Multiplicativos (*, /, %)</span>
                    <p>Se eval√∫an antes que las sumas o restas. Si aparecen varios en la misma l√≠nea, se aplican de <strong>izquierda a derecha</strong> (asociatividad por la izquierda).</p>
                </div>
                <div class="timeline-item">
                    <span class="timeline-date">Nivel 3: Aditivos (+, -)</span>
                    <p>Se eval√∫an en √∫ltima instancia. Al igual que los multiplicativos, siguen la regla de asociatividad de izquierda a derecha.</p>
                </div>
            </div>

            <p><strong>Ejemplo de an√°lisis:</strong> En la expresi√≥n <code>y = a * b + c % d;</code> el compilador evaluar√° primero el producto <code>a * b</code> y el m√≥dulo <code>c % d</code>, para finalmente sumar ambos resultados parciales.</p>

            <h3>IV. Diagrama Conceptual de Evaluaci√≥n de Expresiones</h3>
            <p>Visualice c√≥mo el motor de C++ descompone una expresi√≥n compleja paso a paso siguiendo la jerarqu√≠a analizada en los textos de referencia:</p>
            
            <div class="diagram-box">
                <div class="diagram-node"><code>(a + b) * c / d</code></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node">Paso 1: [a+b] <br><small>Agrupamiento</small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node">Paso 2: [Res1 * c]<br><small>Multiplicaci√≥n</small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node">Paso 3: [Res2 / d]<br><small>Divisi√≥n Final</small></div>
            </div>

            <h3>V. Perspectiva de Calidad: Notaci√≥n y Legibilidad</h3>
            <p>Como indica el cuaderno de <strong>UX/UI</strong> aplicado al c√≥digo, la forma en que usted escribe una expresi√≥n aritm√©tica afecta directamente la mantenibilidad del software. Seg√∫n <strong>O'Reilly</strong>, aunque C++ permite escribir <code>x=a*b+c/d;</code> sin espacios, el uso de "espacios en blanco redundantes" (ej: <code>x = a * b + c / d;</code>) reduce la fatiga visual del programador y minimiza errores l√≥gicos durante la depuraci√≥n.</p>
            
            <p>Adem√°s, en el √°mbito universitario se promueve el uso de <span class="abbr" data-title="Constantes Simb√≥licas: Nombres descriptivos que representan valores fijos en el programa para evitar el uso de 'n√∫meros m√°gicos' dif√≠ciles de entender.">constantes</span> para valores fijos. En lugar de escribir <code>total = precio * 1.21;</code>, es preferible definir una constante <code>IVA = 0.21</code> y escribir <code>total = precio * (1 + IVA);</code>. Esto es un pilar de la buena ingenier√≠a de software.</p>

            <div class="practice-box">
                <span class="icon-sec">üß™</span>
                <strong>Laboratorio de Aplicaci√≥n N¬∞ 6:</strong>
                <p>Escrib√≠ un programa que convierta una temperatura dada en grados Fahrenheit a Celsius utilizando la f√≥rmula: <code>C = 5/9 * (F - 32)</code>.</p>
                <p><strong>Desaf√≠o T√©cnico:</strong> Si us√°s variables de tipo <code>int</code> para el c√°lculo <code>5/9</code>, ¬øqu√© resultado obtendr√°s? ¬øC√≥mo pod√©s solucionar el problema del truncamiento sin cambiar todas las variables a tipo flotante? (Pista: Analiz√° el orden de los operandos en el PDF de <strong>Deitel</strong> sobre la divisi√≥n mixta).</p>
            </div>

            <p>Dominar la aritm√©tica y sus reglas de precedencia es fundamental antes de avanzar hacia las estructuras de control. Un error en un par√©ntesis puede costar millones en un sistema financiero o comprometer la seguridad en un sistema de control f√≠sico. Como afirma <strong>Deitel</strong>, en C++, la precisi√≥n matem√°tica es el reflejo de la precisi√≥n del pensamiento del programador.</p>

            <button class="btn-ref" onclick="openRef('ref-deitel')">Referencia: Deitel Cap. 2.6 / O'Reilly Cap. 5</button>
        </section>

        <section id="sec-2-7">
            <span class="icon-sec">‚öñÔ∏è</span>
            <h2>2.7 Toma de decisiones: operadores de igualdad y relacionales</h2>
            
            <p>La capacidad de un software para "decidir" o bifurcar su flujo de ejecuci√≥n es lo que separa a un simple script de una aplicaci√≥n inteligente. En C++, la toma de decisiones se fundamenta en el enunciado <code>if</code> y la evaluaci√≥n de <span class="abbr" data-title="Expresi√≥n Booleana: Una expresi√≥n que tras ser evaluada por el compilador produce un resultado de verdadero (true) o falso (false).">expresiones booleanas</span>. Seg√∫n el PDF de <strong>Deitel</strong>, usted debe comprender que el lenguaje eval√∫a estas condiciones bas√°ndose en un sistema num√©rico subyacente: el valor <code>0</code> representa la falsedad, mientras que cualquier valor distinto de cero (generalmente <code>1</code>) representa la verdad.</p>

            <h3>I. Anatom√≠a del Enunciado <code>if</code></h3>
            <p>El enunciado de selecci√≥n simple <code>if</code> permite ejecutar una instrucci√≥n (o un bloque de ellas) solo si se cumple una condici√≥n espec√≠fica. La sintaxis b√°sica es:</p>
            <pre><code>if (condicion) {
    // C√≥digo que se ejecuta solo si la condici√≥n es verdadera
}</code></pre>
            <p>Como indica <strong>O'Reilly</strong> en <em>Practical C++ Programming</em>, es vital mantener una sangr√≠a (identaci√≥n) consistente despu√©s del <code>if</code>. Aunque C++ no obliga f√≠sicamente al uso de llaves para una sola instrucci√≥n, en el √°mbito universitario se exige su uso para evitar el error del "if colgante" y mejorar la legibilidad del c√≥digo ante futuras expansiones.</p>

            <h3>II. Operadores de Igualdad y Relacionales</h3>
            <p>C++ provee dos grupos de operadores para comparar valores. Estos operadores poseen una jerarqu√≠a de precedencia menor que los operadores aritm√©ticos, lo que permite realizar c√°lculos dentro de la condici√≥n antes de evaluar la verdad de la misma.</p>

            <div class="table-res">
                <table>
                    <thead>
                        <tr>
                            <th>Categor√≠a</th>
                            <th>Operador</th>
                            <th>Significado Acad√©mico</th>
                            <th>Ejemplo L√≥gico</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td rowspan="4"><strong>Relacionales</strong></td>
                            <td><code>&gt;</code></td>
                            <td>Mayor que</td>
                            <td><code>x &gt; y</code></td>
                        </tr>
                        <tr>
                            <td><code>&lt;</code></td>
                            <td>Menor que</td>
                            <td><code>x &lt; y</code></td>
                        </tr>
                        <tr>
                            <td><code>&gt;=</code></td>
                            <td>Mayor o igual que</td>
                            <td><code>x &gt;= y</code></td>
                        </tr>
                        <tr>
                            <td><code>&lt;=</code></td>
                            <td>Menor o igual que</td>
                            <td><code>x &lt;= y</code></td>
                        </tr>
                        <tr>
                            <td rowspan="2"><strong>Igualdad</strong></td>
                            <td><code>==</code></td>
                            <td>Igual a (Comparaci√≥n)</td>
                            <td><code>x == y</code></td>
                        </tr>
                        <tr>
                            <td><code>!=</code></td>
                            <td>Diferente de (No es igual a)</td>
                            <td><code>x != y</code></td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>III. La Gran Trampa: <code>==</code> vs <code>=</code></h3>
            <p>Usted debe estar extremadamente alerta ante este error, que es la causa principal de fallos l√≥gicos en sistemas cr√≠ticos desarrollados en C++. Seg√∫n <strong>O'Reilly</strong>, confundir el operador de igualdad (<code>==</code>) con el de asignaci√≥n (<code>=</code>) dentro de un <code>if</code> es un "error silencioso".</p>
            
            <p>Analiz√° este escenario catastr√≥fico:</p>
            <pre><code>int x = 0;
if (x = 1) { 
    // ¬°Esto siempre ser√° VERDADERO!
}</code></pre>
            <p>¬øQu√© sucedi√≥? En lugar de comparar si <code>x</code> es igual a 1, el programa <strong>asigna</strong> el valor 1 a <code>x</code>. Como el resultado de la asignaci√≥n es 1 (un valor no-cero), C++ interpreta que la condici√≥n es verdadera y entra al bloque. Peor a√∫n, el valor original de su variable ha sido destruido por una escritura destructiva accidental.</p>

            <h3>IV. Diagrama de Flujo de Decisi√≥n</h3>
            <p>El siguiente diagrama ilustra c√≥mo el procesador gestiona el salto condicional basado en la evaluaci√≥n de la expresi√≥n booleana:</p>
            
            <div class="diagram-box">
                <div class="diagram-node">Inicio del <code>if</code></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node">¬øCondici√≥n Verdadera?<br><small>(Resultado != 0)</small></div>
                <div class="diagram-arrow">‚ûî [SI] ‚ûî</div>
                <div class="diagram-node" style="background: rgba(46, 125, 50, 0.2)">Ejecutar Bloque<br>de C√≥digo</div>
            </div>
            <p style="text-align: center; margin-top: -1rem;"><small>‚ûî [NO] ‚ûî Saltear bloque y continuar ejecuci√≥n</small></p>

            <h3>V. Precedencia y Asociatividad Avanzada</h3>
            <p>De acuerdo con el PDF de <strong>Deitel</strong>, los operadores relacionales tienen todos la misma precedencia y se asocian de izquierda a derecha. Los operadores de igualdad tienen una precedencia menor que los relacionales. Considere la expresi√≥n: <code>x < y == z > w</code>. El compilador evaluar√° primero si <code>x < y</code> y si <code>z > w</code>, y finalmente comparar√° los dos resultados booleanos obtenidos. </p>
            
            <p>Sin embargo, como indica el cuaderno de <strong>UX/UI</strong> aplicado al desarrollo, el uso de par√©ntesis (ej: <code>(x < y) == (z > w)</code>) es una norma de calidad obligatoria en esta c√°tedra, ya que reduce el esfuerzo cognitivo del revisor del c√≥digo y previene ambig√ºedades interpretativas.</p>

            <div class="practice-box">
                <span class="icon-sec">üß™</span>
                <strong>Laboratorio de Aplicaci√≥n N¬∞ 7:</strong>
                <p>Desarroll√° un programa que pida al usuario su edad y el a√±o actual. El sistema debe imprimir "Usted es mayor de edad" solo si la edad es mayor o igual a 18. Adem√°s, si el a√±o ingresado es menor a 2024, debe sonar una alerta sonora (<code>\a</code>) indicando un posible error de entrada.</p>
                <p><strong>Desaf√≠o de Ingenier√≠a:</strong> Intent√° realizar una comparaci√≥n que verifique si tres n√∫meros ingresados por el usuario son todos iguales entre s√≠ utilizando √∫nicamente operadores de igualdad y sentencias <code>if</code> anidadas.</p>
            </div>

            <p>Dominar la toma de decisiones es el umbral hacia la programaci√≥n compleja. En la pr√≥xima secci√≥n (opcional), veremos c√≥mo aplicar estos conceptos de l√≥gica y selecci√≥n al an√°lisis de requerimientos de un sistema real: el cajero autom√°tico (ATM). Como afirma <strong>Deitel</strong>, la programaci√≥n no es solo dar √≥rdenes, sino ense√±ar a la m√°quina a evaluar su entorno con precisi√≥n quir√∫rgica.</p>

            <button class="btn-ref" onclick="openRef('ref-deitel')">Referencia: Deitel Cap. 2.7 / O'Reilly Cap. 6</button>
        </section>

		<section id="sec-2-8">
            <span class="icon-sec">üèß</span>
            <h2>2.8 (Opcional) Ejemplo pr√°ctico de Ingenier√≠a de Software: An√°lisis de la especificaci√≥n de requerimientos de un ATM</h2>
            
            <p>La transici√≥n de la programaci√≥n b√°sica a la construcci√≥n de sistemas robustos requiere una disciplina fundamental: la <strong>Ingenier√≠a de Software</strong>. Como se postula en el PDF de <strong>Deitel</strong>, antes de tipear una sola l√≠nea de c√≥digo en su IDE, usted debe ser capaz de desglosar un problema complejo en sus unidades l√≥gicas esenciales. En esta secci√≥n opcional, pero acad√©micamente vital, analizaremos el caso de estudio de un <span class="abbr" data-title="ATM: Automated Teller Machine. Un dispositivo electr√≥nico de telecomunicaciones que permite a los clientes de las instituciones financieras realizar transacciones financieras.">ATM</span> (Cajero Autom√°tico) para comprender c√≥mo se modela el software utilizando el paradigma de objetos.</p>

            <h3>I. El Desaf√≠o de la Especificaci√≥n de Requerimientos</h3>
            <p>Imagine que usted es contratado para desarrollar el software de una nueva red de cajeros para un banco local. Seg√∫n el cuaderno de <strong>Desarrollo Web</strong>, el √©xito de un proyecto no depende solo de la sintaxis, sino de qu√© tan bien el software satisface las necesidades del usuario final. La especificaci√≥n de requerimientos es el documento t√©cnico que describe <em>qu√©</em> debe hacer el sistema, sin entrar a√∫n en el <em>c√≥mo</em>.</p>
            
            <p>Para nuestro ATM, los requerimientos b√°sicos estipulan que el usuario debe poder:</p>
            <ul>
                <li>Autenticarse mediante un n√∫mero de cuenta y un <span class="abbr" data-title="PIN: Personal Identification Number. Clave num√©rica secreta utilizada para validar la identidad del usuario.">PIN</span>.</li>
                <li>Consultar el saldo disponible en su cuenta.</li>
                <li>Realizar retiros de efectivo (siempre que el saldo y la reserva f√≠sica del cajero lo permitan).</li>
                <li>Depositar fondos mediante sobres de dep√≥sito.</li>
            </ul>

            <p>De acuerdo con <strong>O'Reilly</strong> en <em>Practical C++ Programming</em>, un error com√∫n en ingenier√≠a es ignorar las limitaciones del hardware. Un cajero autom√°tico no es solo c√≥digo; es una orquesta de componentes f√≠sicos (dispensador de efectivo, ranura de dep√≥sito, pantalla) que el software debe coordinar con precisi√≥n milim√©trica.</p>

            <h3>II. La T√©cnica de Identificaci√≥n de Sustantivos (Candidatos a Clases)</h3>
            <p>Para modelar este sistema bajo el paradigma de objetos, aplicamos un an√°lisis ling√º√≠stico sobre la especificaci√≥n. Usted debe buscar los <strong>sustantivos</strong> presentes en los requerimientos, ya que estos suelen representar las entidades o <span class="abbr" data-title="Clases: Modelos o plantillas que definen los atributos (datos) y m√©todos (comportamientos) de un tipo de objeto.">clases</span> de nuestro sistema. Analiz√° la siguiente tabla de clasificaci√≥n t√©cnica:</p>

            <div class="table-res">
                <table>
                    <thead>
                        <tr>
                            <th>Sustantivo extra√≠do</th>
                            <th>Rol en el Sistema</th>
                            <th>Decisi√≥n de Ingenier√≠a</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>ATM</td>
                            <td>Controlador principal.</td>
                            <td>Se convierte en la clase <code>CajeroAutom√°tico</code>.</td>
                        </tr>
                        <tr>
                            <td>Pantalla</td>
                            <td>Interfaz de salida de informaci√≥n.</td>
                            <td>Clase <code>Pantalla</code> (encapsula la salida de texto).</td>
                        </tr>
                        <tr>
                            <td>Teclado num√©rico</td>
                            <td>Interfaz de entrada de datos.</td>
                            <td>Clase <code>Teclado</code> (encapsula <code>std::cin</code>).</td>
                        </tr>
                        <tr>
                            <td>Dispensador</td>
                            <td>Mecanismo f√≠sico de efectivo.</td>
                            <td>Clase <code>DispensadorEfectivo</code>.</td>
                        </tr>
                        <tr>
                            <td>Ranura de dep√≥sito</td>
                            <td>Receptor f√≠sico de sobres.</td>
                            <td>Clase <code>RanuraDep√≥sito</code>.</td>
                        </tr>
                        <tr>
                            <td>Cuenta / Base de Datos</td>
                            <td>Persistencia y l√≥gica financiera.</td>
                            <td>Clases <code>Cuenta</code> y <code>BaseDatosBanco</code>.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Es importante notar que sustantivos como "PIN" o "Saldo" no suelen convertirse en clases independientes. Seg√∫n <strong>Deitel</strong>, estos son <strong>atributos</strong>: datos que pertenecen a una clase (en este caso, a la clase <code>Cuenta</code>). Esta distinci√≥n es la base de una arquitectura limpia.</p>

            <h3>III. La T√©cnica de Identificaci√≥n de Verbos (Candidatos a Funciones)</h3>
            <p>Una vez identificadas las entidades, debemos dotarlas de comportamiento. Los <strong>verbos</strong> en nuestra especificaci√≥n indican las acciones que las clases deben ser capaces de realizar. En C++, estos se implementan como <span class="abbr" data-title="Funciones Miembros: Tambi√©n llamadas m√©todos, son las operaciones o comportamientos asociados a una clase espec√≠fica.">funciones miembros</span>.</p>
            
            <p>Considere el flujo de una transacci√≥n de retiro:</p>
            <ol>
                <li>El cajero solicita (<em>verbo</em>) el PIN.</li>
                <li>La base de datos valida (<em>verbo</em>) las credenciales.</li>
                <li>El cajero muestra (<em>verbo</em>) el men√∫ principal.</li>
                <li>El dispensador entrega (<em>verbo</em>) los billetes.</li>
            </ol>

            <p>De acuerdo con el enfoque de <strong>O'Reilly</strong>, cada uno de estos verbos debe asignarse a la clase que tenga la "responsabilidad" m√°s l√≥gica sobre esa acci√≥n. Por ejemplo, el verbo "validar" pertenece a la <code>BaseDatosBanco</code>, no a la <code>Pantalla</code>.</p>

            <h3>IV. Diagrama Conceptual de Relaciones (Arquitectura de Objetos)</h3>
            <p>Un ingeniero utiliza lenguajes visuales como <span class="abbr" data-title="UML: Unified Modeling Language. El est√°ndar internacional para representar gr√°ficamente la estructura y comportamiento de los sistemas de software.">UML</span> para entender c√≥mo interact√∫an estos componentes. El siguiente diagrama ilustra la jerarqu√≠a de composici√≥n de nuestro sistema ATM:</p>

            <div class="diagram-box">
                <div class="diagram-node"><strong>ATM (Clase Principal)</strong><br><small>Contiene:</small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <div class="diagram-node">Pantalla</div>
                    <div class="diagram-node">Teclado</div>
                    <div class="diagram-node">Dispensador</div>
                </div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node" style="border-style: dashed;">Base de Datos<br><small>(Sistema Externo)</small></div>
            </div>

            <p>Esta estructura de "composici√≥n" (donde un objeto grande est√° formado por objetos m√°s peque√±os) es una de las potencias de C++. Seg√∫n <strong>Deitel</strong>, esto permite que si en el futuro decidimos cambiar el hardware del teclado por una pantalla t√°ctil, solo debamos modificar o reemplazar la clase <code>Teclado</code> sin alterar la l√≥gica de retiro central del <code>ATM</code>. Esto se conoce acad√©micamente como <strong>bajo acoplamiento</strong>.</p>

            <h3>V. El Concepto de Estado en el Modelado</h3>
            <p>Usted debe considerar que el sistema siempre se encuentra en un "estado" determinado. Por ejemplo, el cajero puede estar en estado "Esperando Usuario", "Procesando Transacci√≥n" o "Fuera de Servicio". El software de ingenier√≠a debe gestionar estas transiciones para evitar comportamientos err√≥neos (como dispensar dinero antes de validar el PIN).</p>
            
            <p>Como se destaca en el cuaderno de <strong>Metodolog√≠as Activas</strong>, modelar estos estados ayuda al estudiante a visualizar el flujo l√≥gico del programa antes de enfrentarse a los desaf√≠os de la implementaci√≥n t√©cnica. La programaci√≥n orientada a objetos facilita este manejo mediante la encapsulaci√≥n del estado interno dentro de cada objeto.</p>

            <h3>VI. Perspectiva Acad√©mica: ¬øPor qu√© es importante este an√°lisis?</h3>
            <p>En el √°mbito universitario, no buscamos "codificadores", sino dise√±adores de sistemas. El an√°lisis del ATM nos ense√±a tres pilares fundamentales analizados en los PDFs de referencia:</p>
            <ul>
                <li><strong>Abstracci√≥n:</strong> Ignoramos los cables y circuitos para enfocarnos en la l√≥gica de "Cuentas" y "Saldos".</li>
                <li><strong>Modularidad:</strong> Dividimos un problema inmenso en clases peque√±as y manejables (Pantalla, Teclado, etc.).</li>
                <li><strong>Reutilizaci√≥n:</strong> La clase <code>Pantalla</code> que dise√±amos para el ATM podr√≠a ser reutilizada en un software de quiosco informativo con cambios m√≠nimos.</li>
            </ul>

            <div class="practice-box">
                <span class="icon-sec">üß†</span>
                <strong>Desaf√≠o de Pensamiento Cr√≠tico:</strong>
                <p>Imagine que el banco le pide agregar una funcionalidad de "Recarga de Celular" al ATM. Bajo el enfoque de ingenier√≠a de software que acabamos de ver:</p>
                <ol>
                    <li>¬øQu√© nuevos <strong>sustantivos</strong> (clases) identificar√≠a?</li>
                    <li>¬øA qu√© clase existente le asignar√≠a el <strong>verbo</strong> "solicitar n√∫mero telef√≥nico"?</li>
                    <li>¬øC√≥mo afectar√≠a este cambio a la clase <code>BaseDatosBanco</code>?</li>
                </ol>
                <p><em>Sugerencia:</em> No piense en el c√≥digo, piense en la estructura de responsabilidades descrita en el cap√≠tulo 2 de <strong>Deitel</strong>.</p>
            </div>

            <p>En conclusi√≥n, el an√°lisis de requerimientos del ATM es el puente perfecto para entrar de lleno en los conceptos de <strong>Encapsulamiento</strong> y <strong>Ocultamiento de datos</strong> que exploraremos en la siguiente secci√≥n. Entender que el software es un modelo de la realidad es el primer paso para convertirse en un profesional de la ingenier√≠a inform√°tica.</p>

            <button class="btn-ref" onclick="openRef('ref-deitel')">Referencia: Deitel Secc. 1.21 & 2.8 / O'Reilly Cap. 1</button>
        </section>

        <section id="sec-2-9">
            <span class="icon-sec">üõ°Ô∏è</span>
            <h2>2.9 Entender los conceptos de ingenier√≠a del software relacionado con el encapsulamiento y ocultamiento de datos</h2>
            
            <p>En el √°mbito de la ingenier√≠a de software moderna, la complejidad es el principal adversario. El <strong>encapsulamiento</strong> y el <strong>ocultamiento de datos</strong> (<em>information hiding</em>) no son meras caracter√≠sticas sint√°cticas de C++, sino pilares arquitect√≥nicos que permiten construir sistemas escalables y seguros. Como postula <strong>Deitel</strong>, el dise√±o orientado a objetos busca emular el mundo real, donde interactuamos con entidades complejas sin necesidad de comprender su mec√°nica interna microsc√≥pica.</p>

            <h3>I. Definici√≥n T√©cnica de Encapsulamiento</h3>
            <p>El encapsulamiento es el proceso de empaquetar <strong>miembros de datos</strong> (atributos) y <strong>funciones miembro</strong> (comportamientos) en una unidad l√≥gica coherente llamada <strong>Clase</strong>. Seg√∫n <strong>O'Reilly</strong> en <em>Practical C++ Programming</em>, este empaquetamiento crea un "l√≠mite de software" que define qu√© pertenece a la entidad y qu√© es externo a ella.</p>
            
            <p>Usted debe visualizar la clase como una c√°psula medicinal: los componentes activos (datos) est√°n protegidos por una cubierta (la clase) y solo se liberan o interact√∫an mediante canales espec√≠ficos. En C++, esto se logra mediante la agrupaci√≥n de variables y funciones dentro de un mismo bloque <code>class</code>, estableciendo una relaci√≥n indisoluble entre la informaci√≥n y las operaciones que act√∫an sobre ella.</p>

            <h3>II. El Principio de Ocultamiento de Informaci√≥n</h3>
            <p>Si el encapsulamiento es el acto de "agrupar", el ocultamiento de datos es el acto de "proteger". De acuerdo con el PDF de <strong>Deitel</strong>, el objetivo primordial es evitar que el c√≥digo cliente (el c√≥digo que usa nuestra clase) acceda directamente a los detalles de implementaci√≥n interna. Esto se fundamenta en tres premisas acad√©micas:</p>
            
            <ol>
                <li><strong>Integridad del Estado:</strong> Si un programador externo puede modificar directamente una variable privada (ej: <code>saldo = -5000</code>), puede romper las reglas de negocio del sistema. Al ocultar el dato, obligamos al uso de una interfaz controlada.</li>
                <li><strong>Independencia de Implementaci√≥n:</strong> Usted puede cambiar c√≥mo se almacena un dato internamente (por ejemplo, pasar de usar un <code>int</code> a un <code>long long</code>) sin que el resto del programa se entere, siempre que la interfaz p√∫blica se mantenga constante.</li>
                <li><strong>Reducci√≥n de la Carga Cognitiva:</strong> Seg√∫n el cuaderno de <strong>UX/UI</strong> aplicado al desarrollo, un programador solo debe ver lo que necesita usar. Exponer detalles irrelevantes aumenta la probabilidad de errores accidentales.</li>
            </ol>

            <h3>III. Interfaz P√∫blica vs. Implementaci√≥n Privada</h3>
            <p>Un sistema bien dise√±ado se divide en dos regiones claramente delimitadas:</p>
            <ul>
                <li><strong>La Interfaz (El "Qu√©"):</strong> Definida usualmente en la secci√≥n <code>public</code>. Es el contrato que la clase firma con el mundo exterior. Contiene las funciones que el usuario puede invocar para obtener servicios del objeto.</li>
                <li><strong>La Implementaci√≥n (El "C√≥mo"):</strong> Definida en la secci√≥n <code>private</code>. Contiene los datos sensibles y funciones de apoyo que el objeto utiliza para cumplir su tarea, pero que no son de inter√©s para el usuario.</li>
            </ul>

            <div class="diagram-box">
                <div class="diagram-node" style="border-color: var(--success);"><strong>Interfaz P√∫blica</strong><br><small>M√©todos: depositar(), retirar()</small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node" style="border-color: #d32f2f;"><strong>N√∫cleo Privado (Oculto)</strong><br><small>Atributo: double saldo</small></div>
            </div>

            <h3>IV. Analog√≠a de Ingenier√≠a: El Microondas y el Autom√≥vil</h3>
            <p><strong>Deitel</strong> utiliza analog√≠as magistrales para explicar este concepto. Imagine un microondas: usted tiene una <strong>interfaz p√∫blica</strong> (botones de tiempo, potencia e inicio). Detr√°s de esos botones hay una <strong>implementaci√≥n privada</strong> compleja (magnetr√≥n, transformador, circuitos de alta tensi√≥n). </p>
            
            <p>Si el fabricante permitiera que usted tocara directamente los cables internos para calentar la comida, el riesgo de electrocuci√≥n o de romper el aparato ser√≠a inmenso. El microondas <em>encapsula</em> los componentes peligrosos y los <em>oculta</em> tras una carcasa, exponiendo solo una interfaz segura. En C++, la palabra clave <code>private</code> es nuestra carcasa protectora.</p>

            <h3>V. Beneficios en el Ciclo de Vida del Software</h3>
            <p>De acuerdo con el enfoque pr√°ctico de <strong>O'Reilly</strong>, el ocultamiento de datos facilita enormemente la **depuraci√≥n** (debugging). Si una variable <code>x</code> tiene un valor incorrecto y es p√∫blica, cualquier parte de un programa de un mill√≥n de l√≠neas pudo haberla modificado. Si es privada, usted sabe con certeza absoluta que el error reside dentro de las funciones miembro de esa clase espec√≠fica. Esto reduce dr√°sticamente el tiempo de mantenimiento.</p>

            <div class="table-res">
                <table>
                    <thead>
                        <tr>
                            <th>Concepto</th>
                            <th>Visi√≥n Procedimental (Lenguaje C)</th>
                            <th>Visi√≥n Orientada a Objetos (C++)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Seguridad de Datos</strong></td>
                            <td>Acceso global; cualquiera puede modificar cualquier variable.</td>
                            <td>Acceso restringido; solo m√©todos autorizados modifican datos.</td>
                        </tr>
                        <tr>
                            <td><strong>Modularidad</strong></td>
                            <td>Funciones sueltas que operan sobre estructuras externas.</td>
                            <td>Objetos aut√≥nomos que contienen sus propios datos.</td>
                        </tr>
                        <tr>
                            <td><strong>Mantenibilidad</strong></td>
                            <td>Un cambio en un dato puede romper todo el sistema.</td>
                            <td>Cambios internos son invisibles para el resto del sistema.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>Como se destaca en el cuaderno de <strong>Metodolog√≠as Activas</strong>, este cambio de mentalidad es el mayor desaf√≠o para el estudiante. Usted debe dejar de pensar en "pasos a seguir" para comenzar a pensar en "entidades con responsabilidades". El ocultamiento de datos es la herramienta que garantiza que cada entidad sea due√±a de su propio destino.</p>

            <div class="practice-box">
                <span class="icon-sec">üß†</span>
                <strong>Reflexi√≥n Acad√©mica:</strong>
                <p>Considere una clase <code>SensorTemperatura</code>. Si el atributo <code>lecturaActual</code> fuera p√∫blico, un hacker o un error de c√≥digo podr√≠a asignarle un valor falso (ej: 1000 grados), provocando una falla en un sistema de refrigeraci√≥n industrial. </p>
                <p><strong>Desaf√≠o:</strong> ¬øC√≥mo implementar√≠a usted una "interfaz p√∫blica" que permita leer la temperatura pero impida que alguien externo la modifique arbitrariamente? Piense en el concepto de funciones de solo lectura analizado en <strong>Deitel</strong>.</p>
            </div>

            <p>En conclusi√≥n, el encapsulamiento y el ocultamiento no son restricciones, sino libertades. Le dan al programador la libertad de mejorar su c√≥digo interno sin temor a romper el trabajo de otros. En las secciones 2.11 y 2.13, aprenderemos la sintaxis exacta para aplicar estos conceptos fundamentales.</p>

            <button class="btn-ref" onclick="openRef('ref-deitel')">Referencia: Deitel Cap. 3.2 y 9.2 / O'Reilly Cap. 13</button>
        </section>



        <section id="sec-2-10">
            <span class="icon-sec">üíé</span>
            <h2>2.10 Entender conceptualmente la abstracci√≥n de datos y los tipos de datos abstractos (TDA)</h2>
            
            <p>Para un profesional de la ingenier√≠a de software, la <strong>abstracci√≥n</strong> no es un concepto vago, sino una herramienta de dise√±o fundamental que permite gestionar la complejidad inherente a los grandes sistemas computacionales. Como se postula en el PDF de <strong>Deitel</strong>, usted debe visualizar la abstracci√≥n como la capacidad de enfocarse en las caracter√≠sticas esenciales de una entidad mientras se ignoran, deliberadamente, los detalles accidentales o de implementaci√≥n. En esta secci√≥n, profundizaremos en el concepto de <span class="abbr" data-title="TDA: Tipo de Dato Abstracto. Un modelo l√≥gico que define un conjunto de datos y las operaciones que pueden realizarse sobre ellos, independientemente de su implementaci√≥n en el hardware.">Tipo de Dato Abstracto (TDA)</span> y su materializaci√≥n t√©cnica en C++.</p>

            <h3>I. La Filosof√≠a de la Abstracci√≥n en Ingenier√≠a</h3>
            <p>La abstracci√≥n es un proceso de "separaci√≥n de intereses". Seg√∫n el cuaderno de <strong>Metodolog√≠as Activas</strong>, el aprendizaje universitario requiere que usted sea capaz de elevar su nivel de pensamiento desde los "p√≠xeles y bits" hacia los "conceptos y dominios". En el mundo real, los seres humanos interactuamos con abstracciones constantemente: usted conduce un autom√≥vil (abstracci√≥n) utilizando una interfaz simple (volante, pedales) sin necesidad de ser un experto en termodin√°mica de motores de combusti√≥n interna.</p>
            
            <p>De acuerdo con <strong>O'Reilly</strong> en <em>Practical C++ Programming</em>, un TDA es un modelo matem√°tico. Este modelo define:</p>
            <ol>
                <li><strong>Un dominio:</strong> El conjunto de valores v√°lidos (ej: para un TDA <code>Fecha</code>, los d√≠as deben estar entre 1 y 31).</li>
                <li><strong>Un conjunto de operaciones:</strong> Qu√© se puede hacer con esos datos (ej: <code>sumarDias</code>, <code>esAnioBisiesto</code>).</li>
            </ol>
            <p>Lo crucial es que el usuario del TDA solo conoce <strong>qu√©</strong> hace el tipo, pero no <strong>c√≥mo</strong> lo hace. Esta separaci√≥n es lo que permite que m√∫ltiples programadores trabajen en un mismo proyecto sin pisarse los pies.</p>

            <h3>II. De Tipos Primitivos a TDAs</h3>
            <p>C++ nos provee tipos de datos integrados (primitivos) como <code>int</code>, <code>float</code> o <code>char</code>. Curiosamente, estos ya act√∫an como abstracciones. Seg√∫n <strong>Deitel</strong>, cuando usted declara un <code>int</code>, no se preocupa por c√≥mo la CPU maneja el complemento a dos o los registros de 32 bits; usted simplemente usa el dato. </p>
            
            <p>Sin embargo, en sistemas universitarios e industriales, los tipos primitivos son insuficientes para representar la realidad del negocio. Necesitamos crear nuestros propios tipos. Un TDA bien dise√±ado en C++ (usualmente implementado mediante una <code>clase</code>) debe comportarse con la misma naturalidad que un tipo integrado. Usted debe aspirar a crear tipos que parezcan "extensiones naturales" del lenguaje.</p>

            <div class="table-res">
                <table>
                    <thead>
                        <tr>
                            <th>Atributo</th>
                            <th>Tipo de Dato Primitivo (Built-in)</th>
                            <th>Tipo de Dato Abstracto (User-defined)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Definici√≥n</strong></td>
                            <td>Provisto por el compilador de C++.</td>
                            <td>Dise√±ado por el ingeniero de software.</td>
                        </tr>
                        <tr>
                            <td><strong>Interfaz</strong></td>
                            <td>Operadores fijos (+, -, *, /).</td>
                            <td>Funciones miembro personalizadas (m√©todos).</td>
                        </tr>
                        <tr>
                            <td><strong>Representaci√≥n</strong></td>
                            <td>Fija por la arquitectura del hardware.</td>
                            <td>Oculta y modificable por el desarrollador.</td>
                        </tr>
                        <tr>
                            <td><strong>Ejemplo</strong></td>
                            <td><code>int</code>, <code>double</code></td>
                            <td><code>CuentaBancaria</code>, <code>Vector3D</code></td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>III. La Met√°fora de la "Caja Negra"</h3>
            <p>Un TDA funciona como una <strong>caja negra</strong>. De acuerdo con el enfoque de <strong>O'Reilly</strong>, el programador cliente ve el exterior de la caja (la interfaz p√∫blica). Los detalles internos (la representaci√≥n de datos y el c√≥digo de las funciones) est√°n dentro de la caja y son invisibles. </p>
            
            <p>Esta opacidad es deliberada. Si usted dise√±a un TDA <code>Tiempo</code> que almacena la hora como tres enteros (hora, minuto, segundo), y luego decide que es m√°s eficiente almacenarla como un solo entero que cuente los "segundos desde la medianoche", el cambio no deber√≠a afectar a ninguna otra parte del sistema. Esta es la esencia de la <strong>mantenibilidad</strong> analizada en los textos de referencia.</p>

            <h3>IV. Diagrama de Interacci√≥n con un TDA</h3>
            <p>El siguiente diagrama ilustra c√≥mo fluye la informaci√≥n a trav√©s de la frontera de abstracci√≥n:</p>

            <div class="diagram-box">
                <div class="diagram-node"><strong>Usuario / Cliente</strong><br><small>Env√≠a comando: <code>f.mostrar()</code></small></div>
                <div class="diagram-arrow">‚ûî [Interfaz] ‚ûî</div>
                <div class="diagram-node" style="background: var(--bg-secondary); border-style: dotted;"><strong>Implementaci√≥n TDA</strong><br><small>L√≥gica de formateo oculta</small></div>
                <div class="diagram-arrow">‚ûî [Retorno] ‚ûî</div>
                <div class="diagram-node">"06/01/2026"</div>
            </div>

            <h3>V. El TDA como Contrato de Ingenier√≠a</h3>
            <p>Usted debe ver un TDA como un <strong>contrato</strong>. El dise√±ador del TDA promete que las operaciones funcionar√°n correctamente siempre que se respeten las <span class="abbr" data-title="Precondiciones: Condiciones que deben ser verdaderas antes de invocar una operaci√≥n para asegurar que el resultado sea v√°lido.">precondiciones</span>. Por ejemplo, en un TDA <code>Pila</code> (Stack), la precondici√≥n para la operaci√≥n <code>desapilar</code> es que la pila no est√© vac√≠a. </p>
            
            <p>Como se destaca en el cuaderno de <strong>Desarrollo Web</strong>, la rigurosidad en la definici√≥n de estos contratos es lo que permite la integraci√≥n de software de terceros. En C++, las clases permiten formalizar este contrato mediante la separaci√≥n de archivos de cabecera (<code>.h</code>) para la interfaz y archivos de implementaci√≥n (<code>.cpp</code>).</p>

            <h3>VI. Ventajas Acad√©micas y Profesionales</h3>
            <p>Dominar la abstracci√≥n de datos otorga beneficios tangibles analizados por <strong>Deitel</strong>:</p>
            <ul>
                <li><strong>Extensibilidad:</strong> Es f√°cil agregar nuevas funcionalidades a un TDA sin corromper las existentes.</li>
                <li><strong>Localizaci√≥n de Errores:</strong> Si un dato se corrompe, la b√∫squeda del culpable se limita a la implementaci√≥n del TDA, no a todo el c√≥digo fuente.</li>
                <li><strong>Reutilizaci√≥n:</strong> Un TDA <code>Lista</code> dise√±ado para un proyecto escolar puede ser el mismo que utilice en un entorno profesional a√±os despu√©s.</li>
            </ul>

            <div class="practice-box">
                <span class="icon-sec">üß†</span>
                <strong>Laboratorio de Pensamiento Abstracto:</strong>
                <p>Imagine que debe dise√±ar un TDA llamado <code>NumeroRacional</code> para representar fracciones (ej: 3/4). </p>
                <ol>
                    <li>¬øQu√© <strong>datos esenciales</strong> debe ocultar para que el usuario no pueda crear una fracci√≥n con denominador cero?</li>
                    <li>¬øQu√© <strong>operaciones</strong> (m√©todos) deber√≠a proveer en su interfaz p√∫blica?</li>
                    <li>¬øC√≥mo manejar√≠a la simplificaci√≥n autom√°tica de la fracci√≥n (ej: transformar 2/4 en 1/2) sin que el usuario tenga que pedirlo expl√≠citamente?</li>
                </ol>
                <p><em>Pista Acad√©mica:</em> Piense en la diferencia entre el "Qu√©" (quiero sumar racionales) y el "C√≥mo" (c√≥mo calcular el m√≠nimo com√∫n m√∫ltiplo internamente) explicada en el cap√≠tulo 9 de <strong>Deitel</strong>.</p>
            </div>

            <p>En conclusi√≥n, los Tipos de Datos Abstractos son el puente conceptual entre el problema del mundo real y la implementaci√≥n t√©cnica. Al entender que las clases en C++ son la herramienta para materializar TDAs, usted ha dado el paso m√°s importante hacia la madurez en el paradigma de objetos. En la siguiente secci√≥n, aprenderemos la sintaxis exacta para <strong>crear</strong> estas estructuras de poder.</p>

            <button class="btn-ref" onclick="openRef('ref-deitel')">Referencia: Deitel Cap. 3.4 y 18.2 / O'Reilly Cap. 12</button>
        </section>

        <section id="sec-2-11">
            <span class="icon-sec">üèóÔ∏è</span>
            <h2>2.11 Crear tipos de datos abstractos en C++: Clases</h2>
            
            <p>En el coraz√≥n del paradigma de objetos reside la capacidad del programador para trascender los tipos de datos b√°sicos provistos por el hardware. Como se analiza en el PDF de <strong>Deitel</strong>, C++ permite al ingeniero de software "extender el lenguaje" mediante la creaci√≥n de sus propios tipos de datos. La herramienta fundamental para materializar este concepto es la <strong>Clase</strong> (<em>class</em>). Una clase no es un objeto en s√≠ mismo, sino el plano maestro o <span class="abbr" data-title="Blueprint (Plano maestro): Met√°fora de ingenier√≠a que describe a la clase como la especificaci√≥n t√©cnica necesaria para construir m√∫ltiples instancias f√≠sicas (objetos).">blueprint</span> a partir del cual se fabricar√°n las instancias reales que poblar√°n la memoria del sistema.</p>

            <h3>I. Anatom√≠a y Sintaxis de una Clase en C++</h3>
            <p>De acuerdo con el enfoque pr√°ctico de <strong>O'Reilly</strong>, la declaraci√≥n de una clase debe ser rigurosa. Usted debe visualizar la clase como un contenedor que unifica dos conceptos anteriormente dispersos en la programaci√≥n procedimental:</p>
            <ol>
                <li><strong>Atributos (Datos Miembros):</strong> Representan el <em>estado</em> del objeto. Son variables de cualquier tipo (primitivo o complejo) que residen dentro de la clase.</li>
                <li><strong>Comportamientos (Funciones Miembros / M√©todos):</strong> Representan las <em>capacidades</em> del objeto. Son funciones que operan sobre los datos internos de la clase.</li>
            </ol>

            <p>Analice la sintaxis formal de una clase universitaria est√°ndar:</p>
            <pre><code>// Definici√≥n de la clase Estudiante
class Estudiante {
public:
   // Interfaz p√∫blica: servicios que el objeto ofrece al exterior
   void establecerNombre( std::string nombreIngresado );
   void mostrarPromedio();

private:
   // Miembros privados: datos ocultos para seguridad e integridad
   std::string nombre;
   double promedioAcademico;
}; // ¬°IMPORTANTE! El punto y coma final es obligatorio.</code></pre>

            <h3>II. El "Punto y Coma" Fatal: Una Lecci√≥n de Historia</h3>
            <p>Usted notar√° que la definici√≥n de una clase finaliza con un punto y coma (<code>};</code>). Seg√∫n <strong>Deitel</strong>, este es uno de los errores sint√°cticos m√°s persistentes en estudiantes novatos. La raz√≥n t√©cnica es hist√≥rica: en el lenguaje C (padre de C++), la definici√≥n de una estructura (<code>struct</code>) pod√≠a ir seguida inmediatamente por la declaraci√≥n de una variable de ese tipo. Aunque en la programaci√≥n moderna de C++ rara vez declaramos objetos de esa forma, el compilador a√∫n espera ese delimitador para cerrar la unidad l√≥gica de definici√≥n de tipo. Olvidarlo generar√° un mensaje de error que, a menudo, el compilador reportar√° en la l√≠nea siguiente, causando confusi√≥n en el proceso de <span class="abbr" data-title="Depuraci√≥n (Debugging): Proceso de identificar, localizar y corregir errores de software (bugs) en el c√≥digo fuente.">depuraci√≥n</span>.</p>

            <h3>III. Especificadores de Acceso: El Guardi√°n de la Puerta</h3>
            <p>Como indica el PDF de <strong>O'Reilly</strong> en <em>Practical C++ Programming</em>, el control de acceso es lo que diferencia a una clase profesional de un simple agrupamiento de variables. C++ utiliza palabras clave seguidas de dos puntos para definir la visibilidad:</p>
            <ul>
                <li><strong><code>public:</code></strong> Todo lo que se declare bajo esta secci√≥n ser√° accesible desde cualquier otra funci√≥n del programa (como <code>main</code>). Representa la <strong>Interfaz</strong> del TDA.</li>
                <li><strong><code>private:</code></strong> Es el valor predeterminado si no se especifica nada. Solo las funciones que pertenecen a la propia clase pueden ver o modificar estos miembros. Representa el <strong>Ocultamiento</strong>.</li>
            </ul>
            <p>En el √°mbito universitario, se exige que los datos (atributos) sean siempre <code>private</code> y que el acceso a ellos se realice √∫nicamente a trav√©s de funciones p√∫blicas conocidas como <em>getters</em> y <em>setters</em>. Seg√∫n el cuaderno de <strong>Metodolog√≠as Activas</strong>, esta disciplina previene que el estado interno del objeto sea corrompido por el c√≥digo cliente.</p>

            <h3>IV. Representaci√≥n Visual: Del C√≥digo al Diagrama</h3>
            <p>Un ingeniero debe ser capaz de modelar antes de programar. El siguiente diagrama conceptual ilustra la estructura de la clase <code>Estudiante</code> analizada arriba:</p>

            <div class="diagram-box">
                <div class="diagram-node" style="border-width: 3px;">
                    <strong>Estudiante (Clase)</strong><hr>
                    - nombre: string<br>
                    - promedioAcademico: double<hr>
                    + establecerNombre()<br>
                    + mostrarPromedio()
                </div>
            </div>
            <p style="text-align: center; font-size: 0.9rem; color: var(--text-secondary);">Diagrama 2.11a: Representaci√≥n simplificada de clase. El signo (-) indica privado y (+) indica p√∫blico.</p>

            <h3>V. Comparativa: Tipos Integrados vs. Tipos de Clase</h3>
            <p>De acuerdo con <strong>Deitel</strong>, una vez que usted define una clase, puede usarla para crear variables con la misma facilidad con la que usa un <code>int</code>. Sin embargo, existe una diferencia sem√°ntica vital que usted debe comprender:</p>

            <div class="table-res">
                <table>
                    <thead>
                        <tr>
                            <th>Caracter√≠stica</th>
                            <th>Tipo <code>int</code> (Primitivo)</th>
                            <th>Tipo <code>Estudiante</code> (Clase)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Instanciaci√≥n</strong></td>
                            <td><code>int x;</code></td>
                            <td><code>Estudiante miAlumno;</code></td>
                        </tr>
                        <tr>
                            <td><strong>Naturaleza</strong></td>
                            <td>Contiene un √∫nico valor num√©rico.</td>
                            <td>Contiene m√∫ltiples datos y funciones (un objeto).</td>
                        </tr>
                        <tr>
                            <td><strong>Acceso</strong></td>
                            <td>Directo al valor.</td>
                            <td>Mediante el operador punto (<code>miAlumno.mostrarPromedio()</code>).</td>
                        </tr>
                        <tr>
                            <td><strong>Dise√±o</strong></td>
                            <td>Fijo por el est√°ndar del lenguaje.</td>
                            <td>Totalmente flexible y dise√±ado por usted.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>VI. Perspectiva de Calidad: El Dise√±o de la Interfaz</h3>
            <p>Como se destaca en el cuaderno de <strong>UX/UI</strong> aplicado al software, el programador de la clase debe considerar al "Programador Cliente" como su usuario. Una clase bien dise√±ada debe ser intuitiva. Seg√∫n <strong>O'Reilly</strong>, los nombres de las funciones miembro deben ser verbos claros (ej: <code>calcularSueldo</code> en lugar de <code>proc1</code>). </p>
            
            <p>Usted debe aspirar a lo que acad√©micamente llamamos <strong>Cohesi√≥n</strong>: una clase solo debe encargarse de una √∫nica entidad l√≥gica. Si usted crea una clase <code>Automovil</code> y le agrega funciones para <code>cocinarPizza</code>, est√° rompiendo el principio de dise√±o de ingenier√≠a. Seg√∫n el PDF de <strong>Deitel</strong>, las clases peque√±as y enfocadas son la clave para la reutilizaci√≥n de software.</p>

            <div class="practice-box">
                <span class="icon-sec">üë®‚Äçüíª</span>
                <strong>Laboratorio de Aplicaci√≥n N¬∞ 11:</strong>
                <p>Usted debe dise√±ar una clase llamada <code>Libro</code> para el sistema de la Biblioteca Universitaria. </p>
                <ol>
                    <li>Defina tres atributos <strong>privados</strong> esenciales (ej: t√≠tulo, autor, ISBN).</li>
                    <li>Defina una funci√≥n <strong>p√∫blica</strong> llamada <code>mostrarDetalles</code> que imprima la informaci√≥n del libro en un formato elegante.</li>
                    <li>Escriba el bloque <code>class</code> completo, asegur√°ndose de incluir el punto y coma final y los especificadores de acceso correctos.</li>
                </ol>
                <p><em>Autoevaluaci√≥n:</em> Si intenta acceder al atributo <code>titulo</code> directamente desde la funci√≥n <code>main</code>, ¬øqu√© mensaje deber√≠a arrojar el compilador seg√∫n lo visto en esta secci√≥n?</p>
            </div>

            <p>En conclusi√≥n, crear una clase es el acto supremo de dise√±o en C++. Usted deja de ser un consumidor de tipos de datos para convertirse en un creador de arquitecturas de informaci√≥n. En la pr√≥xima secci√≥n, exploraremos c√≥mo estos planos maestros cobran vida mediante la <strong>Creaci√≥n, uso y destrucci√≥n de objetos</strong>.</p>

            <button class="btn-ref" onclick="openRef('ref-deitel')">Referencia: Deitel Cap. 3.2 / O'Reilly Cap. 13</button>
        </section>

<!-- 2.12 Ciclo de Vida del Objeto: Instanciaci√≥n, Persistencia y Finalizaci√≥n -->
        <section id="sec-2-12">
            <span class="icon-sec">‚ôªÔ∏è</span>
            <h2>2.12 Entender c√≥mo se crean, utilizan y destruyen los objetos de una clase</h2>
            
            <p>En el paradigma de objetos, usted debe visualizar a las instancias no como meras variables pasivas, sino como entidades din√°micas que poseen un <strong>ciclo de vida</strong> perfectamente definido por el lenguaje. Como se detalla en el PDF de <strong>Deitel</strong>, este ciclo comprende tres etapas fundamentales: el nacimiento (instanciaci√≥n mediante constructores), la vida √∫til (interacci√≥n a trav√©s de mensajes) y el fallecimiento (liberaci√≥n de recursos mediante destructores). Para un ingeniero, comprender este proceso es vital para evitar fugas de memoria y asegurar la integridad del estado del sistema.</p>

            <h3>I. La G√©nesis: El Rol del Constructor</h3>
            <p>De acuerdo con <strong>O'Reilly</strong> en <em>Practical C++ Programming</em>, un objeto no puede existir en un estado inconsistente o con "valores basura". Por ello, C++ introduce el concepto de <strong>Constructor</strong>. Un constructor es una funci√≥n miembro especial que se invoca autom√°ticamente en el preciso instante en que se crea un objeto. </p>
            
            <p>Sus caracter√≠sticas acad√©micas son √∫nicas:</p>
            <ul>
                <li><strong>Nombre id√©ntico:</strong> Debe llamarse exactamente igual que la clase.</li>
                <li><strong>Sin tipo de retorno:</strong> No devuelve ning√∫n valor, ni siquiera <code>void</code>.</li>
                <li><strong>Prop√≥sito √∫nico:</strong> Su funci√≥n es inicializar los datos miembros de la clase y establecer las condiciones iniciales de operaci√≥n.</li>
            </ul>

            <p>Analiz√° el siguiente ejemplo de implementaci√≥n t√©cnica:</p>
            <pre><code>class Cuenta {
public:
   // Constructor con par√°metros
   Cuenta( double saldoInicial ) {
      if ( saldoInicial > 0.0 ) {
         saldo = saldoInicial;
      } else {
         saldo = 0.0;
         // En el √°mbito universitario, validar el estado inicial es obligatorio.
      }
   }

private:
   double saldo;
};</code></pre>

            <p>Seg√∫n <strong>Deitel</strong>, si usted no define un constructor, el compilador proveer√° un <span class="abbr" data-title="Constructor Predeterminado: Un constructor que no recibe argumentos y que el compilador genera autom√°ticamente si el programador no define ninguno.">constructor predeterminado</span>. Sin embargo, una vez que usted define cualquier constructor propio, el predeterminado desaparece, oblig√°ndolo a ser expl√≠cito en la creaci√≥n de sus objetos.</p>

            <h3>II. La Lista de Inicializaci√≥n de Miembros</h3>
            <p>Un detalle avanzado analizado en el PDF de <strong>Deitel</strong> es el uso de la <strong>lista de inicializaci√≥n de miembros</strong>. Esta t√©cnica es preferible sobre la asignaci√≥n dentro del cuerpo del constructor, ya que inicializa los datos miembros antes de que comience la ejecuci√≥n del c√≥digo del constructor, optimizando el rendimiento y permitiendo la inicializaci√≥n de miembros constantes (<code>const</code>).</p>
            <pre><code>// Forma optimizada de ingenier√≠a:
Cuenta( double saldoInicial ) : saldo( saldoInicial ) {
   // Cuerpo del constructor (puede estar vac√≠o)
}</code></pre>

            <h3>III. La Vida √ötil: Uso del Operador Punto</h3>
            <p>Una vez que el objeto ha sido instanciado, el programa interact√∫a con √©l mediante el env√≠o de mensajes. En C++, esto se materializa con el <strong>operador punto (<code>.</code>)</strong>. Seg√∫n el cuaderno de <strong>Desarrollo Web</strong>, este operador es la interfaz que conecta la l√≥gica global del programa con la encapsulaci√≥n interna del objeto.</p>
            <p>Usted debe recordar que solo podr√° invocar funciones que hayan sido declaradas como <code>public</code>. Intentar acceder a un miembro privado mediante el operador punto resultar√° en un error de compilaci√≥n inmediato, protegiendo as√≠ la <span class="abbr" data-title="Integridad del Objeto: El principio de que un objeto siempre debe mantener un estado v√°lido de acuerdo a sus reglas de negocio internas.">integridad del objeto</span>.</p>

            <h3>IV. El Final del Camino: El Destructor</h3>
            <p>Como se√±ala <strong>O'Reilly</strong>, "un buen programador limpia lo que ensucia". El <strong>Destructor</strong> es el encargado de realizar las tareas de limpieza final cuando un objeto deja de existir (por ejemplo, al salir del bloque de una funci√≥n). El destructor se identifica por llevar el car√°cter tilde (<code>~</code>) antes del nombre de la clase.</p>
            
            <div class="table-res">
                <table>
                    <thead>
                        <tr>
                            <th>Caracter√≠stica</th>
                            <th>Constructor</th>
                            <th>Destructor</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Sintaxis</strong></td>
                            <td><code>NombreClase()</code></td>
                            <td><code>~NombreClase()</code></td>
                        </tr>
                        <tr>
                            <td><strong>Par√°metros</strong></td>
                            <td>Puede estar sobrecargado con m√∫ltiples par√°metros.</td>
                            <td>Nunca recibe par√°metros ni devuelve valores.</td>
                        </tr>
                        <tr>
                            <td><strong>Llamada</strong></td>
                            <td>Autom√°tica al declarar el objeto o usar <code>new</code>.</td>
                            <td>Autom√°tica al salir del √°mbito o usar <code>delete</code>.</td>
                        </tr>
                        <tr>
                            <td><strong>Cantidad</strong></td>
                            <td>M√∫ltiples versiones posibles (sobrecarga).</td>
                            <td>Solo puede existir uno por clase.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>V. El Orden de Ejecuci√≥n y el √Åmbito (Scope)</h3>
            <p>De acuerdo con el PDF de <strong>Deitel</strong>, el orden en que se crean y destruyen los objetos depende de su <strong>√°mbito de almacenamiento</strong>:</p>
            <ol>
                <li><strong>Objetos Globales:</strong> Se crean antes de que <code>main</code> comience y se destruyen cuando el programa finaliza.</li>
                <li><strong>Objetos Locales (Autom√°ticos):</strong> Se crean cuando el flujo de ejecuci√≥n llega a su declaraci√≥n y se destruyen en el orden inverso a su creaci√≥n al cerrar la llave <code>}</code> del bloque.</li>
                <li><strong>Objetos Est√°ticos Locales:</strong> Se crean una sola vez y persisten hasta el fin del programa.</li>
            </ol>

            <h3>VI. Diagrama del Ciclo de Vida</h3>
            <p>Visualice la trayectoria de un objeto en la memoria del sistema seg√∫n lo analizado en los textos de referencia:</p>
            
            <div class="diagram-box">
                <div class="diagram-node" style="background: rgba(46, 125, 50, 0.1);"><strong>Nacimiento</strong><br><small>Reserva memoria + <br>Llamada al Constructor</small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node"><strong>Uso Activo</strong><br><small>Llamadas a m√©todos <br>mediante operador <code>.</code></small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node" style="background: rgba(211, 47, 47, 0.1);"><strong>Muerte</strong><br><small>Llamada al Destructor + <br>Liberaci√≥n de RAM</small></div>
            </div>

            <h3>VII. Perspectiva Acad√©mica: La Importancia de los Destrutores en Ingenier√≠a</h3>
            <p>Usted se preguntar√°: ¬øpor qu√© necesito un destructor si la memoria se libera sola al cerrar el programa? Seg√∫n <strong>O'Reilly</strong>, en aplicaciones de larga duraci√≥n (como un servidor web o un sistema operativo), los objetos se crean y destruyen miles de veces por segundo. Si el destructor no libera recursos externos (como archivos abiertos, conexiones a bases de datos o memoria din√°mica), el sistema sufrir√° una <span class="abbr" data-title="Memory Leak (Fuga de memoria): Error de software que ocurre cuando un programa no libera la memoria que ya no necesita, lo que puede causar que el sistema se ralentice o se bloquee.">fuga de memoria</span> catastr√≥fica.</p>

            <div class="practice-box">
                <span class="icon-sec">üß™</span>
                <strong>Laboratorio de Aplicaci√≥n N¬∞ 12:</strong>
                <p>Desarroll√° una clase llamada <code>Traza</code>. El constructor debe imprimir el mensaje "Objeto Nacido" y el destructor debe imprimir "Objeto Muerto". </p>
                <ol>
                    <li>Instanci√° tres objetos de la clase <code>Traza</code> dentro de <code>main</code>.</li>
                    <li>Cre√° un bloque de c√≥digo adicional <code>{ ... }</code> dentro de <code>main</code> e instanci√° un cuarto objeto all√≠.</li>
                    <li>Analiz√° la salida de la consola. ¬øEn qu√© orden mueren los objetos? ¬øCu√°ndo muere exactamente el cuarto objeto en relaci√≥n con los dem√°s?</li>
                </ol>
                <p><em>Desaf√≠o de Ingenier√≠a:</em> Basado en lo visto en <strong>Deitel</strong>, intent√° predecir el orden de destrucci√≥n si los objetos se crean en el orden A, B, C.</p>
            </div>

            <p>En conclusi√≥n, dominar el ciclo de vida de los objetos permite que usted escriba c√≥digo predecible y eficiente. La gesti√≥n autom√°tica de la construcci√≥n y destrucci√≥n es una de las caracter√≠sticas m√°s potentes de C++, sentando las bases para lo que en C++ moderno llamamos <strong>RAII</strong> (Resource Acquisition Is Initialization). En la siguiente secci√≥n, profundizaremos en c√≥mo <strong>Controlar el acceso</strong> para que esta vida √∫til transcurra bajo reglas de seguridad estrictas.</p>

            <button class="btn-ref" onclick="openRef('ref-deitel')">Referencia: Deitel Cap. 9.3 y 9.4 / O'Reilly Cap. 13</button>
        </section>

        <section id="sec-2-13">
            <span class="icon-sec">üîë</span>
            <h2>2.13 Controlar el acceso a los datos miembros y a las funciones miembros de los objetos</h2>
            
            <p>En la ingenier√≠a de software de alto nivel, el control de acceso no debe interpretarse como una simple restricci√≥n gramatical, sino como la base fundamental del <strong>Ocultamiento de Informaci√≥n</strong> (<em>Information Hiding</em>). Como bien se√±ala el PDF de <strong>Deitel</strong>, usted debe dise√±ar sus clases siguiendo el <strong>Principio del Menor Privilegio</strong>: cada componente de su c√≥digo debe tener permiso √∫nicamente para lo que es estrictamente indispensable para su funcionamiento. Esta disciplina previene que errores accidentales en una parte del programa se propaguen y corrompan la integridad de los datos en otras √°reas, un concepto vital para el mantenimiento de sistemas complejos.</p>

            <h3>I. Los Especificadores de Acceso: Guardianes de la Encapsulaci√≥n</h3>
            <p>De acuerdo con el enfoque pr√°ctico de <strong>O'Reilly</strong> en <em>Practical C++ Programming</em>, C++ nos provee tres etiquetas fundamentales para definir el "alcance de visibilidad" de los miembros de una clase. Usted debe visualizar estas etiquetas como niveles de seguridad dentro de un edificio gubernamental:</p>
            
            <ul>
                <li><strong><code>public:</code> (√Årea de Atenci√≥n al Cliente):</strong> Los miembros declarados aqu√≠ son accesibles por cualquier funci√≥n del programa, incluso aquellas que no pertenecen a la clase (como <code>main</code>). Representa la <strong>Interfaz P√∫blica</strong> del objeto: el conjunto de servicios que el objeto promete brindar al mundo exterior. Seg√∫n <strong>Deitel</strong>, es aqu√≠ donde solemos ubicar los m√©todos de acci√≥n.</li>
                <li><strong><code>private:</code> (C√°mara Acorazada):</strong> Es el nivel de acceso por defecto en una <code>class</code>. Solo las funciones miembro de la propia clase pueden "ver" o manipular estos elementos. Aqu√≠ es donde usted debe alojar la mayor√≠a de sus <strong>datos miembros</strong> (atributos). Seg√∫n los principios de la POO, exponer datos directamente es una mala pr√°ctica acad√©mica que atenta contra la robustez del software.</li>
                <li><strong><code>protected:</code> (Zona de Personal Autorizado):</strong> Es un nivel intermedio relacionado con la herencia. Los miembros protegidos act√∫an como privados para el mundo exterior, pero son accesibles para las clases derivadas (hijas). Este concepto se explora en profundidad al avanzar hacia el polimorfismo.</li>
            </ul>

            <h3>II. La Filosof√≠a de los "Getters" y "Setters"</h3>
            <p>Usted podr√≠a preguntarse: "¬øPor qu√© ocultar los datos si de todas formas necesito leerlos o cambiarlos?". La respuesta de <strong>Deitel</strong> es contundente: por el <strong>Control de Validaci√≥n</strong>. Si usted permite el acceso directo (p√∫blico), no tiene forma de impedir que un usuario asigne un valor err√≥neo (como un saldo negativo o una edad de 500 a√±os).</p>
            
            <p>Al utilizar funciones de acceso p√∫blicas para manipular datos privados, usted interpone una capa de inteligencia. Por ejemplo, en un m√©todo <code>establecerNota(int n)</code>, usted puede incluir un <code>if</code> que verifique si la nota est√° entre 1 y 10 antes de modificar la memoria f√≠sica. Seg√∫n el PDF de <strong>O'Reilly</strong>, esto reduce dr√°sticamente el tiempo de depuraci√≥n, ya que si un dato es incorrecto, usted sabe exactamente qu√© funci√≥n fue la encargada de validarlo.</p>

            <div class="table-res">
                <table>
                    <thead>
                        <tr>
                            <th>Concepto</th>
                            <th>Acceso P√∫blico (Poco Seguro)</th>
                            <th>Acceso Privado + M√©todos (Acad√©mico)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Integridad</strong></td>
                            <td>Vulnerable: cualquiera puede sobreescribir el dato.</td>
                            <td>Protegida: el objeto decide si el cambio es v√°lido.</td>
                        </tr>
                        <tr>
                            <td><strong>Mantenibilidad</strong></td>
                            <td>Dificultosa: cambiar un nombre de variable rompe todo el sistema.</td>
                            <td>Simple: se cambia el dato interno pero la interfaz sigue igual.</td>
                        </tr>
                        <tr>
                            <td><strong>Depuraci√≥n</strong></td>
                            <td>Compleja: el error puede venir de cualquier l√≠nea del c√≥digo.</td>
                            <td>Localizada: el error solo puede estar en los m√©todos de la clase.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>III. Funciones de Utiler√≠a y el Ocultamiento de la Complejidad</h3>
            <p>No solo los datos deben ser privados. De acuerdo con el cuaderno de <strong>UX/UI</strong> aplicado al desarrollo, un objeto debe presentar una interfaz limpia y simple. Si su clase necesita realizar un c√°lculo matem√°tico complejo de 50 l√≠neas para mostrar un resultado, usted no debe exponer ese proceso al usuario. </p>
            
            <p>Usted debe crear <strong>Funciones de Utiler√≠a</strong> (<em>Helper Functions</em>) declaradas como <code>private</code>. Estas funciones asisten a los m√©todos p√∫blicos pero permanecen ocultas para el programador cliente. Esto reduce la <span class="abbr" data-title="Carga Cognitiva: La cantidad total de esfuerzo mental que se utiliza en la memoria de trabajo. En programaci√≥n, reducirla permite que el desarrollador se enfoque solo en lo esencial.">carga cognitiva</span> y previene que alguien invoque procesos internos en un orden incorrecto, lo que seg√∫n <strong>Deitel</strong> es una fuente com√∫n de fallas sist√©micas.</p>

            <h3>IV. Diagrama de Blindaje de Memoria</h3>
            <p>El siguiente diagrama conceptual muestra c√≥mo el control de acceso act√∫a como un escudo sobre la RAM:</p>
            
            <div class="diagram-box">
                <div class="diagram-node" style="border-style: dotted;"><strong>Programador Cliente</strong><br><small>Intenta acceder a <code>_precio</code></small></div>
                <div class="diagram-arrow">‚ûî [BLOQUEADO] ‚ûî</div>
                <div class="diagram-node" style="background: rgba(211, 47, 47, 0.2); border-color: #d32f2f;"><strong>Zona Privada</strong><br><small>Dato: _precio</small></div>
            </div>
            <div class="diagram-box">
                <div class="diagram-node"><strong>Programador Cliente</strong><br><small>Invoca <code>getPrecio()</code></small></div>
                <div class="diagram-arrow">‚ûî [AUTORIZADO] ‚ûî</div>
                <div class="diagram-node" style="background: rgba(46, 125, 50, 0.2); border-color: var(--success);"><strong>Interfaz P√∫blica</strong><br><small>M√©todo de Acceso</small></div>
            </div>

            <h3>V. Diferencia t√©cnica: <code>class</code> vs <code>struct</code></h3>
            <p>Es fundamental que usted comprenda que, t√©cnicamente, la √∫nica diferencia entre estas dos palabras clave en C++ es su <strong>nivel de acceso predeterminado</strong>. Seg√∫n <strong>O'Reilly</strong>, en un <code>struct</code> todo es p√∫blico a menos que se indique lo contrario (herencia del lenguaje C), mientras que en un <code>class</code> todo es privado por defecto. En esta c√°tedra, usted utilizar√° <code>class</code> para cualquier entidad que requiera l√≥gica y protecci√≥n de datos, reservando <code>struct</code> √∫nicamente para paquetes de datos simples sin comportamiento asociado.</p>

            <h3>VI. Perspectiva de Desarrollo Web e Ingenier√≠a</h3>
            <p>Como se destaca en el cuaderno de <strong>Desarrollo Web</strong>, el control de acceso fomenta el <strong>Desacoplamiento</strong>. Si la implementaci√≥n interna de una clase (sus miembros privados) est√° aislada de la interfaz, usted puede reescribir todo el motor interno de c√°lculo sin que las aplicaciones web o de escritorio que consumen su clase tengan que cambiar una sola l√≠nea de c√≥digo. Esta es la clave para el software evolutivo analizado en los textos de referencia.</p>

            <div class="practice-box">
                <span class="icon-sec">üß™</span>
                <strong>Laboratorio de Aplicaci√≥n N¬∞ 13:</strong>
                <p>Imagine una clase <code>SensorPresion</code>. Usted debe asegurar que el valor de presi√≥n nunca sea menor a 0 ni mayor a 1000 hectopascales.</p>
                <ol>
                    <li>Declare el atributo <code>presionActual</code> como privado.</li>
                    <li>Implemente un m√©todo p√∫blico <code>actualizarPresion(double valor)</code>.</li>
                    <li>Dentro del m√©todo, utilice una estructura <code>if</code> para validar el rango. Si el valor es incorrecto, el programa debe imprimir un mensaje de error y mantener el √∫ltimo valor v√°lido.</li>
                </ol>
                <p><strong>Reflexi√≥n Acad√©mica:</strong> ¬øPor qu√© este dise√±o es superior a simplemente confiar en que el usuario del sensor siempre ingresar√° valores correctos? Considere el concepto de "Programaci√≥n Defensiva" mencionado en <strong>Deitel</strong>.</p>
            </div>

            <p>En conclusi√≥n, el control de acceso es el mecanismo que le otorga al programador el poder de definir fronteras claras de responsabilidad. Dominar <code>public</code> y <code>private</code> es lo que separa a un aficionado de un ingeniero de software profesional. En la siguiente secci√≥n, aprenderemos a <strong>Valorar la orientaci√≥n a objetos</strong>, integrando todos estos pilares de dise√±o en una visi√≥n sist√©mica global.</p>

            <button class="btn-ref" onclick="openRef('ref-deitel')">Referencia: Deitel Cap. 9.2 y 9.5 / O'Reilly Cap. 13</button>
        </section>

<section id="sec-2-14">
            <span class="icon-sec">‚≠ê</span>
            <h2>2.14 Comenzar a valorar la orientaci√≥n a objetos: Un cambio de paradigma en la ingenier√≠a</h2>
            
            <p>Habiendo recorrido la sintaxis de las clases y la mec√°nica del control de acceso, usted se encuentra ahora frente al umbral m√°s importante de su formaci√≥n: comprender por qu√© la <strong>Programaci√≥n Orientada a Objetos (POO)</strong> ha desplazado casi por completo a los modelos procedimentales en la industria del software. Como bien afirma el PDF de <strong>Deitel</strong>, la POO no es simplemente una "forma de escribir c√≥digo", sino una metodolog√≠a de dise√±o que permite modelar sistemas complejos de manera que resulten m√°s naturales, comprensibles y, sobre todo, mantenibles a lo largo del tiempo.</p>

            <h3>I. La Reducci√≥n de la Brecha Sem√°ntica</h3>
            <p>En el paradigma procedimental (como el lenguaje C puro), existe una desconexi√≥n entre el problema del mundo real y el c√≥digo. Usted debe traducir "clientes", "cuentas" y "transacciones" en una serie de funciones sueltas y estructuras de datos desprotegidas. Seg√∫n <strong>Deitel</strong>, la POO permite reducir esta <strong>brecha sem√°ntica</strong> al permitir que los componentes del software reflejen directamente a las entidades del mundo real.</p>
            
            <p>Usted deja de pensar en "c√≥mo procesar un dato" para empezar a pensar en "qu√© responsabilidades tiene este objeto". Esta transici√≥n mental es lo que permite que un ingeniero de software y un analista de negocios hablen el mismo lenguaje. Si el negocio requiere una "Cuenta de Ahorros", usted crea la clase <code>CuentaAhorros</code>. Los objetos, por lo tanto, se convierten en ciudadanos de primera clase en su arquitectura.</p>

            <h3>II. El Valor de la Reutilizaci√≥n: Bibliotecas y Frameworks</h3>
            <p>De acuerdo con el enfoque pr√°ctico de <strong>O'Reilly</strong> en <em>Practical C++ Programming</em>, la verdadera potencia de la POO reside en que usted no tiene que "reinventar la rueda" en cada proyecto. Una vez que una clase ha sido dise√±ada, probada y depurada, puede ser empaquetada en una biblioteca y distribuida a otros programadores.</p>
            
            <p>C++ materializa este valor mediante la <span class="abbr" data-title="STL: Standard Template Library. Un conjunto de clases gen√©ricas y algoritmos que permiten manejar colecciones de datos, cadenas de texto y flujos de entrada/salida de forma estandarizada y altamente eficiente.">STL</span>. Usted ya ha utilizado objetos como <code>std::cout</code> o <code>std::string</code> sin necesidad de conocer los miles de l√≠neas de c√≥digo que gestionan el hardware de pantalla o la memoria din√°mica de los caracteres. Seg√∫n <strong>Deitel</strong>, esta capacidad de "construir sobre hombros de gigantes" es lo que permite que el desarrollo de software moderno sea acelerado y fiable.</p>

            <h3>III. Los Tres Pilares de la Robustez</h3>
            <p>Para que usted pueda valorar realmente este paradigma, debe considerar c√≥mo estos tres pilares analizados en los textos de referencia transforman el ciclo de vida del software:</p>
            <ol>
                <li><strong>Encapsulamiento:</strong> Protege los datos de interferencias externas, garantizando que el objeto sea el √∫nico responsable de su estado.</li>
                <li><strong>Herencia:</strong> Permite crear nuevas clases basadas en clases existentes, heredando sus caracter√≠sticas y a√±adiendo capacidades √∫nicas. Esto evita la duplicaci√≥n de c√≥digo, el enemigo n√∫mero uno de la eficiencia.</li>
                <li><strong>Polimorfismo:</strong> Permite tratar a objetos de diferentes tipos de manera uniforme (por ejemplo, pedirle a un "C√≠rculo" y a un "Tri√°ngulo" que se "dibujen" sin saber qu√© forma tienen exactamente).</li>
            </ol>

            <div class="table-res">
                <table>
                    <thead>
                        <tr>
                            <th>Atributo de Calidad</th>
                            <th>Impacto en el Desarrollo (Visi√≥n O'Reilly)</th>
                            <th>Impacto en el Negocio (Visi√≥n Deitel)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Mantenibilidad</strong></td>
                            <td>Los errores se localizan f√°cilmente dentro de clases espec√≠ficas.</td>
                            <td>Menor costo operativo en el largo plazo.</td>
                        </tr>
                        <tr>
                            <td><strong>Escalabilidad</strong></td>
                            <td>Es simple a√±adir nuevos objetos sin romper la l√≥gica global.</td>
                            <td>Capacidad de responder r√°pido a cambios del mercado.</td>
                        </tr>
                        <tr>
                            <td><strong>Fiabilidad</strong></td>
                            <td>El uso de tipos definidos reduce errores de l√≥gica en tiempo de ejecuci√≥n.</td>
                            <td>Software con menos fallos cr√≠ticos para el usuario final.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>IV. El Concepto de "C√≥digo Limpio" y UX/UI en el Desarrollo</h3>
            <p>Seg√∫n el cuaderno de <strong>UX/UI</strong> aplicado al c√≥digo, un programador debe escribir para otros programadores. La POO fomenta lo que acad√©micamente llamamos <strong>Cohesi√≥n Alta</strong> y <strong>Acoplamiento Bajo</strong>. </p>
            <ul>
                <li><strong>Cohesi√≥n Alta:</strong> Cada clase hace una sola cosa y la hace bien.</li>
                <li><strong>Acoplamiento Bajo:</strong> Las clases dependen m√≠nimamente entre s√≠, comunic√°ndose solo a trav√©s de interfaces p√∫blicas bien definidas.</li>
            </ul>
            <p>Como indica el cuaderno de <strong>Desarrollo Web</strong>, estas propiedades son las que permiten que sistemas masivos (como motores de b√∫squeda o redes sociales) puedan ser modificados por miles de desarrolladores simult√°neamente sin colapsar el sistema completo.</p>

            <h3>V. Diagrama de la Jerarqu√≠a de Valor</h3>
            <p>El siguiente esquema ilustra c√≥mo los conceptos t√©cnicos que hemos estudiado se traducen en valor para la ingenier√≠a de software:</p>

            <div class="diagram-box">
                <div class="diagram-node"><strong>Conceptos Base</strong><br><small>Clases, Objetos, Miembros</small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node" style="background: var(--bg-secondary);"><strong>Propiedades</strong><br><small>Encapsulamiento, Abstracci√≥n</small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node" style="border-color: var(--success); color: var(--success); font-weight: bold;"><strong>Valor Final</strong><br>Reutilizaci√≥n y Calidad</div>
            </div>

            <h3>VI. Perspectiva de Metodolog√≠as Activas: Aprender a Pensar en Objetos</h3>
            <p>Como se destaca en el cuaderno de <strong>Metodolog√≠as Activas</strong>, la valoraci√≥n de la POO no surge de la memorizaci√≥n, sino del enfrentamiento con problemas reales. Usted debe notar que en proyectos grandes, el 80% del tiempo se dedica al mantenimiento y no a la creaci√≥n. Un c√≥digo procedimental "f√°cil de escribir" suele ser un c√≥digo "imposible de mantener" dos a√±os despu√©s. </p>
            
            <p>La POO le exige un mayor esfuerzo inicial de dise√±o (pensar en clases, accesos y relaciones), pero seg√∫n <strong>Deitel</strong>, este esfuerzo se recupera con creces cuando el sistema necesita evolucionar. Usted est√° invirtiendo en la <strong>sustentabilidad</strong> de su propia obra t√©cnica.</p>

            <div class="practice-box">
                <span class="icon-sec">üß†</span>
                <strong>Laboratorio de Reflexi√≥n de Ingenier√≠a:</strong>
                <p>Usted ha sido designado l√≠der de un proyecto para una plataforma de streaming. El sistema debe manejar "Usuarios", "Pel√≠culas" y "Planes de Suscripci√≥n". </p>
                <ol>
                    <li>¬øC√≥mo ayudar√≠a el <strong>Encapsulamiento</strong> a proteger los datos de pago de los usuarios?</li>
                    <li>Si el mes que viene el banco cambia sus protocolos de cobro, ¬øpor qu√© es ventajoso haber dise√±ado una clase <code>PasarelaPago</code> independiente en lugar de tener el c√≥digo de cobro disperso por todo el programa?</li>
                    <li>¬øQu√© <strong>ventaja sem√°ntica</strong> ve usted en que un objeto <code>Pelicula</code> tenga un m√©todo <code>reproducir()</code> en lugar de tener una funci√≥n global llamada <code>func_play_media(datos_peli)</code>?</li>
                </ol>
                <p><em>Sugerencia Acad√©mica:</em> Revise la secci√≥n 2.14 de <strong>Deitel</strong> sobre la interacci√≥n de objetos para fundamentar su respuesta.</p>
            </div>

            <p>En conclusi√≥n, valorar la orientaci√≥n a objetos es reconocer que el software es una estructura arquitect√≥nica que debe resistir el paso del tiempo. Usted ha dejado de ser un simple escritor de algoritmos para convertirse en un arquitecto de sistemas. En la pr√≥xima secci√≥n, realizaremos el <strong>Repaso final</strong> de esta unidad para consolidar estos cimientos antes de avanzar hacia estructuras de control m√°s complejas.</p>

            <button class="btn-ref" onclick="openRef('ref-deitel')">Referencia: Deitel Cap. 1.15 y 2.14 / O'Reilly Cap. 1</button>
        </section>

       <section id="sec-2-15">
            <span class="icon-sec">üèÅ</span>
            <h2>2.15 Repaso General: Consolidaci√≥n de los Pilares del Paradigma de Objetos</h2>
            
            <p>Usted ha concluido un recorrido t√©cnico de importancia fundamental en su formaci√≥n como ingeniero o licenciado. Esta secci√≥n de repaso no es una mera lista de definiciones, sino una s√≠ntesis arquitect√≥nica dise√±ada para que usted pueda verificar si ha internalizado la l√≥gica subyacente de C++. Seg√∫n el PDF de <strong>Deitel</strong>, dominar la Unidad 02 es el requisito <em>sine qua non</em> para abordar estructuras de datos avanzadas y algoritmos complejos. Como indica el cuaderno de <strong>Metodolog√≠as Activas</strong>, el aprendizaje real ocurre cuando usted es capaz de conectar la sintaxis (el "c√≥mo") con la ingenier√≠a (el "por qu√©").</p>

            <h3>I. El N√∫cleo Procedimental y el Flujo de Datos</h3>
            <p>Iniciamos analizando la estructura m√≠nima de un programa ejecutable. Usted debe recordar que la funci√≥n <code>main</code> es el punto de entrada obligatorio y que el uso de bibliotecas como <code>&lt;iostream&gt;</code> es lo que permite la comunicaci√≥n con el usuario. De acuerdo con el enfoque de <strong>O'Reilly</strong> en <em>Practical C++ Programming</em>, la interacci√≥n mediante <code>std::cout</code> (inserci√≥n) y <code>std::cin</code> (extracci√≥n) es una de las primeras manifestaciones de la potencia de los objetos en C++, trat√°ndolos como flujos continuos de informaci√≥n.</p>
            
            <p>Usted ha aprendido a manipular el formato de salida mediante <span class="abbr" data-title="Escape Sequences: Secuencias de caracteres que no se imprimen literalmente sino que ejecutan comandos de control de cursor o sonido (ej: \n, \t).">secuencias de escape</span>, entendiendo que la legibilidad de la interfaz de consola es, seg√∫n el cuaderno de <strong>UX/UI</strong>, el primer paso para una buena experiencia de usuario. La aritm√©tica, por su parte, le ha exigido una precisi√≥n absoluta en el uso de operadores y en la comprensi√≥n de la <strong>Precedencia</strong>, donde un par√©ntesis mal colocado puede alterar el resultado de un c√°lculo financiero o cient√≠fico.</p>

            <h3>II. La Memoria como Recurso F√≠sico</h3>
            <p>Uno de los saltos conceptuales m√°s importantes de esta unidad fue la visualizaci√≥n de la memoria. Basado en el PDF de <strong>Deitel</strong>, usted ahora entiende que una variable no es un nombre et√©reo, sino una ubicaci√≥n f√≠sica en la <span class="abbr" data-title="RAM: Random Access Memory. Espacio f√≠sico donde residen los datos mientras el programa est√° en ejecuci√≥n.">RAM</span>. Hemos analizado la diferencia cr√≠tica entre:</p>
            <ul>
                <li><strong>Lectura No Destructiva:</strong> Utilizar un valor para un c√°lculo sin alterar la celda original.</li>
                <li><strong>Escritura Destructiva:</strong> Asignar un nuevo valor (mediante <code>=</code> o <code>cin</code>), eliminando permanentemente el dato anterior.</li>
            </ul>
            <p>Record√° siempre la advertencia de <strong>O'Reilly</strong>: C++ no limpia la memoria por usted al declarar una variable. El peligro de los "valores basura" es una realidad t√©cnica que usted debe mitigar mediante la inicializaci√≥n expl√≠cita en cada constructor.</p>

            <h3>III. La Transici√≥n hacia el Paradigma de Objetos</h3>
            <p>Usted ha dejado atr√°s la visi√≥n de que un programa es solo una "receta de pasos" para entrar en el mundo de la <span class="abbr" data-title="POO: Programaci√≥n Orientada a Objetos. Paradigma basado en la creaci√≥n de tipos de datos que combinan atributos y comportamientos.">POO</span>. Seg√∫n <strong>Deitel</strong>, este cambio de mentalidad se fundamenta en tres pilares que hemos explorado:</p>
            <ol>
                <li><strong>Abstracci√≥n:</strong> Crear Tipos de Datos Abstractos (TDA) que modelan la esencia de un problema, ignorando lo irrelevante.</li>
                <li><strong>Encapsulamiento:</strong> Agrupar datos y funciones en una unidad l√≥gica llamada <code>class</code>.</li>
                <li><strong>Ocultamiento de Datos:</strong> Proteger el estado interno mediante el especificador <code>private</code>, exponiendo solo una interfaz <code>public</code> controlada.</li>
            </ol>

            <h3>IV. Tabla de Referencia R√°pida: Conceptos Fundamentales</h3>
            <div class="table-res">
                <table>
                    <thead>
                        <tr>
                            <th>Concepto T√©cnico</th>
                            <th>Regla de Oro Acad√©mica</th>
                            <th>Error Com√∫n de Ingenier√≠a (seg√∫n O'Reilly)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Declaraci√≥n de Clase</strong></td>
                            <td>Finaliza siempre con punto y coma (<code>};</code>).</td>
                            <td>Olvidar el <code>;</code> final, provocando errores cr√≠pticos.</td>
                        </tr>
                        <tr>
                            <td><strong>Control de Acceso</strong></td>
                            <td>Atributos siempre <code>private</code>, m√©todos <code>public</code>.</td>
                            <td>Exponer datos directamente, rompiendo la integridad.</td>
                        </tr>
                        <tr>
                            <td><strong>Constructor</strong></td>
                            <td>Inicializa el objeto; se llama autom√°ticamente.</td>
                            <td>Intentar asignarle un tipo de retorno (como <code>void</code>).</td>
                        </tr>
                        <tr>
                            <td><strong>Comparaci√≥n L√≥gica</strong></td>
                            <td>Usar <code>==</code> para igualdad.</td>
                            <td>Usar <code>=</code> (asignaci√≥n) dentro de un <code>if</code>.</td>
                        </tr>
                        <tr>
                            <td><strong>Divisi√≥n Entera</strong></td>
                            <td>El resultado siempre se trunca.</td>
                            <td>Esperar decimales en un c√°lculo entre dos <code>int</code>.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>V. Diagrama Sint√©tico: Del Dise√±o a la Instanciaci√≥n</h3>
            <p>El siguiente esquema resume el proceso de ingenier√≠a que hemos seguido en esta unidad:</p>

            <div class="diagram-box">
                <div class="diagram-node"><strong>1. An√°lisis</strong><br><small>Identificar Sustantivos y Verbos</small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node"><strong>2. Definici√≥n (Clase)</strong><br><small>Crear el Plano (Blueprint)</small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node"><strong>3. Implementaci√≥n</strong><br><small>Escribir M√©todos y Validaci√≥n</small></div>
                <div class="diagram-arrow">‚ûî</div>
                <div class="diagram-node" style="border-color: var(--success);"><strong>4. Ejecuci√≥n (Objetos)</strong><br><small>Ciclo de Vida en RAM</small></div>
            </div>

            <h3>VI. Perspectiva de Metodolog√≠as Activas y Calidad</h3>
            <p>Como se destaca en los cuadernos de <strong>Desarrollo Web</strong> y <strong>Metodolog√≠as Activas</strong>, la calidad del software no es un accidente, sino el resultado de seguir est√°ndares. Usted no programa para la m√°quina; programa para otros seres humanos. Por ello, el uso de nombres descriptivos, el respeto por la identaci√≥n y la documentaci√≥n constante mediante comentarios (<code>//</code>) son marcas de su profesionalismo t√©cnico.</p>

            <h3>VII. Laboratorio de Autoevaluaci√≥n Final</h3>
            <div class="practice-box">
                <span class="icon-sec">üìù</span>
                <strong>Examen de Consolidaci√≥n de la Unidad 02:</strong>
                <p>Responda internamente estas preguntas bas√°ndose en los textos de <strong>Deitel</strong> y <strong>O'Reilly</strong> antes de continuar con la siguiente unidad:</p>
                <ol>
                    <li>¬øCu√°l es la diferencia t√©cnica exacta entre el operador de inserci√≥n (<code><<</code>) y el de extracci√≥n (<code>>></code>)?</li>
                    <li>¬øPor qu√© decimos que la asignaci√≥n (<code>=</code>) tiene una asociatividad de derecha a izquierda?</li>
                    <li>¬øQu√© sucede f√≠sicamente en la memoria cuando un objeto local llega al final de su bloque (llave de cierre)?</li>
                    <li>¬øC√≥mo implementar√≠a un TDA para representar un "Reloj Digital" asegurando que los minutos nunca superen el valor 59?</li>
                    <li>¬øCu√°l es la diferencia sem√°ntica entre un <em>par√°metro</em> de una funci√≥n y un <em>dato miembro</em> de una clase?</li>
                </ol>
                <p><strong>Desaf√≠o Pr√°ctico:</strong> Escrib√≠ un c√≥digo en papel que defina una clase <code>Triangulo</code> con base y altura privadas, un constructor que las inicialice y una funci√≥n p√∫blica que devuelva el √°rea. No te olvides del punto y coma final.</p>
            </div>

            <p>En conclusi√≥n, usted ha establecido los cimientos de la arquitectura de software. Ha pasado de entender c√≥mo sumar n√∫meros a entender c√≥mo modelar la realidad mediante objetos protegidos y eficientes. Estos conceptos ser√°n la base sobre la cual construiremos las <strong>Estructuras de Control</strong> en la Unidad 03. Como afirma <strong>Deitel</strong>, la programaci√≥n es el arte de dominar la complejidad a trav√©s de la abstracci√≥n organizada.</p>

            <button class="btn-ref" onclick="window.scrollTo({top: 0, behavior: 'smooth'})">Finalizar Repaso y Volver al Inicio</button>
        </section>

        <footer style="text-align: center; padding: 4rem 0; border-top: 1px solid var(--border); color: var(--text-secondary);">
            <p>¬© 2024 - C√°tedra de Programaci√≥n - Universidad Argentina</p>
            <p><small>Fuentes: Deitel (6ta Ed.) | O'Reilly Practical C++. <br> 
            Principios de UX/UI y Metodolog√≠as Activas aplicados.</small></p>
        </footer>
    </main>
</div>

<!-- Control de Tema -->
<button class="theme-toggle" id="themeToggle" title="Alternar Modo Oscuro/Claro">üåì</button>

<!-- Modal de Referencias -->
<div id="refModal" class="modal">
    <div class="modal-content">
        <h3 id="refTitle">Referencia Bibliogr√°fica</h3>
        <p id="refBody"></p>
        <button class="btn-ref" onclick="closeRef()">Cerrar</button>
    </div>
</div>

<script>
    const biblio = {
        'ref-deitel': "Basado en 'C++ C√≥mo Programar' de Deitel & Deitel (Sexta Edici√≥n). Este texto es la fuente principal para la estructura de control y la introducci√≥n a clases.",
        'ref-oreilly': "Basado en 'Practical C++ Programming' de Steve Oualline (O'Reilly). Aporta la perspectiva pragm√°tica sobre el manejo de memoria y eficiencia de bajo nivel."
    };

    function openRef(id) {
        document.getElementById('refBody').innerText = biblio[id];
        document.getElementById('refModal').style.display = 'flex';
    }

    function closeRef() {
        document.getElementById('refModal').style.display = 'none';
    }

    const themeToggle = document.getElementById('themeToggle');
    const html = document.documentElement;
    const savedTheme = localStorage.getItem('user-theme') || 'light';
    html.setAttribute('data-theme', savedTheme);

    themeToggle.addEventListener('click', () => {
        const current = html.getAttribute('data-theme');
        const next = current === 'light' ? 'dark' : 'light';
        html.setAttribute('data-theme', next);
        localStorage.setItem('user-theme', next);
    });

    // --- L√≥gica del Men√∫ Lateral Optimizado ---
    const navLinks = document.querySelectorAll('.nav-links a');
    const sections = document.querySelectorAll('section');
    const sidebar = document.getElementById('sidebar');

    const observerOptions = {
        root: null,
        // Detectamos el cambio cuando la secci√≥n est√° en la parte superior (20% del viewport)
        rootMargin: '0px 0px -80% 0px',
        threshold: 0
    };

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const id = entry.target.getAttribute('id');
                
                // Actualizamos el resaltado
                navLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === `#${id}`) {
                        link.classList.add('active');
                        
                        // Aseguramos que el elemento activo sea visible en el scroll del men√∫
                        link.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                });
            }
        });
    }, observerOptions);

    sections.forEach(section => observer.observe(section));

    window.onclick = function(e) {
        if (e.target.className === 'modal') closeRef();
    }
</script>

</body>
</html>
