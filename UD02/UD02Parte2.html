<!DOCTYPE html>
<html lang="es-AR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Gu√≠a de estudio universitaria sobre clases y objetos en C++ basada en Deitel y O'Reilly.">
    <title>Unidad Did√°ctica 02 - Paradigma de Objetos - Parte 2</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;1,400&family=Roboto+Mono:wght@400;500&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-primary: #fdfdfd;
            --bg-secondary: #f4f4f4;
            --bg-paper: #ffffff;
            --text-primary: #1a1a1a;
            --text-secondary: #4a4a4a;
            --accent: #0056b3;
            --accent-hover: #003d80;
            --code-bg: #f8f9fa;
            --border: #dee2e6;
            --shadow: 0 4px 12px rgba(0,0,0,0.08);
            --timeline-line: #0056b3;
            --success: #28a745;
        }

        [data-theme="dark"] {
            --bg-primary: #0f111a;
            --bg-secondary: #1a1c2e;
            --bg-paper: #1e2132;
            --text-primary: #e6edf3;
            --text-secondary: #9198a1;
            --accent: #58a6ff;
            --accent-hover: #1f6feb;
            --code-bg: #0d1117;
            --border: #30363d;
            --shadow: 0 4px 12px rgba(0,0,0,0.4);
            --timeline-line: #58a6ff;
        }

        * {
            box-sizing: border-box;
            transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease;
        }

        body {
            font-family: 'Merriweather', serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.8;
            margin: 0;
        }

        h1, h2, h3, h4 {
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
        }

        h1 { font-size: 2.5rem; margin-bottom: 1rem; color: var(--accent); }
        h2 { font-size: 1.8rem; border-left: 5px solid var(--accent); padding-left: 1rem; margin-top: 3rem; }
        
        .home-link {
            text-decoration: none;
            color: inherit;
            cursor: pointer;
        }

        /* Layout */
        .app-wrapper {
            display: grid;
            grid-template-columns: 300px 1fr;
            min-height: 100vh;
        }

        aside {
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--border);
            padding: 2rem 1.5rem;
            height: 100vh;
            position: sticky;
            top: 0;
            overflow-y: auto;
        }

        .nav-links {
            list-style: none;
            padding: 0;
        }

        .nav-links li { margin-bottom: 0.8rem; }
        .nav-links a {
            text-decoration: none;
            color: var(--text-secondary);
            font-size: 0.95rem;
            font-family: 'Roboto', sans-serif;
            display: block;
            padding: 0.6rem;
            border-radius: 6px;
        }

        .nav-links a:hover, .nav-links a.active {
            background-color: var(--accent);
            color: white;
            transform: translateX(5px);
        }

        main {
            padding: 4rem 12%;
            max-width: 1400px;
        }

        /* Components */
        section {
            margin-bottom: 6rem;
            scroll-margin-top: 2rem;
            opacity: 0;
            transform: translateY(30px);
            animation: slideUp 0.8s forwards;
        }

        @keyframes slideUp {
            to { opacity: 1; transform: translateY(0); }
        }

        .code-block {
            background-color: var(--code-bg);
            padding: 1.5rem;
            border-radius: 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            border: 1px solid var(--border);
            margin: 1.5rem 0;
            position: relative;
            overflow-x: auto;
        }

        .abbr {
            border-bottom: 2px dotted var(--accent);
            cursor: help;
            color: var(--accent);
            font-weight: 600;
        }

        .abbr:hover::after {
            content: attr(data-title);
            position: absolute;
            background: #333;
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.85rem;
            z-index: 100;
            width: 250px;
            font-family: 'Roboto', sans-serif;
            margin-top: 25px;
        }

        .diagram {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 3rem 0;
            padding: 2rem;
            background: var(--bg-secondary);
            border-radius: 12px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .box {
            background: var(--bg-paper);
            border: 2px solid var(--accent);
            padding: 1.5rem;
            border-radius: 10px;
            text-align: center;
            min-width: 160px;
            box-shadow: var(--shadow);
            font-weight: bold;
        }

        .arrow { font-size: 2rem; color: var(--accent); }

        /* Tables */
        .table-responsive {
            overflow-x: auto;
            margin: 2rem 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'Roboto', sans-serif;
        }

        th, td {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            text-align: left;
        }

        th { background: var(--bg-secondary); color: var(--accent); }

        /* Timeline */
        .timeline {
            border-left: 4px solid var(--timeline-line);
            margin: 2rem 0;
            padding-left: 2rem;
        }

        .timeline-event {
            position: relative;
            margin-bottom: 2.5rem;
        }

        .timeline-event::before {
            content: '';
            position: absolute;
            left: -2.45rem;
            top: 0.5rem;
            width: 1rem;
            height: 1rem;
            background: var(--accent);
            border-radius: 50%;
            border: 4px solid var(--bg-primary);
        }

        .date { font-weight: bold; color: var(--accent); }

        /* Theme Toggle */
        .theme-btn {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--accent);
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ref-btn {
            background: none;
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 0.4rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            margin-top: 1rem;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--bg-paper);
            padding: 2.5rem;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            box-shadow: var(--shadow);
        }

        /* Mobile Adjustments */
        @media (max-width: 900px) {
            .app-wrapper { grid-template-columns: 1fr; }
            aside { display: none; }
            main { padding: 2rem 5%; }
        }

        .icon { font-size: 1.6rem; vertical-align: middle; margin-right: 10px; color: var(--accent); }
    </style>
</head>
<body>

<div class="app-wrapper">
    <aside>
        <h2 style="border:none; padding:0; margin-bottom: 1.5rem;">
            <a href="#" class="home-link">√çndice Acad√©mico</a>
        </h2>
        <ul class="nav-links">
            <li><a href="#sec3">3. Introducci√≥n a Clases</a></li>
            <li><a href="#sec31">3.1 Introducci√≥n</a></li>
            <li><a href="#sec32">3.2 Clases y Objetos</a></li>
            <li><a href="#sec33">3.3 Generalidades de Ejemplos</a></li>
            <li><a href="#sec34">3.4 Definici√≥n de Clase</a></li>
            <li><a href="#sec35">3.5 Funci√≥n con Par√°metros</a></li>
            <li><a href="#sec36">3.6 Miembros de Datos</a></li>
            <li><a href="#sec37">3.7 Constructores</a></li>
            <li><a href="#sec38">3.8 Archivos Separados</a></li>
            <li><a href="#sec39">3.9 Interfaz e Implementaci√≥n</a></li>
            <li><a href="#sec310">3.10 Validaci√≥n de Datos</a></li>
            <li><a href="#sec311">3.11 ATM: Ing. de Software</a></li>
            <li><a href="#sec312">3.12 Repaso</a></li>
        </ul>
    </aside>

    <main>
        <header>
            <h1 id="top"><a href="#" class="home-link">Unidad Did√°ctica 02 - Paradigma de Objetos - Parte 2</a></h1>
            <p><strong>C√°tedra:</strong> Programaci√≥n Avanzada I. <strong>Nivel:</strong> Universitario. <strong>Basado en:</strong> Deitel & Deitel (6ta Ed.) y O'Reilly (Practical C++).</p>
        </header>

        <!-- 3 -->
		<section id="sec3">
            <h2><span class="icon">üèóÔ∏è</span>3 Introducci√≥n a las clases y los objetos</h2>
            
            <p>En esta secci√≥n, nos adentramos en el n√∫cleo de la <span class="abbr" data-title="POO: Paradigma de programaci√≥n basado en objetos que contienen datos y comportamientos">POO</span>. Seg√∫n el PDF de <strong>Deitel</strong> (<em>C++ C√≥mo Programar</em>), el desarrollo de software moderno requiere pensar en el sistema como una colecci√≥n de entidades aut√≥nomas. No se trata solo de escribir instrucciones secuenciales, sino de modelar la realidad mediante <strong>clases</strong> y <strong>objetos</strong>. Este cambio de paradigma es fundamental para el ingeniero; mientras que la programaci√≥n procedimental se centra en verbos (acciones), la POO se centra en sustantivos (objetos) que poseen tanto estado como comportamiento.</p>

            <h3>3.1 La analog√≠a del plano y la construcci√≥n</h3>
            <p>Basado en el PDF de <strong>Deitel</strong>, una clase puede entenderse como el "plano" (<em>blueprint</em>) de una casa. El plano define las caracter√≠sticas (n√∫mero de ventanas, tipo de techo) y las funcionalidades (sistema el√©ctrico, drenaje), pero no es una casa en s√≠ misma. El <strong>objeto</strong> es la instancia f√≠sica construida a partir de ese plano. Ustedes pueden construir m√∫ltiples casas (objetos) a partir de un √∫nico plano (clase), y cada una tendr√° su propia identidad, aunque compartan la misma estructura b√°sica.</p>
            
            <p>Desde la perspectiva del <strong>Cuaderno de notebookLM sobre educaci√≥n y metodolog√≠as activas</strong>, este concepto de "instanciaci√≥n" debe ser abordado mediante el aprendizaje constructivista. No basta con que el estudiante memorice la sintaxis; debe "construir" mentalmente la relaci√≥n entre el tipo de dato abstracto y la entidad en memoria. El cuaderno sugiere que la mejor forma de asimilar esto es mediante la identificaci√≥n de objetos en el entorno real de los estudiantes, aplicando la t√©cnica de modelado antes de la codificaci√≥n.</p>

            <h3>3.2 Atributos y Funciones Miembro: El Contrato de Comportamiento</h3>
            <p>Una clase en C++ encapsula datos y funciones. <strong>O'Reilly</strong>, en su texto <em>Practical C++ Programming</em>, enfatiza que la robustez de un sistema depende de cu√°n bien hayamos definido estas fronteras l√≥gicas. Los datos se denominan <strong>miembros de datos</strong> (o atributos) y las funciones que operan sobre ellos se llaman <strong>funciones miembro</strong> (o m√©todos). Seg√∫n <strong>O'Reilly</strong>, una clase bien dise√±ada es aquella que presenta una interfaz clara y oculta su complejidad interna.</p>

            <p>En este punto, el <strong>Cuaderno de notebookLM sobre UX UI</strong> aporta una visi√≥n cr√≠tica: la interfaz de una clase (sus funciones p√∫blicas) es, en esencia, la "interfaz de usuario" para el desarrollador que la utiliza. Una mala disposici√≥n de los m√©todos o nombres ambiguos aumentan la <span class="abbr" data-title="Carga Cognitiva: Cantidad de esfuerzo mental utilizado en la memoria de trabajo">Carga Cognitiva</span> del programador. Aplicar principios de UX al dise√±o de clases significa crear m√©todos que sean "descubribles" y cuya funci√≥n sea predecible, reduciendo la fricci√≥n en el mantenimiento del c√≥digo.</p>

            <h3>3.3 Encapsulamiento y Ocultamiento de Datos</h3>
            <p>Uno de los principios m√°s destacados en el PDF de <strong>Deitel</strong> es el <strong>encapsulamiento</strong>. Al declarar los miembros de datos como <code>private</code>, impedimos que funciones externas a la clase los manipulen arbitrariamente. Esto protege la integridad del objeto. Por ejemplo, si tenemos una clase <code>CuentaBancaria</code>, el atributo <code>saldo</code> no deber√≠a ser modificado directamente desde fuera; en su lugar, se utilizan funciones miembro <code>depositar</code> o <code>retirar</code> que validan la operaci√≥n.</p>
            
            <p><strong>O'Reilly</strong> complementa esta idea se√±alando que el ocultamiento de informaci√≥n permite cambiar la implementaci√≥n interna de una clase sin afectar a quienes la usan. Esta "independencia de implementaci√≥n" es lo que permite que los sistemas de software crezcan y se vuelvan escalables. En el desarrollo web profesional, como se menciona en el <strong>Cuaderno de notebookLM sobre desarrollo web</strong>, este aislamiento de responsabilidades es an√°logo a la separaci√≥n entre el <em>backend</em> y el <em>frontend</em>; cada componente conf√≠a en el contrato de la interfaz sin necesitar conocer los detalles t√©cnicos del otro.</p>

            <h3>3.4 Implementaci√≥n Pr√°ctica: Constructores y Setters/Getters</h3>
            <p>Para garantizar que un objeto nazca en un estado v√°lido, utilizamos <strong>constructores</strong>. Seg√∫n <strong>Deitel</strong>, el constructor es una funci√≥n miembro especial que se ejecuta autom√°ticamente cuando se crea el objeto. Es el lugar ideal para inicializar los atributos. Si no definimos uno, C++ proporciona un constructor predeterminado, pero <strong>O'Reilly</strong> advierte que depender de esto puede llevar a errores de l√≥gica si los datos no se inicializan correctamente.</p>

            <p>Para interactuar con los datos privados, la pr√°ctica est√°ndar en C++ (y recomendada exhaustivamente por Deitel) es el uso de funciones <strong>set</strong> (mutadores) y <strong>get</strong> (accesores). Estas funciones act√∫an como guardianes. Por ejemplo, una funci√≥n <code>setHora(int h)</code> puede verificar que el valor de <code>h</code> est√© entre 0 y 23 antes de asignarlo. Esta validaci√≥n es crucial para evitar que el software entre en estados inconsistentes.</p>

            <h3>3.5 Reflexi√≥n para la Ingenier√≠a: El objeto como entidad aut√≥noma</h3>
            <p>El <strong>Cuaderno de notebookLM sobre educaci√≥n</strong> subraya que el aprendizaje de la POO requiere que los futuros ingenieros pasen de una mentalidad de "resolver problemas" a una de "dise√±ar sistemas". Al modelar una entidad, no solo estamos escribiendo c√≥digo; estamos definiendo un lenguaje propio para el problema que intentamos resolver. La clase es el contrato que garantiza que los objetos interact√∫en de forma segura y eficiente.</p>

            <p>Finalmente, integrando la visi√≥n del <strong>Cuaderno sobre desarrollo web</strong> y el texto de <strong>O'Reilly</strong>, debemos entender que el dise√±o de objetos es la base de las arquitecturas limpias. En un entorno web, donde los datos fluyen constantemente entre diferentes capas, tener clases bien estructuradas facilita la <span class="abbr" data-title="Serializaci√≥n: Proceso de convertir un objeto en un formato que pueda ser almacenado o transmitido">Serializaci√≥n</span> y el manejo de estados complejos. La robustez t√©cnica de C++ unida a un dise√±o orientado a objetos s√≥lido permite crear aplicaciones que no solo funcionan, sino que son legibles, mantenibles y profesionalmente impecables.</p>

            <button class="ref-btn" onclick="showRef('3')">Referencia Bibliogr√°fica</button>
        </section>

        <!-- 3.1 -->
		<section id="sec31">
            <h2><span class="icon">üîç</span>3.1 Introducci√≥n a la Evoluci√≥n del Paradigma</h2>
            
            <p>Tradicionalmente, la programaci√≥n se centraba en las funciones (el "hacer cosas"). Este enfoque, conocido como programaci√≥n estructurada o procedimental, permit√≠a una descomposici√≥n algor√≠tmica clara pero presentaba limitaciones severas ante el escalamiento masivo. Seg√∫n el texto de <strong>Deitel</strong> (<em>C++ C√≥mo Programar</em>), a medida que los sistemas crecieron en complejidad durante las d√©cadas de 1970 y 1980, este enfoque se volvi√≥ ingobernable, dando lugar a lo que se denomin√≥ la "crisis del software". La transici√≥n hacia los objetos permite gestionar esta complejidad dividiendo el software en unidades que tienen sentido en el mundo real, permitiendo que el desarrollador deje de pensar en t√©rminos de "instrucciones de m√°quina" para pensar en t√©rminos de "entidades de dominio".</p>
            
            <div class="timeline">
                <div class="timeline-event">
                    <span class="date">1970s</span>
                    <p><strong>Dominio de la programaci√≥n estructurada:</strong> Lenguajes como C y Pascal definieron una era. Seg√∫n <strong>O'Reilly</strong> (<em>Practical C++ Programming</em>), el enfoque estaba estrictamente en los algoritmos y la manipulaci√≥n directa de estructuras de datos globales. Sin embargo, la falta de ocultamiento de informaci√≥n provocaba que cualquier cambio en la estructura de los datos tuviera un efecto domin√≥ catastr√≥fico en todo el sistema. Esta vulnerabilidad es la que la POO vendr√≠a a subsanar mediante el encapsulamiento.</p>
                </div>
                <div class="timeline-event">
                    <span class="date">1980s</span>
                    <p><strong>El nacimiento de C++ y "C con Clases":</strong> Bjarne Stroustrup, en los Laboratorios Bell, busc√≥ combinar la eficiencia de C con las capacidades de abstracci√≥n de Simula. <strong>Deitel</strong> se√±ala que este hito no fue solo una mejora sint√°ctica, sino una revoluci√≥n sem√°ntica. La introducci√≥n de la clase permiti√≥ crear Tipos de Datos Abstractos (<span class="abbr" data-title="ADT: Abstract Data Types. Tipos de datos definidos por el usuario que encapsulan datos y operaciones">ADT</span>) que protegen su estado interno.</p>
                </div>
                <div class="timeline-event">
                    <span class="date">1990s - 1998</span>
                    <p><strong>Estandarizaci√≥n y Madurez:</strong> Con la publicaci√≥n del primer est√°ndar ISO/IEC en 1998, C++ se consolid√≥ como el est√°ndar industrial. Seg√∫n el <strong>Cuaderno de notebookLM sobre desarrollo web</strong>, este periodo es crucial porque la POO permiti√≥ la creaci√≥n de bibliotecas de software reutilizables, lo que hoy conocemos como <em>frameworks</em>. La industria pas√≥ de escribir software desde cero a ensamblar componentes robustos y probados.</p>
                </div>
                <div class="timeline-event">
                    <span class="date">Siglo XXI</span>
                    <p><strong>C++ Moderno:</strong> Los est√°ndares C++11, C++14, C++17 y posteriores han refinado el lenguaje. El <strong>Cuaderno de notebookLM sobre desarrollo web</strong> destaca que, aunque han surgido lenguajes de m√°s alto nivel, C++ sigue siendo la columna vertebral de motores de b√∫squeda, navegadores y sistemas donde el rendimiento es cr√≠tico, demostrando que la abstracci√≥n de objetos no tiene por qu√© sacrificar la velocidad.</p>
                </div>
            </div>

            <h3>3.1.1 La Crisis del Software y el Cambio de Mentalidad</h3>
            <p>La necesidad de la Programaci√≥n Orientada a Objetos (<span class="abbr" data-title="POO: Paradigma que organiza el dise√±o de software en torno a datos u objetos, en lugar de funciones y l√≥gica">POO</span>) surge de una necesidad t√©cnica pero tambi√©n humana. Basado en el <strong>Cuaderno de notebookLM sobre educaci√≥n y metodolog√≠as activas</strong>, el aprendizaje de la POO requiere una reconfiguraci√≥n de los esquemas mentales del estudiante. En la programaci√≥n estructurada, el flujo es lineal; en la POO, el flujo es una red de mensajes entre objetos aut√≥nomos.</p>
            
            <p><strong>O'Reilly</strong> advierte que muchos programadores cometen el error de usar C++ como si fuera "C con esteroides", ignorando las ventajas del dise√±o orientado a objetos. Para evitar esto, la formaci√≥n en ingenier√≠a debe enfatizar el <strong>Modelado</strong>. Como ingenieros, deben ser capaces de abstraer las caracter√≠sticas esenciales de un objeto (atributos) y sus comportamientos (m√©todos) antes de tocar una sola l√≠nea de c√≥digo. Este enfoque es lo que garantiza que el software sea extensible. Si el modelo es s√≥lido, agregar una nueva funcionalidad no requiere reescribir el sistema, sino simplemente a√±adir o extender clases existentes.</p>

            <h3>3.1.2 El Control de Bajo Nivel y la Elegancia de la Abstracci√≥n</h3>
            <p>Una de las mayores fortalezas de C++, resaltada tanto por <strong>Deitel</strong> como por el <strong>Cuaderno de desarrollo web</strong>, es su naturaleza h√≠brida. A diferencia de lenguajes como Java o Python, C++ permite el control absoluto del <span class="abbr" data-title="Bajo Nivel: Capacidad de interactuar directamente con la memoria del sistema y los registros del procesador">bajo nivel</span> (gesti√≥n manual de memoria, punteros, operaciones de bits). Sin embargo, gracias a las clases, este control se puede "envolver" en abstracciones elegantes.</p>
            
            <p>Desde la perspectiva del <strong>Cuaderno de notebookLM sobre UX UI</strong>, existe una analog√≠a poderosa entre el dise√±o de una interfaz de usuario y el dise√±o de una clase. As√≠ como una interfaz debe ser intuitiva para el usuario final, una clase debe ser "utilizable" para el programador. El principio de <span class="abbr" data-title="Affordance: Propiedad de un objeto que sugiere c√≥mo debe ser usado">affordance</span> en el dise√±o se traduce en la programaci√≥n como una interfaz de clase (sus m√©todos p√∫blicos) que sugiere claramente su prop√≥sito. Un buen programador de C++ dise√±a clases que son dif√≠ciles de usar de forma incorrecta.</p>

            <h3>3.1.3 Contexto Acad√©mico en Argentina: La Relevancia de C++</h3>
            <p>En Argentina, la ense√±anza universitaria en facultades de ingenier√≠a (como la UTN o la UBA) prioriza el estudio de C++ precisamente por esta dualidad. El mercado laboral local, que exporta servicios de software de alta complejidad, valora al profesional que comprende qu√© sucede en la memoria mientras dise√±a arquitecturas de alto nivel. Aprender C++ no es solo aprender un lenguaje; es aprender c√≥mo funciona la computaci√≥n moderna.</p>
            
            <p>El <strong>Cuaderno de notebookLM sobre educaci√≥n</strong> sugiere que el uso de C++ fomenta un "aprendizaje profundo". Al enfrentarse a conceptos como la gesti√≥n de memoria dentro de un objeto, el estudiante desarrolla una comprensi√≥n sist√©mica que los lenguajes de alto nivel a menudo ocultan. Ustedes ver√°n que dominar esta secci√≥n 3.1 les permitir√° no solo escribir c√≥digo eficiente, sino comprender la infraestructura de los sistemas operativos, los motores de bases de datos y los videojuegos de √∫ltima generaci√≥n, donde C++ sigue siendo el rey indiscutido.</p>

            <p>En conclusi√≥n, la transici√≥n de las funciones a los objetos es el paso de la artesan√≠a de c√≥digo a la ingenier√≠a de software. Al segmentar la realidad en objetos, como propone <strong>Deitel</strong>, creamos sistemas m√°s robustos, f√°ciles de testear y, sobre todo, mantenibles en el tiempo, una cualidad indispensable en el mundo del desarrollo profesional actual.</p>

            <button class="ref-btn" onclick="showRef('3.1')">Referencia Bibliogr√°fica</button>
        </section>

        <!-- 3.2 -->
		<section id="sec32">
            <h2><span class="icon">üì¶</span>3.2 Clases, objetos, funciones miembro y miembros de datos</h2>
            
            <p>Para comprender la arquitectura de un sistema moderno, debemos interiorizar la dualidad entre lo abstracto y lo concreto. Imaginen un autom√≥vil: un plano de ingenier√≠a detallado no es el veh√≠culo en s√≠, sino un conjunto de especificaciones t√©cnicas y l√≥gicas para su creaci√≥n. En t√©rminos de programaci√≥n, ese plano es la <strong>Clase</strong>. El auto f√≠sico que ustedes conducen por la Av. Rivadavia, con un n√∫mero de chasis √∫nico y una posici√≥n espec√≠fica en el espacio, es el <strong>Objeto</strong> (una instancia tangible de la clase).</p>

            <p>Seg√∫n el PDF de <strong>Deitel</strong> (<em>C++ C√≥mo Programar</em>), una clase funciona como un nuevo tipo de dato definido por el usuario. Mientras que los tipos b√°sicos (como <code>int</code> o <code>float</code>) son at√≥micos, las clases son componentes de software reutilizables que agrupan complejidad. Esta capacidad de empaquetar datos y funciones es lo que conocemos como <span class="abbr" data-title="Encapsulamiento: Proceso de agrupar datos y m√©todos que operan sobre esos datos en una sola unidad">encapsulamiento</span>.</p>

            <h3>3.2.1 Anatom√≠a de la Clase: Estado y Comportamiento</h3>
            <p>La estructura interna de una clase se divide en dos pilares fundamentales que definen la naturaleza de cualquier entidad modelada:</p>
            <ul>
                <li><strong>Miembros de Datos (Atributos):</strong> Representan el <strong>estado</strong> del objeto. Basado en el PDF de <strong>O'Reilly</strong> (<em>Practical C++ Programming</em>), los atributos son variables que pertenecen a la clase. Siguiendo el ejemplo del autom√≥vil, estos incluir√≠an la cantidad de combustible, la velocidad actual y el color. Es crucial notar que cada objeto mantiene su propia copia de estos datos; si un auto se queda sin nafta, el resto de los objetos de la misma clase no se ven afectados.</li>
                <li><strong>Funciones Miembro (M√©todos):</strong> Representan el <strong>comportamiento</strong> o las capacidades del objeto. Son las acciones que el objeto puede realizar, como <code>acelerar()</code>, <code>frenar()</code> o <code>virar()</code>. Deitel enfatiza que estas funciones son las encargadas de manipular los miembros de datos, asegurando que el estado del objeto cambie de manera controlada y predecible.</li>
            </ul>

            <div class="diagram">
                <div class="box">
                    <strong>Clase: CuentaBancaria</strong><br>
                    <small>Atributos: saldo, titular</small><br>
                    <small>M√©todos: depositar(), retirar()</small><br>
                    <em>(El Molde L√≥gico)</em>
                </div>
                <div class="arrow">‚¨á Instanciaci√≥n (Reserva de Memoria)</div>
                <div class="box">
                    <strong>Objeto: cuentaDeJuan</strong><br>
                    <small>saldo: $50.000</small><br>
                    <small>ID: 0x4f2a1</small><br>
                    <em>(Entidad Viva en RAM)</em>
                </div>
            </div>

            <h3>3.2.2 El Enfoque de Ingenier√≠a: Identidad y Contratos</h3>
            <p>Ustedes, como ingenieros, deben ver la clase como un <strong>contrato de comportamiento</strong>. El <strong>Cuaderno de notebookLM sobre educaci√≥n y metodolog√≠as activas</strong> sugiere que la comprensi√≥n de este concepto se facilita mediante el "modelado mental activo". No se trata solo de escribir c√≥digo, sino de identificar las responsabilidades de cada objeto. En el dise√±o de software, si una funci√≥n miembro no est√° alineada con la responsabilidad de la clase, se rompe la <span class="abbr" data-title="Cohesi√≥n: Medida de qu√© tan estrechamente relacionadas est√°n las responsabilidades de un m√≥dulo">cohesi√≥n</span>, un error com√∫n que <strong>O'Reilly</strong> advierte en programadores inexpertos.</p>

            <p>Adem√°s, cada objeto posee una <strong>identidad</strong> √∫nica. Dos objetos pueden tener exactamente los mismos valores en sus atributos (por ejemplo, dos cuentas bancarias con $0 de saldo), pero siguen siendo entidades distintas en la memoria del sistema. El acceso a estas entidades se realiza mediante el operador punto (<code>.</code>), que act√∫a como el puente de comunicaci√≥n entre el controlador del sistema y la interfaz del objeto.</p>

            <h3>3.2.3 La Perspectiva de Dise√±o: UX/UI y Desarrollo Web</h3>
            <p>Integrando el <strong>Cuaderno de notebookLM sobre UX UI</strong>, podemos afirmar que los nombres de las funciones miembro y la visibilidad de los datos conforman la "API interna" del sistema. Un buen dise√±o de clase debe seguir principios de usabilidad para el desarrollador: las funciones deben ser autodescriptivas. Si un ingeniero de C++ dise√±a una clase <code>Motor</code> con una funci√≥n miembro llamada <code>x1()</code> en lugar de <code>iniciarIgnicion()</code>, est√° aumentando la carga cognitiva y dificultando el mantenimiento.</p>
            
            <p>Desde la √≥ptica del <strong>Cuaderno de notebookLM sobre desarrollo web</strong>, la importancia de las clases radica en la modularidad. En sistemas web complejos, los objetos act√∫an como contenedores de l√≥gica de negocio que pueden ser testeados de forma aislada. La separaci√≥n de "lo que un objeto hace" (interfaz p√∫blica) de "c√≥mo lo hace" (implementaci√≥n privada) es el coraz√≥n de lo que <strong>Deitel</strong> llama el ocultamiento de informaci√≥n (<em>information hiding</em>). Esto permite que, por ejemplo, podamos cambiar la f√≥rmula de c√°lculo de intereses en una clase <code>Prestamo</code> sin que el resto de la aplicaci√≥n web sufra modificaciones, siempre y cuando el nombre de la funci√≥n y sus par√°metros permanezcan constantes.</p>

            <h3>3.2.4 Implementaci√≥n y Ciclo de Vida</h3>
            <p>Para que un objeto sea √∫til, debe ser inicializado correctamente. <strong>Deitel</strong> explica que las clases suelen incluir funciones miembro especiales denominadas <strong>constructores</strong>, cuya misi√≥n es establecer los valores iniciales de los miembros de datos al momento de la creaci√≥n (instanciaci√≥n). Sin una inicializaci√≥n adecuada, los miembros de datos podr√≠an contener valores residuales de la memoria ("basura"), un riesgo de seguridad y estabilidad que <strong>O'Reilly</strong> destaca como cr√≠tico en aplicaciones industriales.</p>

            <p>Finalmente, es vital entender que la interacci√≥n con los objetos no es ca√≥tica. En C++, el programador tiene el control total sobre cu√°ndo un objeto nace y cu√°ndo muere (liberaci√≥n de memoria). Esta responsabilidad t√©cnica, combinada con la elegancia de la abstracci√≥n de objetos, es lo que permite que C++ sea el lenguaje preferido para sistemas donde el rendimiento y la organizaci√≥n l√≥gica son no-negociables. Como futuros profesionales, su objetivo es dise√±ar clases que no solo funcionen, sino que modelen el mundo real con precisi√≥n, facilitando la colaboraci√≥n en equipos de desarrollo a gran escala.</p>

            <button class="ref-btn" onclick="showRef('3.2')">Referencia Bibliogr√°fica</button>
        </section>

        <!-- 3.3 -->
		<section id="sec33">
            <h2><span class="icon">üìã</span>3.3 Generalidades acerca de los ejemplos del cap√≠tulo</h2>
            
            <p>A lo largo de este estudio, utilizaremos una metodolog√≠a de <strong>aprendizaje incremental</strong>. En lugar de presentar una clase completa y compleja desde el primer momento, iniciaremos con una estructura minimalista: la clase <code>LibroCalificaciones</code>. Esta evolucionar√° desde una simple funci√≥n que imprime un mensaje de bienvenida hasta convertirse en un sistema robusto con validaci√≥n de datos, miembros privados y una clara separaci√≥n entre la interfaz y la implementaci√≥n. Seg√∫n el <strong>PDF de Deitel</strong> (<em>C++ C√≥mo Programar</em>), este enfoque permite que el estudiante asimile los conceptos de la Programaci√≥n Orientada a Objetos (<span class="abbr" data-title="POO: Paradigma de programaci√≥n basado en objetos que contienen datos y comportamientos">POO</span>) de manera org√°nica, evitando la sobrecarga informativa.</p>

            <h3>3.3.1 Fundamentaci√≥n Pedag√≥gica: El Andamiaje Cognitivo</h3>
            <p>Este m√©todo pedag√≥gico encuentra su respaldo en el <strong>Cuaderno de notebookLM sobre educaci√≥n y metodolog√≠as activas</strong>. Se basa en la teor√≠a del <em>andamiaje</em> (scaffolding), donde el docente (o el material did√°ctico) proporciona apoyos temporales que se retiran a medida que el estudiante gana autonom√≠a. Al empezar con un ejemplo que solo "imprime un mensaje", el alumno se concentra exclusivamente en la sintaxis de definici√≥n de una clase y la invocaci√≥n de una funci√≥n miembro, sin distraerse con la l√≥gica de negocio compleja o la gesti√≥n de memoria.</p>
            
            <p>Ustedes ver√°n que cada nueva iteraci√≥n del ejemplo responde a una necesidad t√©cnica espec√≠fica. El cuaderno de <strong>Metodolog√≠as Activas</strong> destaca que este "conflicto cognitivo" ‚Äîes decir, presentar un problema antes de la soluci√≥n‚Äî es vital para un aprendizaje significativo. Por ejemplo, al notar que cualquier parte del programa puede alterar el nombre del curso de forma indebida, surge naturalmente la necesidad de implementar modificadores de acceso <code>private</code> y funciones de validaci√≥n, transformando el aprendizaje en un proceso de descubrimiento de ingenier√≠a.</p>

            <h3>3.3.2 Evoluci√≥n T√©cnica seg√∫n Deitel y O'Reilly</h3>
            <p>De acuerdo con el <strong>PDF de Deitel</strong>, la evoluci√≥n de la clase <code>LibroCalificaciones</code> seguir√° un camino cr√≠tico de profesionalizaci√≥n:</p>
            <ul>
                <li><strong>Fase 1: Definici√≥n B√°sica.</strong> Se introducen las palabras clave <code>class</code> y <code>public</code>. El objetivo es entender que una clase es un contenedor de comportamientos.</li>
                <li><strong>Fase 2: Paso de Par√°metros.</strong> Se dota a las funciones miembro de la capacidad de recibir informaci√≥n externa, permitiendo que un objeto sea din√°mico y responda a datos variables.</li>
                <li><strong>Fase 3: Miembros de Datos y Encapsulamiento.</strong> Aqu√≠ es donde, seg√∫n <strong>O'Reilly</strong> (<em>Practical C++ Programming</em>), el software empieza a ser "pr√°ctico". Se a√±aden atributos para mantener el estado del objeto y se discute por qu√© los datos deben estar protegidos del acceso directo.</li>
                <li><strong>Fase 4: Constructores.</strong> Se ense√±a c√≥mo garantizar que cada objeto de la clase <code>LibroCalificaciones</code> nazca con un estado v√°lido, eliminando la posibilidad de trabajar con datos "basura" o nulos.</li>
            </ul>

            <p><strong>O'Reilly</strong> complementa este an√°lisis se√±alando que la robustez del software no reside solo en que el c√≥digo funcione, sino en su capacidad para resistir errores del usuario. Por ello, el ejemplo final del cap√≠tulo incorpora la validaci√≥n de entrada, asegurando que el nombre del curso no supere una longitud determinada, lo que previene errores de desbordamiento o inconsistencias en la presentaci√≥n de datos.</p>

            <h3>3.3.3 La Perspectiva de UX/UI para Desarrolladores</h3>
            <p>Un aspecto a menudo ignorado en la ense√±anza t√©cnica es la <span class="abbr" data-title="Developer Experience: La sensaci√≥n y facilidad de uso que experimenta un programador al interactuar con una biblioteca o API">DX</span> (Developer Experience). Basado en el <strong>Cuaderno de notebookLM sobre UX UI</strong>, la forma en que dise√±amos nuestras clases es una forma de dise√±o de interfaz. Los ejemplos del cap√≠tulo han sido cuidadosamente seleccionados para mostrar nombres de funciones claros (como <code>establecerNombreCurso</code> en lugar de <code>setN</code>) y estructuras predecibles.</p>
            
            <p>La aplicaci√≥n de principios de UX al c√≥digo reduce la carga cognitiva. Cuando ustedes estudien el <code>LibroCalificaciones</code>, no solo estar√°n aprendiendo C++; estar√°n aprendiendo a dise√±ar componentes de software que otros programadores podr√°n entender y usar sin necesidad de leer toda la documentaci√≥n interna. El cuaderno de <strong>UX UI</strong> enfatiza que la consistencia en los nombres y la jerarqu√≠a de las funciones miembro son claves para la mantenibilidad de sistemas a gran escala.</p>

            <h3>3.3.4 Conexi√≥n con el Desarrollo Web Moderno</h3>
            <p>Aunque el ejemplo del <code>LibroCalificaciones</code> se ejecuta en una consola, los principios que se ense√±an son la base del <strong>desarrollo web profesional</strong>. El <strong>Cuaderno de notebookLM sobre desarrollo web</strong> menciona que la estructura de una clase en C++ es conceptualmente id√©ntica a los componentes en frameworks modernos como React o Angular, donde los "miembros de datos" equivalen al <em>estado</em> (state) y las "funciones miembro" a los <em>manejadores de eventos</em> (handlers).</p>
            
            <p>La separaci√≥n de la interfaz (el archivo <code>.h</code>) y la implementaci√≥n (el archivo <code>.cpp</code>), que se aborda hacia el final del cap√≠tulo, es un precursor directo de la arquitectura de microservicios y el desarrollo basado en m√≥dulos que domina la web hoy en d√≠a. Comprender c√≥mo C++ gestiona estas fronteras l√≥gicas les dar√° una ventaja competitiva √∫nica, permiti√©ndoles escribir c√≥digo <em>backend</em> de alta eficiencia o motores de renderizado web con una base arquitect√≥nica s√≥lida.</p>

            <h3>3.3.5 Resumen de Objetivos de Ingenier√≠a</h3>
            <p>En conclusi√≥n, los ejemplos de este cap√≠tulo no son meros fragmentos de c√≥digo, sino un simulacro de desarrollo profesional. Como futuros ingenieros, su tarea es observar c√≥mo la clase <code>LibroCalificaciones</code> pasa de ser un juguete acad√©mico a una pieza de ingenier√≠a reutilizable. Siguiendo los consejos de <strong>Deitel</strong> y <strong>O'Reilly</strong>, buscaremos siempre la m√°xima cohesi√≥n y el m√≠nimo acoplamiento, principios que garantizan que el software sea escalable y f√°cil de depurar.</p>

            <div class="note-box">
                <strong>üí° Recomendaci√≥n del Cuaderno de Metodolog√≠as Activas:</strong> No pasen al siguiente ejemplo hasta que hayan podido explicarle a un compa√±ero (o a ustedes mismos) por qu√© la versi√≥n anterior de la clase era insuficiente para un sistema real. La reflexi√≥n sobre la limitaci√≥n es lo que fija el conocimiento t√©cnico.
            </div>

            <button class="ref-btn" onclick="showRef('3.3')">Referencia Bibliogr√°fica</button>
        </section>

        <!-- 3.4 -->
		<section id="sec34">
            <h2><span class="icon">‚úçÔ∏è</span>3.4 Definici√≥n de una clase con una funci√≥n miembro</h2>
            
            <p>La precisi√≥n sint√°ctica en C++ no es una mera convenci√≥n est√©tica, sino un requisito t√©cnico para la construcci√≥n de sistemas robustos. Seg√∫n el PDF de <strong>Deitel</strong> (<em>C++ C√≥mo Programar</em>), la definici√≥n de una clase comienza con la palabra reservada <code>class</code>, seguida del nombre de la clase en estilo <em>PascalCase</em> (comenzando con may√∫scula), lo cual es una pr√°ctica est√°ndar en la industria para diferenciar los tipos definidos por el usuario de las variables locales.</p>

            <p>Una clase es, en esencia, un nuevo tipo de dato. Al definir <code>LibroCalificaciones</code>, no estamos creando un dato concreto, sino describiendo un nuevo modelo de datos que el compilador debe entender. El cuerpo de la clase se delimita por llaves (<code>{ }</code>). Dentro de estas llaves, se definen los miembros que dar√°n forma al objeto. Es aqu√≠ donde el dise√±o de software se cruza con la ingenier√≠a: debemos decidir qu√© partes de nuestra entidad ser√°n visibles al mundo exterior y cu√°les permanecer√°n ocultas.</p>

            <div class="code-block">
<pre>// Definici√≥n de la clase seg√∫n los est√°ndares de Deitel y O'Reilly
class LibroCalificaciones {
public:
    // Funci√≥n miembro que representa un comportamiento del objeto
    void mostrarMensaje() const {
        // El uso de cout y endl requiere la biblioteca iostream
        std::cout << "Bienvenido al curso de C++!" << std::endl;
    } // Fin de la funci√≥n mostrarMensaje
}; // El punto y coma es OBLIGATORIO aqu√≠</pre>
            </div>

            <h3>3.4.1 El especificador de acceso <code>public:</code></h3>
            <p>Por defecto, C++ adopta una postura conservadora respecto a la seguridad: todos los miembros de una <code>class</code> son privados (<code>private</code>) si no se especifica lo contrario. Esto significa que no son accesibles desde funciones externas, como <code>main</code>. Para permitir que otros componentes del sistema interact√∫en con nuestro objeto, debemos utilizar la etiqueta <code>public:</code>.</p>
            
            <p>Basado en el PDF de <strong>O'Reilly</strong> (<em>Practical C++ Programming</em>), el uso correcto de los especificadores de acceso es la primera l√≠nea de defensa contra errores de l√≥gica. Un error com√∫n de los estudiantes es olvidar la etiqueta <code>public:</code>, lo que resulta en un error de compilaci√≥n que indica que la funci√≥n "es inaccesible". Desde la perspectiva del <strong>Cuaderno de notebookLM sobre UX UI</strong>, este aislamiento (encapsulamiento) es fundamental para reducir el "ruido" en la interfaz de programaci√≥n; un desarrollador solo deber√≠a ver aquello que realmente necesita usar para cumplir su tarea.</p>

            <h3>3.4.2 Anatom√≠a de la Funci√≥n Miembro</h3>
            <p>La funci√≥n <code>mostrarMensaje</code> dentro de nuestra clase es lo que <strong>Deitel</strong> denomina una "funci√≥n miembro". A diferencia de las funciones globales de C, estas funciones est√°n intr√≠nsecamente ligadas a la identidad de la clase. Poseen un tipo de retorno (en este caso <code>void</code>, indicando que no devuelve valor) y un cuerpo de funci√≥n donde se ejecuta la l√≥gica.</p>

            <p>Un detalle t√©cnico avanzado, mencionado por <strong>O'Reilly</strong>, es que las funciones miembro tienen acceso impl√≠cito a todos los dem√°s miembros de la clase (datos y otras funciones). Esto crea un entorno de ejecuci√≥n cohesivo. En el <strong>Cuaderno de notebookLM sobre desarrollo web</strong>, este concepto se compara con los m√©todos de clase en JavaScript moderno o los componentes de React, donde el comportamiento est√° encapsulado junto con la l√≥gica de renderizado, permitiendo una modularidad que facilita enormemente el mantenimiento del c√≥digo a largo plazo.</p>

            <h3>3.4.3 El "Error del Punto y Coma" y la Pedagog√≠a del Error</h3>
            <p>Uno de los puntos m√°s cr√≠ticos se√±alados por <strong>Deitel</strong> es la necesidad del punto y coma (<code>;</code>) despu√©s de la llave de cierre de la clase. T√©cnicamente, esto se debe a que una definici√≥n de clase en C++ es una sentencia de declaraci√≥n de tipo. Omitir este car√°cter es uno de los errores m√°s frecuentes en los ex√°menes parciales y en la pr√°ctica profesional inicial.</p>
            
            <p>El <strong>Cuaderno de notebookLM sobre educaci√≥n y metodolog√≠as activas</strong> sugiere abordar este error com√∫n no solo como un fallo de memoria, sino como una oportunidad de "aprendizaje basado en la depuraci√≥n". Se recomienda que los alumnos provoquen el error intencionalmente para reconocer los mensajes cr√≠pticos del compilador. Comprender el "porqu√©" de la sintaxis ‚Äîen este caso, que C++ permite declarar variables inmediatamente despu√©s de la definici√≥n de la clase, de ah√≠ la necesidad de cerrar la sentencia‚Äî fija el conocimiento de manera mucho m√°s efectiva que la simple repetici√≥n.</p>

            <h3>3.4.4 Perspectiva de Dise√±o: La Clase como Interfaz de Usuario</h3>
            <p>Integrando el <strong>Cuaderno de notebookLM sobre UX UI</strong>, debemos ver la definici√≥n de una clase como el dise√±o de una experiencia para el programador (<em>Developer Experience</em>). La etiqueta <code>public:</code> define la <span class="abbr" data-title="Superficie de Ataque/Uso: Conjunto de puntos en los que un usuario o sistema puede interactuar">superficie de uso</span> de nuestra clase. Un buen ingeniero de software dise√±a clases con interfaces p√∫blicas peque√±as y claras.</p>
            
            <p>Si la interfaz p√∫blica es demasiado extensa, la carga cognitiva del desarrollador aumenta, incrementando la probabilidad de errores. Por ello, <strong>O'Reilly</strong> enfatiza que solo las funciones esenciales para el comportamiento externo deben ser p√∫blicas. Todo lo relacionado con el "c√≥mo" se hace el trabajo (detalles de implementaci√≥n) debe permanecer oculto, siguiendo el principio de dise√±o de "menor sorpresa".</p>

            <h3>3.4.5 Relevancia en la Ingenier√≠a de Software Moderna</h3>
            <p>La definici√≥n de clases en C++ sienta las bases para arquitecturas escalables. Seg√∫n el <strong>Cuaderno de notebookLM sobre desarrollo web</strong>, este enfoque orientado a componentes es lo que permite que equipos de cientos de personas trabajen en el mismo proyecto sin interferir entre s√≠. Al definir contratos claros a trav√©s de funciones miembro p√∫blicas, aseguramos que los cambios internos en una clase no rompan el funcionamiento del resto del ecosistema web o de la aplicaci√≥n.</p>
            
            <p>Ustedes, como futuros profesionales, deben dominar esta sintaxis no como un ejercicio de caligraf√≠a de c√≥digo, sino como la herramienta fundamental para crear abstracciones poderosas. Como dice <strong>Deitel</strong>, dominar la definici√≥n de una clase es el primer paso para dejar de ser un "escritor de instrucciones" y convertirse en un "arquitecto de sistemas". La elegancia de C++ reside en su capacidad para ofrecer este nivel de abstracci√≥n sin sacrificar un √°pice de rendimiento, permitiendo que funciones miembro como <code>mostrarMensaje</code> se ejecuten con una eficiencia cercana al c√≥digo de bajo nivel.</p>

            <div class="note-box">
                <strong>üí° Nota Acad√©mica:</strong> Recuerden que en C++ moderno, si una funci√≥n miembro no modifica el estado del objeto, es una excelente pr√°ctica marcarla como <code>const</code>, como se muestra en el bloque de c√≥digo superior. Esto ayuda al compilador a optimizar el c√≥digo y a otros programadores a entender que la funci√≥n es "de solo lectura".
            </div>

            <button class="ref-btn" onclick="showRef('3.4')">Referencia Bibliogr√°fica</button>
        </section>

        <!-- 3.5 -->
		<section id="sec35">
            <h2><span class="icon">üì•</span>3.5 Definici√≥n de una funci√≥n miembro con un par√°metro</h2>
            
            <p>Para que nuestras clases dejen de ser estructuras est√°ticas y se conviertan en entidades din√°micas y √∫tiles, deben poseer la capacidad de recibir informaci√≥n del mundo exterior. Este proceso de comunicaci√≥n se facilita a trav√©s de los <strong>par√°metros</strong> de las funciones miembro. Basado en el libro de <strong>Deitel</strong> (<em>C++ C√≥mo Programar</em>), el paso de par√°metros es el mecanismo que permite que un solo objeto se comporte de manera diferencial seg√∫n la entrada recibida, permitiendo la personalizaci√≥n del estado del objeto en tiempo de ejecuci√≥n.</p>

            <p>En el paradigma de la Programaci√≥n Orientada a Objetos (<span class="abbr" data-title="POO: Paradigma de programaci√≥n basado en objetos que contienen datos y comportamientos">POO</span>), una funci√≥n miembro con par√°metros act√∫a como una interfaz de entrada. Mientras que en la secci√≥n anterior vimos funciones que simplemente ejecutaban una acci√≥n fija, aqu√≠ introducimos la noci√≥n de "datos de entrada" que alimentan la l√≥gica interna de la clase. Esta distinci√≥n es fundamental para la ingenier√≠a de software: pasamos de scripts lineales a componentes interactivos.</p>

            <div class="code-block">
<pre>// Implementaci√≥n t√©cnica basada en est√°ndares de Deitel
#include &lt;iostream&gt;
#include &lt;string&gt; // Necesario para el tipo de dato string

class LibroCalificaciones {
public:
    // Funci√≥n miembro que recibe un par√°metro de tipo string
    // El par√°metro 'nombreCurso' act√∫a como una variable local de la funci√≥n
    void mostrarMensaje(std::string nombreCurso) {
        std::cout << "Bienvenido al curso: " << nombreCurso << "!" << std::endl;
    } 
};</pre>
            </div>

            <h3>3.5.1 La importancia de la biblioteca <code>&lt;string&gt;</code></h3>
            <p>En el c√≥digo anterior, introducimos una herramienta poderosa: la clase <code>std::string</code>. Seg√∫n <strong>O'Reilly</strong> en <em>Practical C++ Programming</em>, el manejo de texto es una de las √°reas donde m√°s errores se comet√≠an en el lenguaje C tradicional debido al uso de arreglos de caracteres terminados en nulo (<code>char*</code>). El PDF de <strong>O'Reilly</strong> enfatiza que los objetos <code>string</code> de C++ eliminan gran parte del peligro de los <span class="abbr" data-title="Buffer Overflow: Error de software que ocurre cuando se escriben m√°s datos en un bloque de memoria de los que este puede retener">desbordamientos de b√∫fer</span>, ya que gestionan su propio tama√±o y memoria de forma autom√°tica.</p>
            
            <p>Ustedes, como futuros profesionales, deben acostumbrarse a incluir la cabecera <code>&lt;string&gt;</code> siempre que necesiten manipular texto. <strong>Deitel</strong> se√±ala que <code>string</code> no es un tipo de dato b√°sico (como <code>int</code> o <code>double</code>), sino una clase de la Biblioteca Est√°ndar, lo que significa que el par√°metro <code>nombreCurso</code> es, en realidad, un objeto que se pasa a la funci√≥n.</p>

            <h3>3.5.2 Par√°metros vs. Argumentos: Claridad Terminol√≥gica</h3>
            <p>Es com√∫n que en los ex√°menes y en el √°mbito profesional se confundan estos t√©rminos. El <strong>Cuaderno de notebookLM sobre educaci√≥n y metodolog√≠as activas</strong> sugiere un enfoque constructivista para diferenciar estos conceptos:</p>
            <ul>
                <li><strong>Par√°metro:</strong> Es el marcador de posici√≥n definido en la declaraci√≥n de la funci√≥n (en nuestro caso, <code>nombreCurso</code>). Es el "molde" que espera un valor.</li>
                <li><strong>Argumento:</strong> Es el valor real que se env√≠a a la funci√≥n en el momento de la llamada (por ejemplo, <code>"Programacion I"</code>).</li>
            </ul>
            <p>Esta distinci√≥n es vital para entender el flujo de datos. Desde el punto de vista del <strong>Cuaderno sobre desarrollo web</strong>, esta transferencia es an√°loga a la manera en que una API recibe par√°metros en una petici√≥n <code>POST</code> o <code>GET</code>; el servidor define qu√© espera (par√°metro) y el cliente env√≠a el dato concreto (argumento).</p>

            <h3>3.5.3 Perspectiva de Dise√±o: UX para Desarrolladores</h3>
            <p>El dise√±o de los par√°metros de una funci√≥n no es solo una decisi√≥n t√©cnica, sino tambi√©n una decisi√≥n de <strong>experiencia de usuario (UX)</strong> para el programador que utilizar√° nuestra clase. Seg√∫n el <strong>Cuaderno de notebookLM sobre UX UI</strong>, el nombre de un par√°metro debe ser sem√°nticamente rico. Un nombre como <code>string s</code> es pobre, mientras que <code>string nombreCurso</code> comunica inmediatamente qu√© tipo de informaci√≥n se espera.</p>
            
            <p>Adem√°s, el cuaderno de UX UI resalta la importancia de la <span class="abbr" data-title="Carga Cognitiva: Cantidad de esfuerzo mental que el cerebro utiliza para procesar informaci√≥n">Carga Cognitiva</span>. Si una funci√≥n requiere demasiados par√°metros, el desarrollador que la invoque tendr√° m√°s probabilidades de cometer errores en el orden o en el tipo de los datos. La recomendaci√≥n acad√©mica es mantener las funciones miembro con la menor cantidad de par√°metros posible, agrupando datos relacionados en objetos si es necesario.</p>

            <h3>3.5.4 Metodolog√≠as Activas: Aprendizaje por Descubrimiento</h3>
            <p>El <strong>Cuaderno de notebookLM sobre educaci√≥n</strong> propone que, para dominar el uso de par√°metros, los estudiantes realicen ejercicios de "Ingenier√≠a Inversa". En lugar de copiar el c√≥digo, se les pide identificar qu√© datos necesita un objeto (como un <code>Termostato</code> o una <code>CamaraSeguridad</code>) para cumplir su funci√≥n. Al identificar que un termostato necesita un par√°metro <code>temperaturaDeseada</code> para funcionar, el alumno entiende la utilidad real del par√°metro antes de enfrentarse a la sintaxis <code>void establecerTemperatura(int temp)</code>.</p>

            <h3>3.5.5 Robustez y Buenas Pr√°cticas seg√∫n O'Reilly</h3>
            <p>En el PDF de <strong>O'Reilly</strong> se menciona un detalle t√©cnico crucial para el rendimiento: cuando pasamos un objeto <code>string</code> como par√°metro de la forma <code>void funcion(string s)</code>, se crea una copia completa de la cadena de texto en la memoria. Para aplicaciones industriales de alto rendimiento, <strong>O'Reilly</strong> sugiere el uso de referencias constantes (<code>const string&</code>), un tema que profundizaremos en secciones avanzadas pero que ya deben tener en su radar de ingenier√≠a. El paso por valor es aceptable para el aprendizaje inicial, pero la optimizaci√≥n es la marca de un programador senior.</p>
            
            <p>En conclusi√≥n, dotar a las funciones miembro de par√°metros es el primer paso hacia la creaci√≥n de software modular y flexible. Como indica <strong>Deitel</strong>, esto permite que la clase <code>LibroCalificaciones</code> no sea solo un letrero est√°tico, sino un componente capaz de representar y gestionar la informaci√≥n de cualquier curso dentro de una instituci√≥n educativa, facilitando la reutilizaci√≥n del c√≥digo y la escalabilidad del sistema.</p>

            <button class="ref-btn" onclick="showRef('3.5')">Referencia Bibliogr√°fica</button>
        </section>

        <!-- 3.6 -->
		<section id="sec36">
            <h2><span class="icon">üõ°Ô∏è</span>3.6 Miembros de datos, funciones establecer y funciones obtener</h2>
            
            <p>En el n√∫cleo de la ingenier√≠a de software de calidad reside el principio del <strong>Encapsulamiento</strong>, tambi√©n conocido en el √°mbito acad√©mico como <strong>Ocultamiento de Informaci√≥n</strong> (<em>Information Hiding</em>). Seg√∫n el PDF de <strong>Deitel</strong> (<em>C++ C√≥mo Programar</em>), una de las reglas de oro del dise√±o orientado a objetos es que los datos de una clase deben mantenerse ocultos para el mundo exterior. Para lograr esto, declaramos los miembros de datos bajo el especificador de acceso <code>private</code>. Sin embargo, un objeto que no permite interactuar con su estado es in√∫til; por ello, proporcionamos "puertas de enlace" controladas denominadas funciones <strong>Establecer</strong> (<em>Setters</em>) y <strong>Obtener</strong> (<em>Getters</em>).</p>

            <p>Desde la perspectiva del <strong>Cuaderno de notebookLM sobre UX UI</strong>, estas funciones no son solo c√≥digo, sino la interfaz de usuario del programador. Un dise√±o de clase que expone sus variables internas directamente rompe el principio de <span class="abbr" data-title="Encapsulamiento: Mecanismo que agrupa los datos y el c√≥digo que los manipula, protegi√©ndolos de interferencias externas">abstracci√≥n</span>, obligando al usuario de la clase a conocer detalles de implementaci√≥n que no deber√≠an ser su preocupaci√≥n. La "usabilidad" de una clase depende de que sus funciones <code>set</code> y <code>get</code> sean intuitivas y seguras.</p>

            <div class="table-responsive">
                <table>
                    <thead>
                        <tr>
                            <th>Concepto T√©cnico</th>
                            <th>Prop√≥sito en la Arquitectura</th>
                            <th>Acceso (Scope)</th>
                            <th>Visi√≥n de Ingenier√≠a</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Miembro de Datos</strong></td>
                            <td>Almacenar el estado interno del objeto (ej. saldo, nombre).</td>
                            <td><code>private</code></td>
                            <td>Protege la integridad; evita la manipulaci√≥n accidental de la memoria.</td>
                        </tr>
                        <tr>
                            <td><strong>Funci√≥n Establecer (Setter)</strong></td>
                            <td>Modificar el valor de un atributo bajo reglas de negocio espec√≠ficas.</td>
                            <td><code>public</code></td>
                            <td>Act√∫a como un filtro de validaci√≥n (Guardia de entrada).</td>
                        </tr>
                        <tr>
                            <td><strong>Funci√≥n Obtener (Getter)</strong></td>
                            <td>Retornar el valor de un atributo de forma segura (lectura).</td>
                            <td><code>public</code></td>
                            <td>Proporciona una vista del estado sin permitir su alteraci√≥n directa.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>3.6.1 La Validaci√≥n: El Guardia de Seguridad del Objeto</h3>
            <p>Basado en el PDF de <strong>Deitel</strong>, la principal ventaja de utilizar una funci√≥n "establecer" en lugar de permitir el acceso directo a una variable es la <strong>validaci√≥n</strong>. Imagine una clase <code>Estudiante</code> con un miembro de datos <code>nota</code>. Si el atributo fuera p√∫blico, cualquier programador externo podr√≠a asignar un valor de <code>-100</code> o <code>999</code>, rompiendo la l√≥gica del sistema. Al usar un <em>Setter</em>, podemos implementar una estructura de control:</p>
            
            <div class="code-block">
<pre>void establecerNota(int valorNota) {
    if (valorNota >= 0 && valorNota <= 10) {
        nota = valorNota; // El dato es v√°lido, se asigna.
    } else {
        // L√≥gica de error o asignaci√≥n por defecto.
        cout << "Error: Nota inv√°lida." << endl;
    }
}</pre>
            </div>

            <p><strong>O'Reilly</strong> (<em>Practical C++ Programming</em>) complementa este punto se√±alando que el software profesional debe ser "defensivo". Un objeto debe ser responsable de su propio estado. Si permitimos que agentes externos modifiquen los datos sin supervisi√≥n, el proceso de <span class="abbr" data-title="Depuraci√≥n: Proceso de identificar y corregir errores en el c√≥digo fuente">debugging</span> se vuelve exponencialmente m√°s dif√≠cil, ya que no sabremos qu√© parte del programa corrompi√≥ el dato. Con los <em>Setters</em>, tenemos un √∫nico punto de entrada donde podemos colocar puntos de interrupci√≥n (<em>breakpoints</em>) para rastrear cambios.</p>

            <h3>3.6.2 Getters y la Inmutabilidad Percibida</h3>
            <p>Las funciones "obtener" permiten que otros objetos consulten el estado necesario para realizar sus tareas sin riesgo de modificarlo. De acuerdo con el <strong>Cuaderno de notebookLM sobre desarrollo web</strong>, este concepto es an√°logo a las respuestas de una API de solo lectura. En el desarrollo web moderno, la predictibilidad del estado es fundamental. Si una funci√≥n <code>obtenerSaldo()</code> simplemente devuelve el valor, garantizamos que la l√≥gica de renderizado visual no afectar√° accidentalmente la l√≥gica financiera del <em>backend</em>.</p>

            <p>Adem√°s, <strong>Deitel</strong> sugiere que las funciones obtener deben declararse como <code>const</code> cuando sea posible. Esto le indica al compilador y a otros programadores que la funci√≥n promete no modificar el objeto, una caracter√≠stica de seguridad avanzada de C++ que refuerza la robustez del sistema.</p>

            <h3>3.6.3 Perspectiva Pedag√≥gica: Educaci√≥n y Metodolog√≠as Activas</h3>
            <p>El <strong>Cuaderno de notebookLM sobre educaci√≥n y metodolog√≠as activas</strong> advierte sobre el peligro de ense√±ar estos conceptos como "c√≥digo repetitivo" (<em>boilerplate</em>). Muchos estudiantes ven los Getters y Setters como una molestia sint√°ctica. La metodolog√≠a activa propone que el estudiante se enfrente primero a un sistema que falla debido a datos inconsistentes (por ejemplo, un simulador de cajero autom√°tico que permite saldos negativos) para que, por descubrimiento, comprenda la necesidad del encapsulamiento.</p>
            
            <p>Ustedes, como ingenieros, deben evitar crear Getters y Setters de forma autom√°tica para cada variable sin pensar. El cuaderno de educaci√≥n enfatiza el dise√±o cr√≠tico: ¬øRealmente este dato debe ser modificado desde fuera? ¬øEs necesario que el mundo exterior conozca este valor? A veces, el mejor Getter es aquel que no existe, manteniendo el objeto como una verdadera "caja negra" que solo se comunica mediante comportamientos de alto nivel.</p>

            <h3>3.6.4 El Impacto en el Mantenimiento y la Evoluci√≥n</h3>
            <p>Finalmente, tanto <strong>O'Reilly</strong> como los cuadernos de <strong>Desarrollo Web</strong> coinciden en que el encapsulamiento facilita la evoluci√≥n del software. Si en el futuro decidimos cambiar c√≥mo se almacena un dato (por ejemplo, cambiar la nota de un <code>int</code> a un <code>float</code> o almacenarla en una base de datos remota), solo tendremos que modificar las funciones miembro internas de la clase. El resto del c√≥digo que utiliza <code>obtenerNota()</code> seguir√° funcionando sin cambios, ya que la interfaz p√∫blica permanece estable. Esta es la esencia de la arquitectura de software profesional: minimizar el impacto del cambio.</p>
            
            <p>En Argentina, la formaci√≥n de ingenieros en sistemas destaca esta capacidad de abstracci√≥n. Comprender que una clase no es un simple contenedor de variables, sino una entidad aut√≥noma con reglas propias, es lo que diferencia a un "codificador" de un arquitecto de software capaz de liderar proyectos de gran escala.</p>

            <button class="ref-btn" onclick="showRef('3.6')">Referencia Bibliogr√°fica</button>
        </section>

        <!-- 3.7 -->
		<section id="sec37">
            <h2><span class="icon">üÜï</span>3.7 Inicializaci√≥n de objetos mediante constructores</h2>
            
            <p>En el ciclo de vida de cualquier entidad de software, el momento de su creaci√≥n es cr√≠tico. Un <strong>constructor</strong> es una funci√≥n miembro especial que se ejecuta autom√°ticamente en el preciso instante en que se crea un objeto (instanciaci√≥n). Seg√∫n el PDF de <strong>Deitel</strong> (<em>C++ C√≥mo Programar</em>), el prop√≥sito primordial y fundamental de un constructor es asegurar que el objeto nazca en un <strong>estado v√°lido</strong>, inicializando sus miembros de datos con valores coherentes antes de que cualquier otra parte del programa intente interactuar con √©l.</p>

            <p>Desde una perspectiva t√©cnica, el constructor presenta caracter√≠sticas √∫nicas que lo distinguen de cualquier otra funci√≥n miembro: debe tener exactamente el mismo nombre que la clase y, lo m√°s importante, <strong>no posee tipo de retorno</strong> (ni siquiera <code>void</code>). Esta ausencia de tipo de retorno se debe a que el compilador invoca al constructor de manera impl√≠cita para configurar la memoria reci√©n reservada para el objeto, no para devolver un resultado al llamador.</p>

            <div class="code-block">
<pre>// Implementaci√≥n robusta siguiendo principios de Deitel y O'Reilly
#include &lt;iostream&gt;
#include &lt;string&gt;

class LibroCalificaciones {
public:
    // Constructor con par√°metro para inicializaci√≥n personalizada
    // Se recomienda usar el constructor para invocar a las funciones establecer (setters)
    LibroCalificaciones(std::string nombre) {
        establecerNombreCurso(nombre); // Reutilizamos l√≥gica de validaci√≥n
    }

    void establecerNombreCurso(std::string nombre) {
        // Aqu√≠ ir√≠a la validaci√≥n l√≥gica seg√∫n O'Reilly
        if (nombre.length() <= 25) {
            nombreCurso = nombre;
        } else {
            nombreCurso = nombre.substr(0, 25);
            std::cout << "Advertencia: Nombre limitado a 25 caracteres." << std::endl;
        }
    }

    std::string obtenerNombreCurso() const {
        return nombreCurso;
    }

private:
    std::string nombreCurso; // Miembro de datos privado
};</pre>
            </div>

            <h3>3.7.1 El Problema de los "Valores Basura" y la Seguridad</h3>
            <p>Basado en el PDF de <strong>O'Reilly</strong> (<em>Practical C++ Programming</em>), la importancia de definir constructores propios radica en la prevenci√≥n de estados indeterminados. En C++, las variables que no se inicializan expl√≠citamente contienen lo que se conoce como <span class="abbr" data-title="Valores Basura: Datos residuales que quedan en una direcci√≥n de memoria tras su uso anterior">valores basura</span>. Trabajar con un objeto cuyos atributos no han sido definidos es una fuente inagotable de errores l√≥gicos y vulnerabilidades de seguridad.</p>
            
            <p>Ustedes, como ingenieros, deben comprender que el constructor es su primera l√≠nea de defensa en la <strong>programaci√≥n defensiva</strong>. <strong>O'Reilly</strong> enfatiza que un objeto debe ser autosuficiente: no deber√≠a ser responsabilidad del usuario de la clase acordarse de llamar a una funci√≥n de "inicio" despu√©s de crear el objeto. El constructor garantiza que esta inicializaci√≥n sea at√≥mica y obligatoria.</p>

            <h3>3.7.2 Constructores Predeterminados y Sobrecarga</h3>
            <p>Si ustedes no definen un constructor en su clase, el compilador de C++ generar√° autom√°ticamente un <strong>constructor predeterminado</strong> que no recibe argumentos. Sin embargo, en el momento en que ustedes definen cualquier constructor (como el que recibe un <code>string</code>), el compilador deja de proporcionar el predeterminado. Esto es una exigencia acad√©mica com√∫n: deben ser conscientes de c√≥mo sus decisiones de dise√±o afectan la forma en que los objetos pueden ser creados.</p>

            <p>Siguiendo la teor√≠a de <strong>Deitel</strong>, es posible aplicar la <strong>sobrecarga de constructores</strong>. Esto permite que una clase tenga m√∫ltiples "puntos de entrada". Podr√≠amos tener un constructor sin par√°metros que asigne un nombre por defecto ("Sin nombre") y otro que acepte un par√°metro espec√≠fico. Desde el <strong>Cuaderno de notebookLM sobre UX UI</strong>, esto se traduce en una mejora en la <span class="abbr" data-title="Affordance: La cualidad de un objeto que sugiere c√≥mo debe ser usado">affordance</span> de nuestra clase: proporcionamos flexibilidad al desarrollador para instanciar objetos de la manera que mejor se adapte a su flujo de trabajo, manteniendo siempre la predictibilidad del sistema.</p>

            <h3>3.7.3 Metodolog√≠as Activas: El "Nacimiento" del Objeto</h3>
            <p>El <strong>Cuaderno de notebookLM sobre educaci√≥n y metodolog√≠as activas</strong> propone una analog√≠a poderosa para facilitar el aprendizaje constructivista: el constructor es como el acta de nacimiento de un ciudadano. Un ciudadano no puede existir en el sistema legal sin ciertos datos b√°sicos (nombre, fecha, lugar). De la misma manera, un objeto <code>LibroCalificaciones</code> no deber√≠a existir en nuestro sistema educativo sin un nombre de curso asignado.</p>
            
            <p>La metodolog√≠a activa sugiere que los estudiantes realicen un ejercicio de "dise√±o por contrato". Antes de codificar el constructor, deben definir: ¬øQu√© es lo m√≠nimo que mi objeto necesita para ser considerado 'v√°lido'? Esta reflexi√≥n previa evita el error com√∫n de crear clases "vac√≠as" que luego requieren m√∫ltiples llamadas a funciones <code>set</code> para funcionar correctamente. Este enfoque fomenta un aprendizaje basado en la resoluci√≥n de problemas de arquitectura de software.</p>

            <h3>3.7.4 Relaci√≥n con el Desarrollo Web y Ciclos de Vida</h3>
            <p>Aunque estamos estudiando C++, el concepto de inicializaci√≥n es universal. El <strong>Cuaderno de notebookLM sobre desarrollo web</strong> establece un paralelismo directo con los componentes de <em>frontend</em> modernos. En frameworks como React o Angular, el constructor (o los hooks de inicializaci√≥n como <code>ngOnInit</code>) cumplen la misma funci√≥n: configurar el estado inicial del componente antes de que sea renderizado en el navegador.</p>
            
            <p>Comprender los constructores en C++ les da una ventaja competitiva en la web, ya que les ense√±a a pensar en el <strong>ciclo de vida</strong> de los componentes. Un componente que no se inicializa correctamente provocar√° errores de "undefined" en la interfaz de usuario, lo cual es el equivalente web a los "valores basura" de C++. La rigurosidad que aprenden aqu√≠ se traduce en aplicaciones web m√°s estables y profesionales.</p>

            <h3>3.7.5 La Lista de Inicializaci√≥n de Miembros: Una Buena Pr√°ctica</h3>
            <p>Un detalle t√©cnico avanzado, resaltado tanto por <strong>Deitel</strong> como por <strong>O'Reilly</strong>, es el uso de la <strong>lista de inicializaci√≥n de miembros</strong>. En lugar de asignar valores dentro del cuerpo de las llaves, C++ permite inicializar los atributos antes de que el cuerpo del constructor se ejecute. Esto es no solo m√°s eficiente en t√©rminos de rendimiento, sino que en algunos casos (como con miembros constantes o referencias) es la √∫nica forma legal de hacerlo.</p>
            
            <div class="code-block">
<pre>// Ejemplo de lista de inicializaci√≥n (Best Practice)
LibroCalificaciones(std::string nombre) 
    : nombreCurso(nombre) // Inicializaci√≥n directa
{
    // El cuerpo puede quedar vac√≠o o usarse para validaciones extra
}</pre>
            </div>

            <p>En conclusi√≥n, el dominio de los constructores separa al programador novato del ingeniero de software. Como futuros profesionales, su meta es dise√±ar sistemas donde los objetos sean ciudadanos responsables que nunca entren en escena sin estar debidamente preparados. El constructor es el guardi√°n de esa integridad, asegurando que la complejidad de sus sistemas se mantenga bajo control desde el primer byte de existencia de cada objeto.</p>

            <div class="note-box">
                <strong>üí° Nota de Ingenier√≠a:</strong> Un error frecuente en ex√°menes es intentar llamar al constructor expl√≠citamente sobre un objeto ya existente. Recuerden: el constructor solo se ejecuta <strong>una vez</strong> durante la creaci√≥n. Para cambiar el estado despu√©s, deben usar funciones <code>set</code>.
            </div>

            <button class="ref-btn" onclick="showRef('3.7')">Referencia Bibliogr√°fica</button>
        </section>

        <!-- 3.8 -->
		<section id="sec38">
            <h2><span class="icon">üìÅ</span>3.8 Colocar una clase en un archivo separado para fines de reutilizaci√≥n</h2>
            
            <p>En el desarrollo de software industrial y profesional, la organizaci√≥n del c√≥digo es tan cr√≠tica como su l√≥gica interna. Siguiendo las directrices del PDF de <strong>Deitel</strong> (<em>C++ C√≥mo Programar</em>), no es una pr√°ctica aceptable colocar todas las definiciones en el archivo <code>main.cpp</code>. En su lugar, dividimos el software en unidades modulares: archivos de cabecera (interfaz) y archivos de c√≥digo fuente (implementaci√≥n). Este enfoque no solo facilita la <strong>reutilizaci√≥n de c√≥digo</strong>, sino que permite que los sistemas escalen de manera sostenible, permitiendo que un equipo de ingenieros trabaje simult√°neamente en diferentes m√≥dulos sin interferencias.</p>

            <h3>3.8.1 La Arquitectura de la Separaci√≥n: Interfaz vs. Implementaci√≥n</h3>
            <p>De acuerdo con <strong>O'Reilly</strong> (<em>Practical C++ Programming</em>), la separaci√≥n f√≠sica de los archivos refleja una separaci√≥n l√≥gica de responsabilidades. Esta estructura se divide tradicionalmente en dos componentes:</p>
            <ul>
                <li><strong>El Archivo de Cabecera (<code>.h</code> o <code>.hpp</code>):</strong> Contiene la <strong>definici√≥n de la clase</strong>. Act√∫a como el "qu√©" hace la clase. Es el contrato que el resto del programa ve. Seg√∫n el <strong>Cuaderno de notebookLM sobre UX UI</strong>, un archivo de cabecera bien dise√±ado debe ser una pieza de comunicaci√≥n clara; debe mostrar los m√©todos p√∫blicos de manera que su uso sea autoevidente, reduciendo la <span class="abbr" data-title="Carga Cognitiva: Cantidad de esfuerzo mental utilizado en la memoria de trabajo">carga cognitiva</span> del desarrollador que lo integra.</li>
                <li><strong>El Archivo de Implementaci√≥n (<code>.cpp</code>):</strong> Contiene las definiciones detalladas de las funciones miembro. Es el "c√≥mo" se realizan las tareas. Al ocultar estos detalles en un archivo separado, aplicamos el principio de <strong>encapsulamiento</strong> a nivel de sistema de archivos, protegiendo la propiedad intelectual y evitando que cambios menores en la l√≥gica requieran recompilar todo el proyecto.</li>
            </ul>

            <div class="note-box">
                <strong>üí° Perspectiva de Dise√±o (DX):</strong> El <strong>Cuaderno de UX UI</strong> introduce el concepto de <em>Developer Experience</em> (DX). Un archivo <code>.h</code> saturado de comentarios innecesarios o l√≥gica mezclada ensucia el <span class="abbr" data-title="Modelo Mental: Representaci√≥n interna que una persona tiene sobre c√≥mo funciona algo">modelo mental</span> del programador. La elegancia en la separaci√≥n de archivos es una forma de dise√±o de interfaz para colegas ingenieros.
            </div>

            <h3>3.8.2 Directivas del Preprocesador y Guardas de Inclusi√≥n</h3>
            <p>Para integrar estos archivos, utilizamos la directiva <code>#include</code>. Es vital notar la diferencia sint√°ctica: usamos <code>#include &lt;iostream&gt;</code> (con par√©ntesis angulares) para bibliotecas est√°ndar del compilador, pero empleamos <code>#include "LibroCalificaciones.h"</code> (con comillas) para nuestros propios archivos. Como se√±ala <strong>Deitel</strong>, las comillas le indican al preprocesador que inicie la b√∫squeda en el directorio local del proyecto.</p>
            
            <p>Un problema t√©cnico recurrente mencionado por <strong>O'Reilly</strong> es la "doble inclusi√≥n". Si dos archivos incluyen la misma cabecera, el compilador ver√° dos definiciones de la misma clase y arrojar√° un error. Para evitar esto, es obligatorio el uso de las <strong>guardas de preprocesador</strong>:</p>

            <div class="code-block">
<pre>// Estructura est√°ndar recomendada por O'Reilly y Deitel
#ifndef LIBROCALIFICACIONES_H
#define LIBROCALIFICACIONES_H

#include &lt;string&gt;

class LibroCalificaciones {
    // Definici√≥n de la clase...
};

#endif</pre>
            </div>

            <h3>3.8.3 Conexi√≥n con el Desarrollo Web y la Modularidad Moderna</h3>
            <p>El <strong>Cuaderno de notebookLM sobre desarrollo web</strong> establece un paralelismo directo entre esta pr√°ctica de C++ y el sistema de m√≥dulos de JavaScript (ESM). En el desarrollo web moderno, dividimos la l√≥gica en archivos <code>.js</code> o <code>.ts</code> independientes que luego se importan donde se necesitan. La filosof√≠a es la misma: crear componentes at√≥micos, testeables y reutilizables.</p>
            
            <p>En el √°mbito web, esta modularidad permite la carga bajo demanda y mejora el rendimiento. En C++, la separaci√≥n permite la <strong>compilaci√≥n independiente</strong>: si solo modificamos el archivo <code>.cpp</code> de una clase, no necesitamos recompilar el resto del sistema, solo vincularlo (<em>linking</em>) nuevamente. Esta eficiencia es lo que permite a C++ dominar en entornos de alto rendimiento como motores de navegadores o infraestructuras de servidores cr√≠ticos.</p>

            <h3>3.8.4 Metodolog√≠as Activas y Pensamiento Sist√©mico</h3>
            <p>Desde el <strong>Cuaderno de notebookLM sobre educaci√≥n y metodolog√≠as activas</strong>, el ejercicio de separar una clase en archivos distintos se considera un paso fundamental hacia el <strong>pensamiento sist√©mico</strong>. Los estudiantes suelen percibir esto inicialmente como una complicaci√≥n innecesaria (un "obst√°culo pedag√≥gico"). Sin embargo, la metodolog√≠a activa propone que el alumno intente reutilizar una clase que est√° "atrapada" en un archivo <code>main.cpp</code> de otro proyecto.</p>
            
            <p>Al enfrentarse a la tarea de copiar y pegar c√≥digo (y los errores que esto conlleva), el estudiante descubre por s√≠ mismo la necesidad de la modularizaci√≥n. Este es un ejemplo de <strong>aprendizaje basado en problemas</strong> (ABP). La capacidad de ver el software como un conjunto de piezas de LEGO que se ensamblan es la marca de un ingeniero capacitado para el trabajo en equipo y la producci√≥n industrial de software en Argentina y el mundo.</p>

            <h3>3.8.5 El Proceso de Construcci√≥n (Build Process)</h3>
            <p>Finalmente, es crucial entender que el compilador no "lee" los archivos de forma aislada por arte de magia. Como explica <strong>Deitel</strong>, cada archivo <code>.cpp</code> se compila en un archivo objeto (<code>.obj</code> o <code>.o</code>). Luego, una herramienta llamada <strong>enlazador</strong> (<em>linker</em>) une todos estos fragmentos junto con las librer√≠as del sistema para generar el ejecutable final. Ustedes, como futuros profesionales, deben dominar este flujo de trabajo para diagnosticar errores de vinculaci√≥n, que son comunes cuando declaramos una funci√≥n en el <code>.h</code> pero olvidamos definirla en el <code>.cpp</code>.</p>

            <div class="diagram">
                <div class="box">main.cpp<br><small>(L√≥gica del programa)</small></div>
                <div class="arrow">‚¨á #include "Clase.h"</div>
                <div class="box">Clase.h<br><small>(Interfaz / Contrato)</small></div>
                <div class="arrow">‚¨Ü Implementa</div>
                <div class="box">Clase.cpp<br><small>(Detalles t√©cnicos)</small></div>
            </div>

            <p>En conclusi√≥n, colocar una clase en un archivo separado no es solo una cuesti√≥n de orden; es una decisi√≥n de dise√±o que impacta en la velocidad de desarrollo, la facilidad de mantenimiento y la claridad del sistema. Siguiendo los principios de <strong>Deitel</strong> y la practicidad de <strong>O'Reilly</strong>, estamos construyendo cimientos s√≥lidos para cualquier aplicaci√≥n de ingenier√≠a, desde una simple herramienta de consola hasta un motor gr√°fico complejo o un sistema de gesti√≥n web de alto tr√°fico.</p>

            <button class="ref-btn" onclick="showRef('3.8')">Referencia Bibliogr√°fica</button>
        </section>

        <!-- 3.9 -->
		<section id="sec39">
            <h2><span class="icon">üîå</span>3.9 Separar la interfaz de la implementaci√≥n</h2>
            
            <p>La culminaci√≥n del dise√±o profesional en C++ se alcanza mediante la separaci√≥n estricta de la <strong>interfaz</strong> y la <strong>implementaci√≥n</strong>. Este principio, pilar de la ingenier√≠a de software moderna, establece que la interfaz le dice al usuario (o a otros desarrolladores) <em>qu√©</em> hace la clase, mientras que la implementaci√≥n describe <em>c√≥mo</em> lo hace. Basado en el texto de <strong>O'Reilly</strong> (<em>Practical C++ Programming</em>), esta distinci√≥n es lo que permite que el software sea verdaderamente robusto: permite cambiar la l√≥gica interna de un m√≥dulo sin que los usuarios de la clase (el c√≥digo cliente) tengan que modificar o siquiera conocer esos cambios.</p>

            <div class="diagram">
                <div class="box">
                    <strong>Archivo de Cabecera (.h)</strong><br>
                    <small>La Interfaz (El "Qu√©")</small><br>
                    <hr>
                    <small>Prototipos, Firmas y Atributos</small>
                </div>
                <div class="arrow">‚ÜîÔ∏è Desacoplamiento ‚ÜîÔ∏è</div>
                <div class="box">
                    <strong>Archivo de Fuente (.cpp)</strong><br>
                    <small>La Implementaci√≥n (El "C√≥mo")</small><br>
                    <hr>
                    <small>L√≥gica de algoritmos y c√°lculos</small>
                </div>
            </div>

            <h3>3.9.1 El Contrato de la Interfaz (.h)</h3>
            <p>Seg√∫n el PDF de <strong>Deitel</strong> (<em>C++ C√≥mo Programar</em>), el archivo de cabecera es el "contrato" de la clase. En √©l se declaran los prototipos de las funciones miembro y los miembros de datos. Desde la perspectiva del <strong>Cuaderno de notebookLM sobre UX UI</strong>, la interfaz de una clase debe tratarse como un dise√±o orientado al usuario (en este caso, el desarrollador). Una interfaz clara tiene una alta <span class="abbr" data-title="Affordance: Propiedad de un objeto que sugiere c√≥mo debe ser usado">affordance</span>: al leer el archivo <code>.h</code>, el programador deber√≠a entender inmediatamente c√≥mo interactuar con el objeto sin necesidad de navegar por cientos de l√≠neas de l√≥gica compleja.</p>
            
            <p><strong>Deitel</strong> resalta que ocultar la implementaci√≥n en un archivo separado promueve la reutilizaci√≥n de software en forma de <strong>objetos binarios</strong>. En la industria, una empresa puede proporcionar el archivo de cabecera (para que el cliente sepa qu√© funciones llamar) y el archivo objeto ya compilado, protegiendo as√≠ su propiedad intelectual (el c√≥digo fuente de la implementaci√≥n) mientras permite que otros integren su tecnolog√≠a.</p>

            <h3>3.9.2 El Operador de Resoluci√≥n de √Åmbito (<code>::</code>)</h3>
            <p>Para que la separaci√≥n sea efectiva, el archivo de implementaci√≥n (<code>.cpp</code>) debe "reclamar" las funciones que pertenecen a la clase definida en la cabecera. Aqu√≠ es donde entra en juego el <strong>Operador de Resoluci√≥n de √Åmbito</strong> (<code>::</code>). Como explica <strong>O'Reilly</strong>, este operador vincula el nombre de la funci√≥n miembro con el nombre de la clase, indicando al compilador que dicha funci√≥n no es una funci√≥n global, sino que tiene acceso a los miembros privados de la entidad correspondiente.</p>

            <div class="code-block">
<pre>// Ejemplo de implementaci√≥n t√©cnica profesional
#include "LibroCalificaciones.h" // Incluimos la interfaz
#include &lt;iostream&gt;

using namespace std;

// El operador :: vincula la funci√≥n a la clase
void LibroCalificaciones::mostrarMensaje() const {
    cout << "Bienvenido al curso: " << obtenerNombreCurso() << "!" << endl;
}</pre>
            </div>

            <h3>3.9.3 Perspectiva de Desarrollo Web: Microservicios y Componentes</h3>
            <p>El <strong>Cuaderno de notebookLM sobre desarrollo web</strong> establece una analog√≠a fascinante: separar la interfaz de la implementaci√≥n en C++ es el precursor ideol√≥gico de la arquitectura de <strong>Microservicios</strong> y el desarrollo basado en componentes (como en React). En la web, el <em>frontend</em> consume una API (interfaz) sin saber si el <em>backend</em> est√° escrito en Node.js, Python o C++ (implementaci√≥n). Esta abstracci√≥n permite que el equipo de <em>backend</em> optimice sus algoritmos o cambie su base de datos sin romper la experiencia del usuario en el navegador.</p>
            
            <p>Ustedes, como ingenieros, deben ver el archivo <code>.h</code> como la documentaci√≥n t√©cnica de su API y el <code>.cpp</code> como el motor oculto. Si dise√±an sus clases de esta manera, est√°n facilitando la creaci√≥n de sistemas distribuidos y escalables, reduciendo el acoplamiento y aumentando la estabilidad del ecosistema de software completo.</p>

            <h3>3.9.4 Metodolog√≠as Activas: El Andamiaje de la Complejidad</h3>
            <p>Desde el punto de vista del <strong>Cuaderno de notebookLM sobre educaci√≥n y metodolog√≠as activas</strong>, la ense√±anza de esta separaci√≥n debe ser gradual. El cuaderno sugiere que el "salto" de un solo archivo a m√∫ltiples archivos representa una <span class="abbr" data-title="Carga Cognitiva Externa: Esfuerzo mental impuesto por la forma en que se presenta la informaci√≥n">Carga Cognitiva Externa</span> considerable. Por ello, se recomienda la t√©cnica de <em>andamiaje</em> (scaffolding): primero consolidar la l√≥gica en un solo archivo y luego realizar una refactorizaci√≥n guiada hacia la separaci√≥n f√≠sica.</p>
            
            <p>Esta pr√°ctica fomenta el <strong>aprendizaje significativo</strong> al obligar al estudiante a reflexionar sobre la visibilidad. ¬øQu√© funciones deben ser p√∫blicas en el <code>.h</code> y cu√°les deben ser funciones de utilidad privadas en el <code>.cpp</code>? Esta toma de decisiones es la esencia del dise√±o de ingenier√≠a y lo que diferencia a un programador de un arquitecto de sistemas.</p>

            <h3>3.9.5 Ventajas de Mantenimiento y Compilaci√≥n</h3>
            <p>Finalmente, <strong>Deitel</strong> y <strong>O'Reilly</strong> coinciden en una ventaja t√©cnica fundamental: la <strong>velocidad de compilaci√≥n</strong>. En proyectos masivos, si cambiamos la implementaci√≥n de una funci√≥n en el archivo <code>.cpp</code>, solo es necesario recompilar ese archivo espec√≠fico y luego volver a enlazarlo (<em>link</em>). Si todo estuviera en un √∫nico archivo de cabecera, cada peque√±o cambio obligar√≠a a recompilar todas las partes del proyecto que incluyen esa clase, lo que en sistemas industriales podr√≠a tomar horas.</p>

            <p>Como futuros ingenieros en Argentina, dominar esta separaci√≥n les permitir√° integrarse en equipos de desarrollo internacionales, donde los est√°ndares de c√≥digo exigen una modularidad absoluta. La elegancia de C++ reside en que nos da el control para decidir exactamente qu√© queremos exponer y qu√© queremos proteger, garantizando que nuestro software no solo funcione hoy, sino que sea capaz de evolucionar ma√±ana sin colapsar bajo su propia complejidad.</p>

            <div class="note-box">
                <strong>üí° Regla de Oro de O'Reilly:</strong> "Nunca pongas c√≥digo ejecutable en un archivo de cabecera a menos que sea una funci√≥n inline o una plantilla. El <code>.h</code> es para declaraciones, el <code>.cpp</code> es para la acci√≥n".
            </div>

            <button class="ref-btn" onclick="showRef('3.9')">Referencia Bibliogr√°fica</button>
        </section>

        <!-- 3.10 -->
		<section id="sec310">
            <h2><span class="icon">‚úÖ</span>3.10 Validaci√≥n de datos mediante funciones establecer</h2>
            
            <p>En la ingenier√≠a de software, la <strong>validaci√≥n de datos</strong> no es una tarea secundaria, sino el guardi√°n fundamental de la integridad de un sistema. No basta con que un objeto reciba un valor; es imperativo verificar que dicho valor sea coherente con las reglas de negocio y los l√≠mites f√≠sicos de la memoria. Seg√∫n el PDF de <strong>Deitel</strong> (<em>C++ C√≥mo Programar</em>), la funci√≥n establecer (<em>setter</em>) es el lugar ideal y arquitect√≥nicamente correcto para aplicar esta l√≥gica. El objetivo es que el objeto mantenga siempre un "estado consistente", impidiendo que datos err√≥neos se propaguen por el resto de la aplicaci√≥n.</p>

            <p>Ustedes deben comprender que un objeto es una entidad aut√≥noma responsable de su propia salud. Si permitimos que un objeto entre en un estado inv√°lido (por ejemplo, una fecha como 31 de febrero o una calificaci√≥n de 150 sobre 100), estamos sembrando la semilla de un fallo sist√©mico que ser√° extremadamente dif√≠cil de depurar en etapas posteriores. Deitel denomina a esto "verificaci√≥n de validez" y la considera una de las ventajas primordiales del <span class="abbr" data-title="Encapsulamiento: Agrupamiento de datos y m√©todos que protege el estado interno de un objeto">encapsulamiento</span>.</p>

            <div class="code-block">
<pre>// Implementaci√≥n t√©cnica de validaci√≥n profesional
#include &lt;iostream&gt;
#include &lt;string&gt;

void LibroCalificaciones::establecerNombreCurso(std::string nombre) {
    // La validaci√≥n protege la integridad del objeto
    if (nombre.length() <= 25) {
        nombreCurso = nombre; // El dato es v√°lido y se asigna
    } else {
        // Estrategia de sanitizaci√≥n sugerida por Deitel y O'Reilly
        nombreCurso = nombre.substr(0, 25); // Se recortan los caracteres excedentes
        
        // El feedback es crucial para el desarrollador (UX de c√≥digo)
        std::cerr << "ADVERTENCIA: El nombre '" << nombre 
                  << "' excede el limite de 25 caracteres.\n"
                  << "Se ha truncado a: " << nombreCurso << std::endl;
    }
}</pre>
            </div>

            <h3>3.10.1 Programaci√≥n Defensiva y el Enfoque Pr√°ctico de O'Reilly</h3>
            <p>Basado en el PDF de <strong>O'Reilly</strong> (<em>Practical C++ Programming</em>), la validaci√≥n dentro de los <em>setters</em> es la piedra angular de la <strong>programaci√≥n defensiva</strong>. O'Reilly argumenta que el software profesional debe estar dise√±ado bajo la premisa de que "si algo puede salir mal, saldr√° mal". Por lo tanto, el c√≥digo no solo debe manejar el flujo feliz de los datos, sino prever activamente las entradas incorrectas o malintencionadas.</p>
            
            <p>En el ejemplo del <code>LibroCalificaciones</code>, el uso de la funci√≥n <code>substr(0, 25)</code> es una t√©cnica de <strong>sanitizaci√≥n</strong>. A diferencia de una validaci√≥n que simplemente rechaza el dato, la sanitizaci√≥n intenta "curar" la entrada para que sea aceptable. Sin embargo, O'Reilly advierte que esta decisi√≥n debe ser comunicada. Silenciar un error de truncamiento puede llevar a que un usuario se pregunte por qu√© su curso de "Programaci√≥n de Sistemas Empotrados en C++" ahora se llama "Programaci√≥n de Sistemas Em", generando confusi√≥n y errores de UX.</p>

            <h3>3.10.2 UX de C√≥digo: El Feedback al Programador</h3>
            <p>Integrando el <strong>Cuaderno de notebookLM sobre UX UI</strong>, debemos entender que el programador que utiliza nuestra clase es nuestro "usuario". Cuando una validaci√≥n falla, la forma en que el sistema responde define la <span class="abbr" data-title="Developer Experience: Facilidad con la que un desarrollador puede trabajar con una API o librer√≠a">DX (Developer Experience)</span>. El cuaderno resalta que un error silencioso es el peor enemigo del dise√±o. Si una clase rechaza un valor sin dar una se√±al clara, el desarrollador experimentar√° una alta <span class="abbr" data-title="Carga Cognitiva: Esfuerzo mental requerido para comprender y operar un sistema">carga cognitiva</span> intentando adivinar por qu√© el objeto no se actualiza.</p>
            
            <p>Por ello, en el c√≥digo superior se utiliza <code>std::cerr</code> (flujo de error est√°ndar). Seg√∫n el cuaderno de UX UI, los mensajes de error deben ser:</p>
            <ul>
                <li><strong>Descriptivos:</strong> Indicar exactamente qu√© regla se rompi√≥.</li>
                <li><strong>Accionables:</strong> Sugerir c√≥mo corregir el dato (ej. "m√°ximo 25 caracteres").</li>
                <li><strong>Ubicables:</strong> Facilitar la identificaci√≥n de en qu√© parte del c√≥digo ocurri√≥ la falla.</li>
            </ul>

            <h3>3.10.3 Perspectiva de Desarrollo Web: Validaci√≥n de Capas</h3>
            <p>Desde la √≥ptica del <strong>Cuaderno de notebookLM sobre desarrollo web</strong>, la l√≥gica de validaci√≥n en las clases de C++ es an√°loga a la validaci√≥n en el <em>backend</em> de una aplicaci√≥n web. El cuaderno enfatiza que no se debe confiar nunca en los datos provenientes del cliente (el <em>frontend</em>). As√≠ como un formulario web puede ser "saltado" por un atacante, un objeto en C++ puede recibir datos de fuentes no seguras (archivos, red, entrada de usuario).</p>
            
            <p>La validaci√≥n en el <em>setter</em> act√∫a como la √∫ltima l√≠nea de defensa. En el desarrollo web profesional, esto se conoce como la aplicaci√≥n de "reglas de negocio". Si una regla dicta que el nombre de un curso no debe ser demasiado largo para evitar problemas de visualizaci√≥n en la base de datos o en la interfaz, el <em>setter</em> es quien garantiza que esa restricci√≥n se cumpla de manera centralizada. Si el d√≠a de ma√±ana la restricci√≥n cambia de 25 a 50 caracteres, solo modificaremos un archivo (la clase), no cada lugar donde se pide el nombre al usuario.</p>

            <h3>3.10.4 Metodolog√≠as Activas: Aprender a trav√©s del "Fallo Controlado"</h3>
            <p>El <strong>Cuaderno de notebookLM sobre educaci√≥n y metodolog√≠as activas</strong> sugiere que la validaci√≥n es un concepto ideal para el aprendizaje por descubrimiento. En lugar de simplemente explicar la teor√≠a, se propone que los estudiantes intenten "romper" sus propios programas. Al ingresar un nombre de 100 caracteres y observar c√≥mo el programa se comporta mal (o se corta), el alumno comprende la necesidad de la validaci√≥n no como una regla arbitraria del profesor, sino como una necesidad de ingenier√≠a.</p>
            
            <p>La metodolog√≠a activa fomenta el <strong>pensamiento cr√≠tico</strong>: el estudiante debe decidir qu√© estrategia es mejor. ¬øDebo usar <code>substr</code> para recortar? ¬øDebo lanzar una excepci√≥n? ¬øDebo dejar el valor anterior si el nuevo es inv√°lido? Estas no son preguntas t√©cnicas, sino decisiones de dise√±o. El cuaderno de educaci√≥n recalca que estas discusiones en clase son las que forman la mentalidad del futuro ingeniero, quien entiende que programar es, ante todo, tomar decisiones fundamentadas.</p>

            <h3>3.10.5 Integridad de Datos y Robustez Sist√©mica</h3>
            <p>Para concluir, la validaci√≥n en funciones establecer, como proponen <strong>Deitel</strong> y <strong>O'Reilly</strong>, es lo que transforma un conjunto de variables en un componente de software industrial. Al encapsular la validaci√≥n, estamos protegiendo al sistema de la entrop√≠a. Un sistema con clases que se validan a s√≠ mismas es un sistema robusto, f√°cil de testear y, lo m√°s importante, predecible.</p>
            
            <p>En Argentina, la formaci√≥n de ingenieros destaca esta responsabilidad √©tica del programador: el c√≥digo debe ser s√≥lido. Ustedes ver√°n que, a medida que sus proyectos crezcan en complejidad, agradecer√°n haber invertido tiempo en estas peque√±as "cerraduras de seguridad" en cada una de sus clases. El <code>LibroCalificaciones</code> es solo el comienzo; en sistemas reales de control industrial, finanzas o salud, una validaci√≥n fallida en un <em>setter</em> puede ser la diferencia entre un sistema exitoso y un desastre tecnol√≥gico catastr√≥fico.</p>

            <button class="ref-btn" onclick="showRef('3.10')">Referencia Bibliogr√°fica</button>
        </section>

        <!-- 3.11 -->
		<section id="sec311">
		<h2><span class="icon">üèß</span>3.11 (Opcional) Ejemplo pr√°ctico: identificaci√≥n de las clases en el ATM</h2>

        <p>En la ingenier√≠a de software, la transici√≥n del lenguaje natural al c√≥digo es uno de los desaf√≠os m√°s cr√≠ticos. Seg√∫n el PDF de <strong>Deitel</strong> (<em>C++ C√≥mo Programar</em>), el proceso de dise√±o comienza con un an√°lisis detallado de los requerimientos para identificar las entidades que compondr√°n el sistema. Una t√©cnica fundamental para este fin es la <strong>identificaci√≥n de sustantivos</strong>. Imaginemos que el cliente nos entrega el siguiente requerimiento: <em>"Un usuario se acerca al cajero autom√°tico, introduce su tarjeta, el sistema valida su identidad y luego el usuario retira dinero de su cuenta consultando el saldo disponible"</em>.</p>

        <h3>3.11.1 An√°lisis Ling√º√≠stico y Modelado de Clases</h3>
        <p>Bajo la metodolog√≠a de <strong>Deitel</strong>, el primer paso es extraer los sustantivos y verbos del relato. Los sustantivos representan los candidatos a ser <strong>Clases</strong>, mientras que los verbos sugieren las <strong>Funciones Miembro</strong>. Este proceso no es autom√°tico; requiere un juicio de ingenier√≠a para filtrar qu√© entidades son relevantes para el dominio del problema.</p>

        <div class="table-responsive">
            <table>
                <thead>
                    <tr>
                        <th>Categor√≠a Gramatical</th>
                        <th>Candidatos Identificados</th>
                        <th>Rol en la <span class="abbr" data-title="POO: Programaci√≥n Orientada a Objetos">POO</span></th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Sustantivos</strong></td>
                        <td>Cajero (ATM), Usuario, Tarjeta, Cuenta, Dinero, Pantalla, Teclado.</td>
                        <td><strong>Clases:</strong> Representan las entidades con estado y comportamiento.</td>
                    </tr>
                    <tr>
                        <td><strong>Verbos</strong></td>
                        <td>Retirar, Validar, Consultar, Introducir, Dispensar.</td>
                        <td><strong>Funciones Miembro:</strong> Definen las acciones que los objetos pueden realizar.</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <h3>3.11.2 La Perspectiva de Dise√±o Industrial (O'Reilly)</h3>
        <p><strong>O'Reilly</strong> (<em>Practical C++ Programming</em>) complementa este enfoque se√±alando que el dise√±o de un sistema como un ATM debe ser modular y resistente a fallos. No basta con identificar la clase <code>Cajero</code>; debemos pensar en la <strong>composici√≥n</strong>. Un <code>ATM</code> no <em>es</em> una <code>Pantalla</code>, sino que <em>tiene</em> una <code>Pantalla</code> y <em>tiene</em> un <code>Dispensador</code>. Esta distinci√≥n es vital para la reutilizaci√≥n: si el banco decide cambiar el modelo de pantalla por uno t√°ctil, solo deber√≠amos modificar la clase <code>Pantalla</code>, manteniendo intacta la l√≥gica de la clase <code>Cajero</code>.</p>

        <p>Ustedes, como futuros profesionales, deben evitar la creaci√≥n de "clases Dios" (clases que hacen todo). <strong>O'Reilly</strong> advierte que la robustez proviene de distribuir responsabilidades. Por ejemplo, la validaci√≥n del PIN no deber√≠a ser responsabilidad de la clase <code>Teclado</code>, sino de la clase <code>BaseDeDatosBanco</code> o de la entidad <code>Cuenta</code>.</p>

        <h3>3.11.3 Metodolog√≠as Activas: El Modelado como Proceso Social</h3>
        <p>El <strong>Cuaderno de notebookLM sobre educaci√≥n y metodolog√≠as activas</strong> sugiere que la identificaci√≥n de clases en un ATM es un escenario ideal para el <strong>Aprendizaje Basado en Problemas (ABP)</strong>. En lugar de recibir la soluci√≥n terminada, la metodolog√≠a activa propone que ustedes realicen una "simulaci√≥n de roles". Al actuar como las diferentes piezas del cajero, los estudiantes descubren qu√© informaci√≥n necesita cada objeto para cumplir su funci√≥n. Esta t√©cnica de <em>andamiaje cognitivo</em> facilita la comprensi√≥n de conceptos abstractos como la <span class="abbr" data-title="Encapsulaci√≥n: Ocultamiento de la complejidad interna de un objeto">encapsulaci√≥n</span>.</p>
        
        <p>En las universidades argentinas, este ejercicio suele acompa√±arse de debates sobre la <strong>cohesi√≥n</strong>. Si la clase <code>Cajero</code> intenta manejar la impresi√≥n del recibo y la validaci√≥n de la tarjeta al mismo tiempo, estamos ante una baja cohesi√≥n. El cuaderno de educaci√≥n resalta que el aprendizaje significativo ocurre cuando el alumno comprende que una clase bien dise√±ada debe tener una √∫nica responsabilidad clara.</p>

        <h3>3.11.4 UX/UI en el Dise√±o de Sistemas Cr√≠ticos</h3>
        <p>Integrando el <strong>Cuaderno de notebookLM sobre UX UI</strong>, debemos recordar que un ATM es, ante todo, una interfaz humana. Las clases <code>Pantalla</code> y <code>Teclado</code> no son solo perif√©ricos; son los puntos de contacto que determinan la <span class="abbr" data-title="Carga Cognitiva: Esfuerzo mental requerido para completar una tarea">carga cognitiva</span> del usuario. Un dise√±o de software deficiente en estas clases puede inducir a errores costosos (ej. retirar una cantidad de dinero equivocada).</p>
        
        <p>Desde la UX, cada funci√≥n miembro como <code>mostrarMenu()</code> debe estar dise√±ada pensando en la claridad y la accesibilidad. Si el sistema de software tarda demasiado en procesar un comando (debido a una mala implementaci√≥n de las funciones miembro en el <em>backend</em>), la experiencia del usuario se degrada. El cuaderno de UX UI enfatiza que el dise√±o orientado a objetos debe facilitar un flujo de interacci√≥n fluido y libre de ambig√ºedades.</p>

        <h3>3.11.5 Paralelismo con el Desarrollo Web Moderno</h3>
        <p>Aunque el ATM es un dispositivo f√≠sico, su arquitectura de software es la base de las aplicaciones web transaccionales. El <strong>Cuaderno de notebookLM sobre desarrollo web</strong> menciona que las clases identificadas en este ejemplo (<code>Usuario</code>, <code>Cuenta</code>, <code>Transaccion</code>) son las mismas que encontramos en el <em>backend</em> de un <em>home banking</em> o una billetera virtual. La separaci√≥n entre la interfaz (el cajero) y la l√≥gica de negocio (el servidor del banco) es un precursor directo del modelo Cliente-Servidor que domina la web actual.</p>
        
        <p>Comprender c√≥mo C++ gestiona estos objetos a bajo nivel les da una ventaja competitiva √∫nica para optimizar procesos cr√≠ticos de concurrencia y seguridad en la nube, donde miles de "objetos ATM" virtuales interact√∫an simult√°neamente con una base de datos centralizada.</p>

        <h3>3.11.6 Hacia el Diagrama UML Profesional</h3>
        <p>Finalmente, este an√°lisis de sustantivos y verbos se vuelca en un diagrama <span class="abbr" data-title="UML: Unified Modeling Language. Est√°ndar visual para especificar sistemas de software">UML</span>. <strong>Deitel</strong> explica que el UML es el lenguaje universal de los ingenieros de software. En un diagrama de clases, ver√°n cajas que representan sus sustantivos, con sus atributos (datos) en la parte superior y sus funciones miembro (verbos) en la inferior, conectadas por l√≠neas que indican c√≥mo interact√∫an.</p>

        <div class="code-block">


<pre>// Pseudo-c√≥digo de la estructura identificada
class CajeroAutomatico {
public:
void ejecutar(); // Funci√≥n principal (Verbo)
private:
Pantalla pantalla;       // Composici√≥n (Sustantivo)
Teclado teclado;         // Composici√≥n (Sustantivo)
DispensadorEfectivo dispensador; // Composici√≥n
};</pre>

        </div>

        <p>En conclusi√≥n, el ejemplo del ATM no es solo una curiosidad acad√©mica; es el laboratorio donde se forja el criterio del ingeniero. Al separar correctamente las clases y sus funciones, como proponen <strong>Deitel</strong> y <strong>O'Reilly</strong>, estamos creando un sistema escalable, seguro y f√°cil de mantener, pilares indiscutibles de la ingenier√≠a de software profesional.</p>

        <button class="ref-btn" onclick="showRef('3.11')">Referencia Bibliogr√°fica</button>
    </section>
	
	

        <!-- 3.12 -->
<section id="sec311">
<h2><span class="icon">üèß</span>3.11 (Opcional) Ejemplo pr√°ctico: identificaci√≥n de las clases en el ATM</h2>

<p>En la ingenier√≠a de software, la transici√≥n del lenguaje natural al c√≥digo es uno de los desaf√≠os m√°s cr√≠ticos. Seg√∫n el PDF de <strong>Deitel</strong> (<em>C++ C√≥mo Programar</em>), el proceso de dise√±o comienza con un an√°lisis detallado de los requerimientos para identificar las entidades que compondr√°n el sistema. Una t√©cnica fundamental para este fin es la <strong>identificaci√≥n de sustantivos</strong>. Imaginemos que el cliente nos entrega el siguiente requerimiento: <em>"Un usuario se acerca al cajero autom√°tico, introduce su tarjeta, el sistema valida su identidad y luego el usuario retira dinero de su cuenta consultando el saldo disponible"</em>.</p>

<h3>3.11.1 An√°lisis Ling√º√≠stico y Modelado de Clases</h3>
<p>Bajo la metodolog√≠a de <strong>Deitel</strong>, el primer paso es extraer los sustantivos y verbos del relato. Los sustantivos representan los candidatos a ser <strong>Clases</strong>, mientras que los verbos sugieren las <strong>Funciones Miembro</strong>. Este proceso no es autom√°tico; requiere un juicio de ingenier√≠a para filtrar qu√© entidades son relevantes para el dominio del problema.</p>

<div class="table-responsive">
    <table>
        <thead>
            <tr>
                <th>Categor√≠a Gramatical</th>
                <th>Candidatos Identificados</th>
                <th>Rol en la <span class="abbr" data-title="POO: Programaci√≥n Orientada a Objetos">POO</span></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Sustantivos</strong></td>
                <td>Cajero (ATM), Usuario, Tarjeta, Cuenta, Dinero, Pantalla, Teclado.</td>
                <td><strong>Clases:</strong> Representan las entidades con estado y comportamiento.</td>
            </tr>
            <tr>
                <td><strong>Verbos</strong></td>
                <td>Retirar, Validar, Consultar, Introducir, Dispensar.</td>
                <td><strong>Funciones Miembro:</strong> Definen las acciones que los objetos pueden realizar.</td>
            </tr>
        </tbody>
    </table>
</div>

<h3>3.11.2 La Perspectiva de Dise√±o Industrial (O'Reilly)</h3>
<p><strong>O'Reilly</strong> (<em>Practical C++ Programming</em>) complementa este enfoque se√±alando que el dise√±o de un sistema como un ATM debe ser modular y resistente a fallos. No basta con identificar la clase <code>Cajero</code>; debemos pensar en la <strong>composici√≥n</strong>. Un <code>ATM</code> no <em>es</em> una <code>Pantalla</code>, sino que <em>tiene</em> una <code>Pantalla</code> y <em>tiene</em> un <code>Dispensador</code>. Esta distinci√≥n es vital para la reutilizaci√≥n: si el banco decide cambiar el modelo de pantalla por uno t√°ctil, solo deber√≠amos modificar la clase <code>Pantalla</code>, manteniendo intacta la l√≥gica de la clase <code>Cajero</code>.</p>

<p>Ustedes, como futuros profesionales, deben evitar la creaci√≥n de "clases Dios" (clases que hacen todo). <strong>O'Reilly</strong> advierte que la robustez proviene de distribuir responsabilidades. Por ejemplo, la validaci√≥n del PIN no deber√≠a ser responsabilidad de la clase <code>Teclado</code>, sino de la clase <code>BaseDeDatosBanco</code> o de la entidad <code>Cuenta</code>.</p>

<h3>3.11.3 Metodolog√≠as Activas: El Modelado como Proceso Social</h3>
<p>El <strong>Cuaderno de notebookLM sobre educaci√≥n y metodolog√≠as activas</strong> sugiere que la identificaci√≥n de clases en un ATM es un escenario ideal para el <strong>Aprendizaje Basado en Problemas (ABP)</strong>. En lugar de recibir la soluci√≥n terminada, la metodolog√≠a activa propone que ustedes realicen una "simulaci√≥n de roles". Al actuar como las diferentes piezas del cajero, los estudiantes descubren qu√© informaci√≥n necesita cada objeto para cumplir su funci√≥n. Esta t√©cnica de <em>andamiaje cognitivo</em> facilita la comprensi√≥n de conceptos abstractos como la <span class="abbr" data-title="Encapsulaci√≥n: Ocultamiento de la complejidad interna de un objeto">encapsulaci√≥n</span>.</p>

<p>En las universidades argentinas, este ejercicio suele acompa√±arse de debates sobre la <strong>cohesi√≥n</strong>. Si la clase <code>Cajero</code> intenta manejar la impresi√≥n del recibo y la validaci√≥n de la tarjeta al mismo tiempo, estamos ante una baja cohesi√≥n. El cuaderno de educaci√≥n resalta que el aprendizaje significativo ocurre cuando el alumno comprende que una clase bien dise√±ada debe tener una √∫nica responsabilidad clara.</p>

<h3>3.11.4 UX/UI en el Dise√±o de Sistemas Cr√≠ticos</h3>
<p>Integrando el <strong>Cuaderno de notebookLM sobre UX UI</strong>, debemos recordar que un ATM es, ante todo, una interfaz humana. Las clases <code>Pantalla</code> y <code>Teclado</code> no son solo perif√©ricos; son los puntos de contacto que determinan la <span class="abbr" data-title="Carga Cognitiva: Esfuerzo mental requerido para completar una tarea">carga cognitiva</span> del usuario. Un dise√±o de software deficiente en estas clases puede inducir a errores costosos (ej. retirar una cantidad de dinero equivocada).</p>

<p>Desde la UX, cada funci√≥n miembro como <code>mostrarMenu()</code> debe estar dise√±ada pensando en la claridad y la accesibilidad. Si el sistema de software tarda demasiado en procesar un comando (debido a una mala implementaci√≥n de las funciones miembro en el <em>backend</em>), la experiencia del usuario se degrada. El cuaderno de UX UI enfatiza que el dise√±o orientado a objetos debe facilitar un flujo de interacci√≥n fluido y libre de ambig√ºedades.</p>

<h3>3.11.5 Paralelismo con el Desarrollo Web Moderno</h3>
<p>Aunque el ATM es un dispositivo f√≠sico, su arquitectura de software es la base de las aplicaciones web transaccionales. El <strong>Cuaderno de notebookLM sobre desarrollo web</strong> menciona que las clases identificadas en este ejemplo (<code>Usuario</code>, <code>Cuenta</code>, <code>Transaccion</code>) son las mismas que encontramos en el <em>backend</em> de un <em>home banking</em> o una billetera virtual. La separaci√≥n entre la interfaz (el cajero) y la l√≥gica de negocio (el servidor del banco) es un precursor directo del modelo Cliente-Servidor que domina la web actual.</p>

<p>Comprender c√≥mo C++ gestiona estos objetos a bajo nivel les da una ventaja competitiva √∫nica para optimizar procesos cr√≠ticos de concurrencia y seguridad en la nube, donde miles de "objetos ATM" virtuales interact√∫an simult√°neamente con una base de datos centralizada.</p>

<h3>3.11.6 Hacia el Diagrama UML Profesional</h3>
<p>Finalmente, este an√°lisis de sustantivos y verbos se vuelca en un diagrama <span class="abbr" data-title="UML: Unified Modeling Language. Est√°ndar visual para especificar sistemas de software">UML</span>. <strong>Deitel</strong> explica que el UML es el lenguaje universal de los ingenieros de software. En un diagrama de clases, ver√°n cajas que representan sus sustantivos, con sus atributos (datos) en la parte superior y sus funciones miembro (verbos) en la inferior, conectadas por l√≠neas que indican c√≥mo interact√∫an.</p>

<div class="code-block">
    <pre>// Pseudo-c√≥digo de la estructura identificada


class CajeroAutomatico {
public:
void ejecutar(); // Funci√≥n principal (Verbo)
private:
Pantalla pantalla;       // Composici√≥n (Sustantivo)
Teclado teclado;         // Composici√≥n (Sustantivo)
DispensadorEfectivo dispensador; // Composici√≥n
};</pre>
</div>

<p>En conclusi√≥n, el ejemplo del ATM no es solo una curiosidad acad√©mica; es el laboratorio donde se forja el criterio del ingeniero. Al separar correctamente las clases y sus funciones, como proponen <strong>Deitel</strong> y <strong>O'Reilly</strong>, estamos creando un sistema escalable, seguro y f√°cil de mantener, pilares indiscutibles de la ingenier√≠a de software profesional.</p>

<button class="ref-btn" onclick="showRef('3.11')">Referencia Bibliogr√°fica</button>


</section>

<section id="sec312">
<h2><span class="icon">üèÅ</span>3.12 Repaso Integral y S√≠ntesis del Cap√≠tulo</h2>

<p>Hemos recorrido los fundamentos de la construcci√≥n de clases en C++, transitando desde la sintaxis b√°sica hasta la arquitectura modular de nivel industrial. Seg√∫n el PDF de <strong>Deitel</strong> (<em>C++ C√≥mo Programar</em>), este cap√≠tulo constituye el cimiento sobre el cual se erige todo el desarrollo de software moderno. La Programaci√≥n Orientada a Objetos (<span class="abbr" data-title="POO: Paradigma de programaci√≥n basado en objetos que contienen datos y comportamientos">POO</span>) no es solo una forma de organizar c√≥digo, sino una metodolog√≠a para modelar la realidad mediante entidades aut√≥nomas que poseen estado y comportamiento.</p>

<h3>3.12.1 Pilares de la Ingenier√≠a de Objetos</h3>
<p>A modo de s√≠ntesis, es imperativo que ustedes, como futuros ingenieros, retengan los tres conceptos fundamentales que hemos explorado:</p>
<ul>
    <li><strong>La Clase como Tipo de Dato Abstracto (ADT):</strong> Siguiendo a <strong>Deitel</strong>, una clase es un molde que define un nuevo tipo de dato. Es el "plano" que especifica qu√© datos (atributos) y qu√© acciones (funciones miembro) tendr√° cada objeto instanciado.</li>
    <li><strong>Encapsulamiento y Ocultamiento:</strong> <strong>O'Reilly</strong> (<em>Practical C++ Programming</em>) destaca que la robustez sist√©mica se logra protegiendo el estado interno del objeto mediante el modificador <code>private</code>. El acceso a estos datos debe estar estrictamente mediado por funciones <code>public</code> (Getters y Setters), lo que garantiza la integridad y facilita la depuraci√≥n.</li>
    <li><strong>El Contrato de Interfaz:</strong> La separaci√≥n entre el archivo de cabecera (<code>.h</code>) y el de implementaci√≥n (<code>.cpp</code>) permite que el software sea escalable. Ustedes definen un contrato de comportamiento que el resto del sistema utiliza, permitiendo que la l√≥gica interna evolucione sin romper las dependencias externas.</li>
</ul>

<p>Desde la perspectiva del <strong>Cuaderno de notebookLM sobre UX UI</strong>, este dise√±o de clases debe entenderse como la creaci√≥n de una "interfaz para desarrolladores" (DX). Una clase bien dise√±ada minimiza la <span class="abbr" data-title="Carga Cognitiva: Cantidad de esfuerzo mental utilizado en la memoria de trabajo">carga cognitiva</span>; sus funciones miembro son autodescriptivas y su comportamiento es predecible, lo que reduce la fricci√≥n en el mantenimiento a largo plazo.</p>

<h3>3.12.2 Conexi√≥n Profesional: Del Aula a la Industria</h3>
<p>El <strong>Cuaderno de notebookLM sobre desarrollo web</strong> subraya que los principios de modularidad y validaci√≥n de datos que hemos estudiado en C++ son id√©nticos a los aplicados en el desarrollo de microservicios y componentes web modernos (como React o Angular). Aprender a validar una entrada en un <em>Setter</em> de C++ les da la disciplina necesaria para implementar l√≥gicas de negocio seguras en cualquier capa de un sistema distribuido, donde la confianza en los datos externos nunca debe ser absoluta.</p>

<p>Asimismo, el <strong>Cuaderno de notebookLM sobre educaci√≥n y metodolog√≠as activas</strong> nos recuerda que el aprendizaje de la ingenier√≠a es un proceso constructivo. No basta con memorizar la sintaxis de un constructor; es necesario comprender <em>por qu√©</em> un objeto no debe nacer en un estado "basura". La educaci√≥n de ingenier√≠a en Argentina prioriza este <strong>pensamiento cr√≠tico</strong>: la capacidad de evaluar compensaciones entre rendimiento, legibilidad y seguridad.</p>

<h3>3.12.3 Desaf√≠o de Ingenier√≠a: Implementaci√≥n de la Clase Alumno</h3>
<p>Para consolidar estos conocimientos de manera activa, se propone la siguiente actividad pr√°ctica que simula un requerimiento acad√©mico real. Deber√°n dise√±ar una clase que cumpla con est√°ndares profesionales de validaci√≥n y encapsulamiento.</p>

<div class="code-block">
    <pre>// Requerimiento Acad√©mico Profesional


class Alumno {
public:
// Constructor que garantiza estado inicial v√°lido
Alumno(int idLegajo, double notaInicial) {
establecerLegajo(idLegajo);
establecerPromedio(notaInicial);
}

// Setter con validaci√≥n de negocio (Deitel)
void establecerPromedio(double valor) {
    if (valor >= 0.0 && valor <= 10.0) {
        promedio = valor;
    } else {
        promedio = 0.0; // Estado seguro por defecto
        std::cerr << "Error: Promedio fuera de rango [0-10]." << std::endl;
    }
}

// Getter marcado como const (O'Reilly)
double obtenerPromedio() const {
    return promedio;
}

void establecerLegajo(int id) {
    legajo = (id > 0) ? id : 0;
}


private:
int legajo;      // Atributo protegido
double promedio; // Atributo protegido (Invariante de la clase)
};</pre>
</div>

<p><strong>An√°lisis del Desaf√≠o:</strong> Noten c√≥mo el constructor delega la responsabilidad a las funciones <code>establecer</code>. Esto, como se√±ala <strong>O'Reilly</strong>, evita la duplicaci√≥n de c√≥digo de validaci√≥n y asegura que las reglas de negocio se apliquen tanto en la creaci√≥n como en la modificaci√≥n del objeto. Adem√°s, el uso de <code>const</code> en los <em>Getters</em> es una marca de excelencia t√©cnica, informando al compilador que la funci√≥n es de solo lectura.</p>

<h3>3.12.4 Reflexi√≥n Final</h3>
<p>Ustedes tienen ahora las herramientas para dejar de ser "codificadores" y empezar a ser "arquitectos de sistemas". La elegancia de C++ reside en su capacidad para ofrecer un control total del hardware con la abstracci√≥n poderosa de los objetos. Como concluye <strong>Deitel</strong>, dominar las clases es el primer paso para construir sistemas complejos, desde motores de b√∫squeda hasta simuladores industriales o plataformas web de alto tr√°fico.</p>

<p>Recuerden la premisa del <strong>Cuaderno de Metodolog√≠as Activas</strong>: el conocimiento se fija mediante la pr√°ctica y la reflexi√≥n sobre el error. No teman a los fallos de compilaci√≥n; cada error de resoluci√≥n de √°mbito (<code>::</code>) o de punto y coma (<code>;</code>) es una lecci√≥n de precisi√≥n que los acerca a la maestr√≠a profesional. Han completado la introducci√≥n a los objetos; el resto del curso expandir√° estas fronteras hacia la herencia, el polimorfismo y las plantillas.</p>

<button class="ref-btn" onclick="showRef('3.12')">Referencia Bibliogr√°fica</button>


</section>


        <footer style="border-top: 1px solid var(--border); padding: 2rem 0; margin-top: 5rem; text-align: center; color: var(--text-secondary);">
            <p>&copy; 2024 - Herramienta Did√°ctica Universitaria para C++.</p>
            <p>Desarrollado siguiendo principios de UX/UI y Metodolog√≠as Activas.</p>
        </footer>
    </main>
</div>

<!-- Theme Toggle -->
<button class="theme-btn" id="themeToggle" title="Cambiar Tema">üåì</button>

<!-- Modal Referencias -->
<div id="refModal" class="modal">
    <div class="modal-content">
        <h3 id="refTitle">Referencia Acad√©mica</h3>
        <p id="refBody"></p>
        <button class="ref-btn" onclick="closeModal()" style="width:100%; padding:1rem; font-weight:bold;">Entendido</button>
    </div>
</div>

<script>
    // --- Referencias Bibliogr√°ficas ---
    const biblio = {
        "3": "Deitel, P. J., & Deitel, H. M. (2009). C++ C√≥mo Programar (6ta ed.). Cap√≠tulo 3: Introducci√≥n a las clases y los objetos. Pearson Educaci√≥n.",
        "3.1": "Deitel (2009), Secci√≥n 3.1, p√°g. 72. Evoluci√≥n del dise√±o centrado en funciones al dise√±o centrado en objetos.",
        "3.2": "Deitel (2009), Secci√≥n 3.2. Analog√≠a del autom√≥vil y conceptos de abstracci√≥n.",
        "3.3": "Cuaderno de NotebookLM sobre Metodolog√≠as Activas: Importancia del aprendizaje incremental y casos de estudio.",
        "3.4": "Practical C++ Programming (O'Reilly, 2003). Sintaxis de clases y manejo de √°mbitos p√∫blicos/privados.",
        "3.5": "Deitel (2009), Secci√≥n 3.5. Interacci√≥n de objetos mediante paso de mensajes (par√°metros).",
        "3.6": "Deitel (2009), Secci√≥n 3.6. El concepto de encapsulamiento y protecci√≥n de atributos.",
        "3.7": "Oualline, S. (2003). Practical C++ Programming. Constructores y destructores: Gesti√≥n del ciclo de vida.",
        "3.8": "Deitel (2009), Secci√≥n 3.8. Organizaci√≥n de archivos y directivas del preprocesador.",
        "3.9": "O'Reilly (2003), Cap. 13. Abstracci√≥n de datos y separaci√≥n de la interfaz (header files).",
        "3.10": "Deitel (2009), Secci√≥n 3.10. T√©cnicas de validaci√≥n y robustez en la entrada de datos.",
        "3.11": "Booch, G. (2005). El Lenguaje Unificado de Modelado (UML). Identificaci√≥n de clases y relaciones de dominio.",
        "3.12": "S√≠ntesis pedag√≥gica basada en el Cuaderno de NotebookLM sobre Educaci√≥n: Evaluaci√≥n formativa y repaso conceptual."
    };

    function showRef(id) {
        document.getElementById('refBody').innerText = biblio[id];
        document.getElementById('refModal').style.display = 'flex';
    }

    function closeModal() {
        document.getElementById('refModal').style.display = 'none';
    }

    // --- Persistencia de Tema ---
    const themeBtn = document.getElementById('themeToggle');
    const html = document.documentElement;

    const savedTheme = localStorage.getItem('theme') || 'light';
    html.setAttribute('data-theme', savedTheme);

    themeBtn.addEventListener('click', () => {
        const currentTheme = html.getAttribute('data-theme');
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        html.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
    });

// --- Navegaci√≥n Activa (Intersection Observer Optimizado) ---
    const sections = document.querySelectorAll('section');
    const navLinks = document.querySelectorAll('.nav-links a');

    // Ajustamos las opciones para manejar secciones muy largas
    const obsOptions = { 
        threshold: 0, // Se activa en cuanto entra el primer p√≠xel
        rootMargin: "-20% 0px -70% 0px" // Banda de detecci√≥n en la parte superior (donde se lee)
    };

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            // Eliminamos la restricci√≥n del ratio (0.1) para que funcione con textos largos
            if (entry.isIntersecting) {
                const activeId = entry.target.getAttribute('id');
                const activeLink = document.querySelector(`.nav-links a[href="#${activeId}"]`);
                
                if (activeLink) {
                    navLinks.forEach(link => link.classList.remove('active'));
                    activeLink.classList.add('active');
                    
                    // UX: Asegurar que el men√∫ lateral haga scroll si el enlace queda fuera de vista
                    activeLink.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
        });
    }, obsOptions);

    sections.forEach(s => observer.observe(s));

    // Cierre de modal al hacer clic fuera
    window.onclick = (e) => {
        if (e.target == document.getElementById('refModal')) closeModal();
    };
</script>

</body>
</html>
